/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{651:function(t,e,r){"use strict";r.d(e,"b",(function(){return o})),r.d(e,"a",(function(){return c}));var n=r(27);class o{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const l=new n.OrthographicCamera(-1,1,1,-1,0,1),h=new n.BufferGeometry;h.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),h.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2));class c{constructor(t){this._mesh=new n.Mesh(h,t)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,l)}get material(){return this._mesh.material}set material(t){this._mesh.material=t}}},652:function(t,e,r){"use strict";r.d(e,"a",(function(){return l}));var n=r(27),o=r(651);class l extends o.b{constructor(t,e){super(),this.textureID=void 0!==e?e:"tDiffuse",t instanceof n.ShaderMaterial?(this.uniforms=t.uniforms,this.material=t):t&&(this.uniforms=n.UniformsUtils.clone(t.uniforms),this.material=new n.ShaderMaterial({defines:Object.assign({},t.defines),uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader})),this.fsQuad=new o.a(this.material)}render(t,e,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(e),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),this.fsQuad.render(t))}}},654:function(t,e,r){"use strict";r.d(e,"a",(function(){return o}));var n=r(27);class o extends n.Loader{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(t){return new f(t)})),this.register((function(t){return new E(t)})),this.register((function(t){return new M(t)})),this.register((function(t){return new _(t)})),this.register((function(t){return new v(t)})),this.register((function(t){return new y(t)})),this.register((function(t){return new x(t)})),this.register((function(t){return new m(t)})),this.register((function(t){return new T(t)})),this.register((function(t){return new c(t)})),this.register((function(t){return new w(t)}))}load(t,e,r,o){const l=this;let h;h=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:n.LoaderUtils.extractUrlBase(t),this.manager.itemStart(t);const c=function(e){o?o(e):console.error(e),l.manager.itemError(t),l.manager.itemEnd(t)},d=new n.FileLoader(this.manager);d.setPath(this.path),d.setResponseType("arraybuffer"),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(t,(function(data){try{l.parse(data,h,(function(r){e(r),l.manager.itemEnd(t)}),c)}catch(t){c(t)}}),r,c)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(data,path,t,e){let content;const r={},o={};if("string"==typeof data)content=data;else{if(n.LoaderUtils.decodeText(new Uint8Array(data,0,4))===S){try{r[h.KHR_BINARY_GLTF]=new O(data)}catch(t){return void(e&&e(t))}content=r[h.KHR_BINARY_GLTF].content}else content=n.LoaderUtils.decodeText(new Uint8Array(data))}const l=JSON.parse(content);if(void 0===l.asset||l.asset.version[0]<2)return void(e&&e(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new ht(l,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let i=0;i<this.pluginCallbacks.length;i++){const t=this.pluginCallbacks[i](c);o[t.name]=t,r[t.name]=!0}if(l.extensionsUsed)for(let i=0;i<l.extensionsUsed.length;++i){const t=l.extensionsUsed[i],e=l.extensionsRequired||[];switch(t){case h.KHR_MATERIALS_UNLIT:r[t]=new d;break;case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:r[t]=new I;break;case h.KHR_DRACO_MESH_COMPRESSION:r[t]=new C(l,this.dracoLoader);break;case h.KHR_TEXTURE_TRANSFORM:r[t]=new P;break;case h.KHR_MESH_QUANTIZATION:r[t]=new D;break;default:e.indexOf(t)>=0&&void 0===o[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}c.setExtensions(r),c.setPlugins(o),c.parse(t,e)}parseAsync(data,path){const t=this;return new Promise((function(e,r){t.parse(data,path,e,r)}))}}function l(){let t={};return{get:function(e){return t[e]},add:function(e,object){t[e]=object},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const h={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class c{constructor(t){this.parser=t,this.name=h.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let r=0,n=e.length;r<n;r++){const n=e[r];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&t._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(t){const e=this.parser,r="light:"+t;let o=e.cache.get(r);if(o)return o;const l=e.json,h=((l.extensions&&l.extensions[this.name]||{}).lights||[])[t];let c;const d=new n.Color(16777215);void 0!==h.color&&d.fromArray(h.color);const m=void 0!==h.range?h.range:0;switch(h.type){case"directional":c=new n.DirectionalLight(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new n.PointLight(d),c.distance=m;break;case"spot":c=new n.SpotLight(d),c.distance=m,h.spot=h.spot||{},h.spot.innerConeAngle=void 0!==h.spot.innerConeAngle?h.spot.innerConeAngle:0,h.spot.outerConeAngle=void 0!==h.spot.outerConeAngle?h.spot.outerConeAngle:Math.PI/4,c.angle=h.spot.outerConeAngle,c.penumbra=1-h.spot.innerConeAngle/h.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+h.type)}return c.position.set(0,0,0),c.decay=2,void 0!==h.intensity&&(c.intensity=h.intensity),c.name=e.createUniqueName(h.name||"light_"+t),o=Promise.resolve(c),e.cache.add(r,o),o}createNodeAttachment(t){const e=this,r=this.parser,n=r.json.nodes[t],o=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===o?null:this._loadLight(o).then((function(t){return r._getNodeRef(e.cache,o,t)}))}}class d{constructor(){this.name=h.KHR_MATERIALS_UNLIT}getMaterialType(){return n.MeshBasicMaterial}extendParams(t,e,r){const o=[];t.color=new n.Color(1,1,1),t.opacity=1;const l=e.pbrMetallicRoughness;if(l){if(Array.isArray(l.baseColorFactor)){const e=l.baseColorFactor;t.color.fromArray(e),t.opacity=e[3]}void 0!==l.baseColorTexture&&o.push(r.assignTexture(t,"map",l.baseColorTexture,n.sRGBEncoding))}return Promise.all(o)}}class m{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const r=this.parser.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name].emissiveStrength;return void 0!==n&&(e.emissiveIntensity=n),Promise.resolve()}}class f{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(t,e){const r=this.parser,o=r.json.materials[t];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],h=o.extensions[this.name];if(void 0!==h.clearcoatFactor&&(e.clearcoat=h.clearcoatFactor),void 0!==h.clearcoatTexture&&l.push(r.assignTexture(e,"clearcoatMap",h.clearcoatTexture)),void 0!==h.clearcoatRoughnessFactor&&(e.clearcoatRoughness=h.clearcoatRoughnessFactor),void 0!==h.clearcoatRoughnessTexture&&l.push(r.assignTexture(e,"clearcoatRoughnessMap",h.clearcoatRoughnessTexture)),void 0!==h.clearcoatNormalTexture&&(l.push(r.assignTexture(e,"clearcoatNormalMap",h.clearcoatNormalTexture)),void 0!==h.clearcoatNormalTexture.scale)){const t=h.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new n.Vector2(t,t)}return Promise.all(l)}}class _{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(t,e){const r=this.parser,o=r.json.materials[t];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[];e.sheenColor=new n.Color(0,0,0),e.sheenRoughness=0,e.sheen=1;const h=o.extensions[this.name];return void 0!==h.sheenColorFactor&&e.sheenColor.fromArray(h.sheenColorFactor),void 0!==h.sheenRoughnessFactor&&(e.sheenRoughness=h.sheenRoughnessFactor),void 0!==h.sheenColorTexture&&l.push(r.assignTexture(e,"sheenColorMap",h.sheenColorTexture,n.sRGBEncoding)),void 0!==h.sheenRoughnessTexture&&l.push(r.assignTexture(e,"sheenRoughnessMap",h.sheenRoughnessTexture)),Promise.all(l)}}class v{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(t,e){const r=this.parser,n=r.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],l=n.extensions[this.name];return void 0!==l.transmissionFactor&&(e.transmission=l.transmissionFactor),void 0!==l.transmissionTexture&&o.push(r.assignTexture(e,"transmissionMap",l.transmissionTexture)),Promise.all(o)}}class y{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(t,e){const r=this.parser,o=r.json.materials[t];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],h=o.extensions[this.name];e.thickness=void 0!==h.thicknessFactor?h.thicknessFactor:0,void 0!==h.thicknessTexture&&l.push(r.assignTexture(e,"thicknessMap",h.thicknessTexture)),e.attenuationDistance=h.attenuationDistance||0;const c=h.attenuationColor||[1,1,1];return e.attenuationColor=new n.Color(c[0],c[1],c[2]),Promise.all(l)}}class x{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(t,e){const r=this.parser.json.materials[t];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name];return e.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class T{constructor(t){this.parser=t,this.name=h.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(t,e){const r=this.parser,o=r.json.materials[t];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],h=o.extensions[this.name];e.specularIntensity=void 0!==h.specularFactor?h.specularFactor:1,void 0!==h.specularTexture&&l.push(r.assignTexture(e,"specularIntensityMap",h.specularTexture));const c=h.specularColorFactor||[1,1,1];return e.specularColor=new n.Color(c[0],c[1],c[2]),void 0!==h.specularColorTexture&&l.push(r.assignTexture(e,"specularColorMap",h.specularColorTexture,n.sRGBEncoding)),Promise.all(l)}}class E{constructor(t){this.parser=t,this.name=h.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,r=e.json,n=r.textures[t];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name],l=e.options.ktx2Loader;if(!l){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,o.source,l)}}class M{constructor(t){this.parser=t,this.name=h.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,r=this.parser,n=r.json,o=n.textures[t];if(!o.extensions||!o.extensions[e])return null;const l=o.extensions[e],source=n.images[l.source];let h=r.textureLoader;if(source.uri){const t=r.options.manager.getHandler(source.uri);null!==t&&(h=t)}return this.detectSupport().then((function(o){if(o)return r.loadTextureImage(t,l.source,h);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",image.onload=image.onerror=function(){t(1===image.height)}}))),this.isSupported}}class w{constructor(t){this.name=h.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,r=e.bufferViews[t];if(r.extensions&&r.extensions[this.name]){const t=r.extensions[this.name],n=this.parser.getDependency("buffer",t.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([n,o.ready]).then((function(e){const r=t.byteOffset||0,n=t.byteLength||0,l=t.count,h=t.byteStride,c=new ArrayBuffer(l*h),source=new Uint8Array(e[0],r,n);return o.decodeGltfBuffer(new Uint8Array(c),l,h,source,t.mode,t.filter),c}))}return null}}const S="glTF",A=1313821514,R=5130562;class O{constructor(data){this.name=h.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(data,0,12);if(this.header={magic:n.LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==S)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const e=this.header.length-12,r=new DataView(data,12);let o=0;for(;o<e;){const t=r.getUint32(o,!0);o+=4;const e=r.getUint32(o,!0);if(o+=4,e===A){const e=new Uint8Array(data,12+o,t);this.content=n.LoaderUtils.decodeText(e)}else if(e===R){const e=12+o;this.body=data.slice(e,e+t)}o+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class C{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=h.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const r=this.json,n=this.dracoLoader,o=t.extensions[this.name].bufferView,l=t.extensions[this.name].attributes,h={},c={},d={};for(const t in l){const e=Z[t]||t.toLowerCase();h[e]=l[t]}for(const e in t.attributes){const n=Z[e]||e.toLowerCase();if(void 0!==l[e]){const o=r.accessors[t.attributes[e]],l=Q[o.componentType];d[n]=l,c[n]=!0===o.normalized}}return e.getDependency("bufferView",o).then((function(t){return new Promise((function(e){n.decodeDracoFile(t,(function(t){for(const e in t.attributes){const r=t.attributes[e],n=c[e];void 0!==n&&(r.normalized=n)}e(t)}),h,d)}))}))}}class P{constructor(){this.name=h.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return void 0!==e.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===e.offset&&void 0===e.rotation&&void 0===e.scale||(t=t.clone(),void 0!==e.offset&&t.offset.fromArray(e.offset),void 0!==e.rotation&&(t.rotation=e.rotation),void 0!==e.scale&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class L extends n.MeshStandardMaterial{constructor(t){super(),this.isGLTFSpecularGlossinessMaterial=!0;const e=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),r=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),o=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),l=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),h=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),c={specular:{value:(new n.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=c,this.onBeforeCompile=function(t){for(const e in c)t.uniforms[e]=c[e];t.fragmentShader=t.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",e).replace("#include <metalnessmap_pars_fragment>",r).replace("#include <roughnessmap_fragment>",o).replace("#include <metalnessmap_fragment>",l).replace("#include <lights_physical_fragment>",h)},Object.defineProperties(this,{specular:{get:function(){return c.specular.value},set:function(t){c.specular.value=t}},specularMap:{get:function(){return c.specularMap.value},set:function(t){c.specularMap.value=t,t?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return c.glossiness.value},set:function(t){c.glossiness.value=t}},glossinessMap:{get:function(){return c.glossinessMap.value},set:function(t){c.glossinessMap.value=t,t?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(t)}copy(source){return super.copy(source),this.specularMap=source.specularMap,this.specular.copy(source.specular),this.glossinessMap=source.glossinessMap,this.glossiness=source.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class I{constructor(){this.name=h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return L}extendParams(t,e,r){const o=e.extensions[this.name];t.color=new n.Color(1,1,1),t.opacity=1;const l=[];if(Array.isArray(o.diffuseFactor)){const e=o.diffuseFactor;t.color.fromArray(e),t.opacity=e[3]}if(void 0!==o.diffuseTexture&&l.push(r.assignTexture(t,"map",o.diffuseTexture,n.sRGBEncoding)),t.emissive=new n.Color(0,0,0),t.glossiness=void 0!==o.glossinessFactor?o.glossinessFactor:1,t.specular=new n.Color(1,1,1),Array.isArray(o.specularFactor)&&t.specular.fromArray(o.specularFactor),void 0!==o.specularGlossinessTexture){const e=o.specularGlossinessTexture;l.push(r.assignTexture(t,"glossinessMap",e)),l.push(r.assignTexture(t,"specularMap",e,n.sRGBEncoding))}return Promise.all(l)}createMaterial(t){const e=new L(t);return e.fog=!0,e.color=t.color,e.map=void 0===t.map?null:t.map,e.lightMap=null,e.lightMapIntensity=1,e.aoMap=void 0===t.aoMap?null:t.aoMap,e.aoMapIntensity=1,e.emissive=t.emissive,e.emissiveIntensity=void 0===t.emissiveIntensity?1:t.emissiveIntensity,e.emissiveMap=void 0===t.emissiveMap?null:t.emissiveMap,e.bumpMap=void 0===t.bumpMap?null:t.bumpMap,e.bumpScale=1,e.normalMap=void 0===t.normalMap?null:t.normalMap,e.normalMapType=n.TangentSpaceNormalMap,t.normalScale&&(e.normalScale=t.normalScale),e.displacementMap=null,e.displacementScale=1,e.displacementBias=0,e.specularMap=void 0===t.specularMap?null:t.specularMap,e.specular=t.specular,e.glossinessMap=void 0===t.glossinessMap?null:t.glossinessMap,e.glossiness=t.glossiness,e.alphaMap=null,e.envMap=void 0===t.envMap?null:t.envMap,e.envMapIntensity=1,e}}class D{constructor(){this.name=h.KHR_MESH_QUANTIZATION}}class U extends n.Interpolant{constructor(t,e,r,n){super(t,e,r,n)}copySampleValue_(t){const e=this.resultBuffer,r=this.sampleValues,n=this.valueSize,o=t*n*3+n;for(let i=0;i!==n;i++)e[i]=r[o+i];return e}}U.prototype.beforeStart_=U.prototype.copySampleValue_,U.prototype.afterEnd_=U.prototype.copySampleValue_,U.prototype.interpolate_=function(t,e,r,n){const o=this.resultBuffer,l=this.sampleValues,h=this.valueSize,c=2*h,d=3*h,td=n-e,p=(r-e)/td,m=p*p,f=m*p,_=t*d,v=_-d,y=-2*f+3*m,x=f-m,T=1-y,E=x-m+p;for(let i=0;i!==h;i++){const t=l[v+i+h],e=l[v+i+c]*td,r=l[_+i+h],n=l[_+i]*td;o[i]=T*t+E*e+y*r+x*n}return o};const F=new n.Quaternion;class B extends U{interpolate_(t,e,r,n){const o=super.interpolate_(t,e,r,n);return F.fromArray(o).normalize().toArray(o),o}}const N=0,k=1,z=2,H=3,V=4,G=5,j=6,Q={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},X={9728:n.NearestFilter,9729:n.LinearFilter,9984:n.NearestMipmapNearestFilter,9985:n.LinearMipmapNearestFilter,9986:n.NearestMipmapLinearFilter,9987:n.LinearMipmapLinearFilter},Y={33071:n.ClampToEdgeWrapping,33648:n.MirroredRepeatWrapping,10497:n.RepeatWrapping},K={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Z={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},W={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},J={CUBICSPLINE:void 0,LINEAR:n.InterpolateLinear,STEP:n.InterpolateDiscrete},$="OPAQUE",tt="MASK",et="BLEND";function st(t,object,e){for(const r in e.extensions)void 0===t[r]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[r]=e.extensions[r])}function it(object,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(object.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function nt(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let i=0,r=e.weights.length;i<r;i++)t.morphTargetInfluences[i]=e.weights[i];if(e.extras&&Array.isArray(e.extras.targetNames)){const r=e.extras.targetNames;if(t.morphTargetInfluences.length===r.length){t.morphTargetDictionary={};for(let i=0,e=r.length;i<e;i++)t.morphTargetDictionary[r[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function at(t){const e=t.extensions&&t.extensions[h.KHR_DRACO_MESH_COMPRESSION];let r;return r=e?"draco:"+e.bufferView+":"+e.indices+":"+ot(e.attributes):t.indices+":"+ot(t.attributes)+":"+t.mode,r}function ot(t){let e="";const r=Object.keys(t).sort();for(let i=0,n=r.length;i<n;i++)e+=r[i]+":"+t[r[i]]+";";return e}function lt(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class ht{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new l,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const r=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),o=navigator.userAgent.indexOf("Firefox")>-1,h=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||r||o&&h<98?this.textureLoader=new n.TextureLoader(this.options.manager):this.textureLoader=new n.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new n.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const r=this,n=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll((function(t){return t._markDefs&&t._markDefs()})),Promise.all(this._invokeAll((function(t){return t.beforeRoot&&t.beforeRoot()}))).then((function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])})).then((function(e){const l={scene:e[0][n.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:n.asset,parser:r,userData:{}};st(o,l,n),it(l,n),Promise.all(r._invokeAll((function(t){return t.afterRoot&&t.afterRoot(l)}))).then((function(){t(l)}))})).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],r=this.json.meshes||[];for(let r=0,n=e.length;r<n;r++){const n=e[r].joints;for(let i=0,e=n.length;i<e;i++)t[n[i]].isBone=!0}for(let e=0,n=t.length;e<n;e++){const n=t[e];void 0!==n.mesh&&(this._addNodeRef(this.meshCache,n.mesh),void 0!==n.skin&&(r[n.mesh].isSkinnedMesh=!0)),void 0!==n.camera&&this._addNodeRef(this.cameraCache,n.camera)}}_addNodeRef(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,object){if(t.refs[e]<=1)return object;const r=object.clone(),n=(t,e)=>{const r=this.associations.get(t);null!=r&&this.associations.set(e,r);for(const[i,r]of t.children.entries())n(r,e.children[i])};return n(object,r),r.name+="_instance_"+t.uses[e]++,r}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let i=0;i<e.length;i++){const r=t(e[i]);if(r)return r}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const r=[];for(let i=0;i<e.length;i++){const n=t(e[i]);n&&r.push(n)}return r}getDependency(t,e){const r=t+":"+e;let n=this.cache.get(r);if(!n){switch(t){case"scene":n=this.loadScene(e);break;case"node":n=this.loadNode(e);break;case"mesh":n=this._invokeOne((function(t){return t.loadMesh&&t.loadMesh(e)}));break;case"accessor":n=this.loadAccessor(e);break;case"bufferView":n=this._invokeOne((function(t){return t.loadBufferView&&t.loadBufferView(e)}));break;case"buffer":n=this.loadBuffer(e);break;case"material":n=this._invokeOne((function(t){return t.loadMaterial&&t.loadMaterial(e)}));break;case"texture":n=this._invokeOne((function(t){return t.loadTexture&&t.loadTexture(e)}));break;case"skin":n=this.loadSkin(e);break;case"animation":n=this._invokeOne((function(t){return t.loadAnimation&&t.loadAnimation(e)}));break;case"camera":n=this.loadCamera(e);break;default:throw new Error("Unknown type: "+t)}this.cache.add(r,n)}return n}getDependencies(t){let e=this.cache.get(t);if(!e){const r=this,defs=this.json[t+("mesh"===t?"es":"s")]||[];e=Promise.all(defs.map((function(e,n){return r.getDependency(t,n)}))),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],r=this.fileLoader;if(e.type&&"arraybuffer"!==e.type)throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(void 0===e.uri&&0===t)return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);const o=this.options;return new Promise((function(t,l){r.load(n.LoaderUtils.resolveURL(e.uri,o.path),t,void 0,(function(){l(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))}))}))}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then((function(t){const r=e.byteLength||0,n=e.byteOffset||0;return t.slice(n,n+r)}))}loadAccessor(t){const e=this,r=this.json,o=this.json.accessors[t];if(void 0===o.bufferView&&void 0===o.sparse)return Promise.resolve(null);const l=[];return void 0!==o.bufferView?l.push(this.getDependency("bufferView",o.bufferView)):l.push(null),void 0!==o.sparse&&(l.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),l.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(l).then((function(t){const l=t[0],h=K[o.type],c=Q[o.componentType],d=c.BYTES_PER_ELEMENT,m=d*h,f=o.byteOffset||0,_=void 0!==o.bufferView?r.bufferViews[o.bufferView].byteStride:void 0,v=!0===o.normalized;let y,x;if(_&&_!==m){const t=Math.floor(f/_),r="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+t+":"+o.count;let m=e.cache.get(r);m||(y=new c(l,t*_,o.count*_/d),m=new n.InterleavedBuffer(y,_/d),e.cache.add(r,m)),x=new n.InterleavedBufferAttribute(m,h,f%_/d,v)}else y=null===l?new c(o.count*h):new c(l,f,o.count*h),x=new n.BufferAttribute(y,h,v);if(void 0!==o.sparse){const e=K.SCALAR,r=Q[o.sparse.indices.componentType],d=o.sparse.indices.byteOffset||0,m=o.sparse.values.byteOffset||0,f=new r(t[1],d,o.sparse.count*e),_=new c(t[2],m,o.sparse.count*h);null!==l&&(x=new n.BufferAttribute(x.array.slice(),x.itemSize,x.normalized));for(let i=0,t=f.length;i<t;i++){const t=f[i];if(x.setX(t,_[i*h]),h>=2&&x.setY(t,_[i*h+1]),h>=3&&x.setZ(t,_[i*h+2]),h>=4&&x.setW(t,_[i*h+3]),h>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return x}))}loadTexture(t){const e=this.json,r=this.options,n=e.textures[t].source,o=e.images[n];let l=this.textureLoader;if(o.uri){const t=r.manager.getHandler(o.uri);null!==t&&(l=t)}return this.loadTextureImage(t,n,l)}loadTextureImage(t,e,r){const o=this,l=this.json,h=l.textures[t],c=l.images[e],d=(c.uri||c.bufferView)+":"+h.sampler;if(this.textureCache[d])return this.textureCache[d];const m=this.loadImageSource(e,r).then((function(e){e.flipY=!1,h.name&&(e.name=h.name);const r=(l.samplers||{})[h.sampler]||{};return e.magFilter=X[r.magFilter]||n.LinearFilter,e.minFilter=X[r.minFilter]||n.LinearMipmapLinearFilter,e.wrapS=Y[r.wrapS]||n.RepeatWrapping,e.wrapT=Y[r.wrapT]||n.RepeatWrapping,o.associations.set(e,{textures:t}),e})).catch((function(){return null}));return this.textureCache[d]=m,m}loadImageSource(t,e){const r=this,o=this.json,l=this.options;if(void 0!==this.sourceCache[t])return this.sourceCache[t].then((t=>t.clone()));const h=o.images[t],c=self.URL||self.webkitURL;let d=h.uri||"",m=!1;if(void 0!==h.bufferView)d=r.getDependency("bufferView",h.bufferView).then((function(t){m=!0;const e=new Blob([t],{type:h.mimeType});return d=c.createObjectURL(e),d}));else if(void 0===h.uri)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const f=Promise.resolve(d).then((function(t){return new Promise((function(r,o){let h=r;!0===e.isImageBitmapLoader&&(h=function(t){const e=new n.Texture(t);e.needsUpdate=!0,r(e)}),e.load(n.LoaderUtils.resolveURL(t,l.path),h,void 0,o)}))})).then((function(t){var e;return!0===m&&c.revokeObjectURL(d),t.userData.mimeType=h.mimeType||((e=h.uri).search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":"image/png"),t})).catch((function(t){throw console.error("THREE.GLTFLoader: Couldn't load texture",d),t}));return this.sourceCache[t]=f,f}assignTexture(t,e,r,n){const o=this;return this.getDependency("texture",r.index).then((function(l){if(void 0===r.texCoord||0==r.texCoord||"aoMap"===e&&1==r.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+e+" not yet supported."),o.extensions[h.KHR_TEXTURE_TRANSFORM]){const t=void 0!==r.extensions?r.extensions[h.KHR_TEXTURE_TRANSFORM]:void 0;if(t){const e=o.associations.get(l);l=o.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(l,t),o.associations.set(l,e)}}return void 0!==n&&(l.encoding=n),t[e]=l,l}))}assignFinalMaterial(t){const e=t.geometry;let r=t.material;const o=void 0===e.attributes.tangent,l=void 0!==e.attributes.color,h=void 0===e.attributes.normal;if(t.isPoints){const t="PointsMaterial:"+r.uuid;let e=this.cache.get(t);e||(e=new n.PointsMaterial,n.Material.prototype.copy.call(e,r),e.color.copy(r.color),e.map=r.map,e.sizeAttenuation=!1,this.cache.add(t,e)),r=e}else if(t.isLine){const t="LineBasicMaterial:"+r.uuid;let e=this.cache.get(t);e||(e=new n.LineBasicMaterial,n.Material.prototype.copy.call(e,r),e.color.copy(r.color),this.cache.add(t,e)),r=e}if(o||l||h){let t="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(t+="specular-glossiness:"),o&&(t+="derivative-tangents:"),l&&(t+="vertex-colors:"),h&&(t+="flat-shading:");let e=this.cache.get(t);e||(e=r.clone(),l&&(e.vertexColors=!0),h&&(e.flatShading=!0),o&&(e.normalScale&&(e.normalScale.y*=-1),e.clearcoatNormalScale&&(e.clearcoatNormalScale.y*=-1)),this.cache.add(t,e),this.associations.set(e,this.associations.get(r))),r=e}r.aoMap&&void 0===e.attributes.uv2&&void 0!==e.attributes.uv&&e.setAttribute("uv2",e.attributes.uv),t.material=r}getMaterialType(){return n.MeshStandardMaterial}loadMaterial(t){const e=this,r=this.json,o=this.extensions,l=r.materials[t];let c;const d={},m=l.extensions||{},f=[];if(m[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const t=o[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];c=t.getMaterialType(),f.push(t.extendParams(d,l,e))}else if(m[h.KHR_MATERIALS_UNLIT]){const t=o[h.KHR_MATERIALS_UNLIT];c=t.getMaterialType(),f.push(t.extendParams(d,l,e))}else{const r=l.pbrMetallicRoughness||{};if(d.color=new n.Color(1,1,1),d.opacity=1,Array.isArray(r.baseColorFactor)){const t=r.baseColorFactor;d.color.fromArray(t),d.opacity=t[3]}void 0!==r.baseColorTexture&&f.push(e.assignTexture(d,"map",r.baseColorTexture,n.sRGBEncoding)),d.metalness=void 0!==r.metallicFactor?r.metallicFactor:1,d.roughness=void 0!==r.roughnessFactor?r.roughnessFactor:1,void 0!==r.metallicRoughnessTexture&&(f.push(e.assignTexture(d,"metalnessMap",r.metallicRoughnessTexture)),f.push(e.assignTexture(d,"roughnessMap",r.metallicRoughnessTexture))),c=this._invokeOne((function(e){return e.getMaterialType&&e.getMaterialType(t)})),f.push(Promise.all(this._invokeAll((function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,d)}))))}!0===l.doubleSided&&(d.side=n.DoubleSide);const _=l.alphaMode||$;if(_===et?(d.transparent=!0,d.depthWrite=!1):(d.transparent=!1,_===tt&&(d.alphaTest=void 0!==l.alphaCutoff?l.alphaCutoff:.5)),void 0!==l.normalTexture&&c!==n.MeshBasicMaterial&&(f.push(e.assignTexture(d,"normalMap",l.normalTexture)),d.normalScale=new n.Vector2(1,1),void 0!==l.normalTexture.scale)){const t=l.normalTexture.scale;d.normalScale.set(t,t)}return void 0!==l.occlusionTexture&&c!==n.MeshBasicMaterial&&(f.push(e.assignTexture(d,"aoMap",l.occlusionTexture)),void 0!==l.occlusionTexture.strength&&(d.aoMapIntensity=l.occlusionTexture.strength)),void 0!==l.emissiveFactor&&c!==n.MeshBasicMaterial&&(d.emissive=(new n.Color).fromArray(l.emissiveFactor)),void 0!==l.emissiveTexture&&c!==n.MeshBasicMaterial&&f.push(e.assignTexture(d,"emissiveMap",l.emissiveTexture,n.sRGBEncoding)),Promise.all(f).then((function(){let r;return r=c===L?o[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(d):new c(d),l.name&&(r.name=l.name),it(r,l),e.associations.set(r,{materials:t}),l.extensions&&st(o,r,l),r}))}createUniqueName(t){const e=n.PropertyBinding.sanitizeNodeName(t||"");let r=e;for(let i=1;this.nodeNamesUsed[r];++i)r=e+"_"+i;return this.nodeNamesUsed[r]=!0,r}loadGeometries(t){const e=this,r=this.extensions,o=this.primitiveCache;function l(t){return r[h.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,e).then((function(r){return ut(r,t,e)}))}const c=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],d=at(r),m=o[d];if(m)c.push(m.promise);else{let t;t=r.extensions&&r.extensions[h.KHR_DRACO_MESH_COMPRESSION]?l(r):ut(new n.BufferGeometry,r,e),o[d]={primitive:r,promise:t},c.push(t)}}return Promise.all(c)}loadMesh(t){const e=this,r=this.json,o=this.extensions,l=r.meshes[t],h=l.primitives,c=[];for(let i=0,t=h.length;i<t;i++){const t=void 0===h[i].material?(void 0===(d=this.cache).DefaultMaterial&&(d.DefaultMaterial=new n.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:n.FrontSide})),d.DefaultMaterial):this.getDependency("material",h[i].material);c.push(t)}var d;return c.push(e.loadGeometries(h)),Promise.all(c).then((function(r){const c=r.slice(0,r.length-1),d=r[r.length-1],m=[];for(let i=0,r=d.length;i<r;i++){const r=d[i],f=h[i];let _;const v=c[i];if(f.mode===V||f.mode===G||f.mode===j||void 0===f.mode)_=!0===l.isSkinnedMesh?new n.SkinnedMesh(r,v):new n.Mesh(r,v),!0!==_.isSkinnedMesh||_.geometry.attributes.skinWeight.normalized||_.normalizeSkinWeights(),f.mode===G?_.geometry=pt(_.geometry,n.TriangleStripDrawMode):f.mode===j&&(_.geometry=pt(_.geometry,n.TriangleFanDrawMode));else if(f.mode===k)_=new n.LineSegments(r,v);else if(f.mode===H)_=new n.Line(r,v);else if(f.mode===z)_=new n.LineLoop(r,v);else{if(f.mode!==N)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+f.mode);_=new n.Points(r,v)}Object.keys(_.geometry.morphAttributes).length>0&&nt(_,l),_.name=e.createUniqueName(l.name||"mesh_"+t),it(_,l),f.extensions&&st(o,_,f),e.assignFinalMaterial(_),m.push(_)}for(let i=0,r=m.length;i<r;i++)e.associations.set(m[i],{meshes:t,primitives:i});if(1===m.length)return m[0];const f=new n.Group;e.associations.set(f,{meshes:t});for(let i=0,t=m.length;i<t;i++)f.add(m[i]);return f}))}loadCamera(t){let e;const r=this.json.cameras[t],o=r[r.type];if(o)return"perspective"===r.type?e=new n.PerspectiveCamera(n.MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):"orthographic"===r.type&&(e=new n.OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),r.name&&(e.name=this.createUniqueName(r.name)),it(e,r),Promise.resolve(e);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(t){const e=this.json.skins[t],r={joints:e.joints};return void 0===e.inverseBindMatrices?Promise.resolve(r):this.getDependency("accessor",e.inverseBindMatrices).then((function(t){return r.inverseBindMatrices=t,r}))}loadAnimation(t){const e=this.json.animations[t],r=[],o=[],l=[],h=[],c=[];for(let i=0,t=e.channels.length;i<t;i++){const t=e.channels[i],n=e.samplers[t.sampler],d=t.target,m=void 0!==d.node?d.node:d.id,input=void 0!==e.parameters?e.parameters[n.input]:n.input,output=void 0!==e.parameters?e.parameters[n.output]:n.output;r.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",input)),l.push(this.getDependency("accessor",output)),h.push(n),c.push(d)}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(l),Promise.all(h),Promise.all(c)]).then((function(r){const o=r[0],l=r[1],h=r[2],c=r[3],d=r[4],m=[];for(let i=0,t=o.length;i<t;i++){const t=o[i],e=l[i],r=h[i],f=c[i],_=d[i];if(void 0===t)continue;let v;switch(t.updateMatrix(),t.matrixAutoUpdate=!0,W[_.path]){case W.weights:v=n.NumberKeyframeTrack;break;case W.rotation:v=n.QuaternionKeyframeTrack;break;default:v=n.VectorKeyframeTrack}const y=t.name?t.name:t.uuid,x=void 0!==f.interpolation?J[f.interpolation]:n.InterpolateLinear,T=[];W[_.path]===W.weights?t.traverse((function(object){object.morphTargetInfluences&&T.push(object.name?object.name:object.uuid)})):T.push(y);let E=r.array;if(r.normalized){const t=lt(E.constructor),e=new Float32Array(E.length);for(let r=0,n=E.length;r<n;r++)e[r]=E[r]*t;E=e}for(let t=0,r=T.length;t<r;t++){const track=new v(T[t]+"."+W[_.path],e.array,E,x);"CUBICSPLINE"===f.interpolation&&(track.createInterpolant=function(t){return new(this instanceof n.QuaternionKeyframeTrack?B:U)(this.times,this.values,this.getValueSize()/3,t)},track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(track)}}const f=e.name?e.name:"animation_"+t;return new n.AnimationClip(f,void 0,m)}))}createNodeMesh(t){const e=this.json,r=this,n=e.nodes[t];return void 0===n.mesh?null:r.getDependency("mesh",n.mesh).then((function(t){const e=r._getNodeRef(r.meshCache,n.mesh,t);return void 0!==n.weights&&e.traverse((function(t){if(t.isMesh)for(let i=0,e=n.weights.length;i<e;i++)t.morphTargetInfluences[i]=n.weights[i]})),e}))}loadNode(t){const e=this.json,r=this.extensions,o=this,l=e.nodes[t],h=l.name?o.createUniqueName(l.name):"";return function(){const e=[],r=o._invokeOne((function(e){return e.createNodeMesh&&e.createNodeMesh(t)}));return r&&e.push(r),void 0!==l.camera&&e.push(o.getDependency("camera",l.camera).then((function(t){return o._getNodeRef(o.cameraCache,l.camera,t)}))),o._invokeAll((function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)})).forEach((function(t){e.push(t)})),Promise.all(e)}().then((function(e){let c;if(c=!0===l.isBone?new n.Bone:e.length>1?new n.Group:1===e.length?e[0]:new n.Object3D,c!==e[0])for(let i=0,t=e.length;i<t;i++)c.add(e[i]);if(l.name&&(c.userData.name=l.name,c.name=h),it(c,l),l.extensions&&st(r,c,l),void 0!==l.matrix){const t=new n.Matrix4;t.fromArray(l.matrix),c.applyMatrix4(t)}else void 0!==l.translation&&c.position.fromArray(l.translation),void 0!==l.rotation&&c.quaternion.fromArray(l.rotation),void 0!==l.scale&&c.scale.fromArray(l.scale);return o.associations.has(c)||o.associations.set(c,{}),o.associations.get(c).nodes=t,c}))}loadScene(t){const e=this.json,r=this.extensions,o=this.json.scenes[t],l=this,h=new n.Group;o.name&&(h.name=l.createUniqueName(o.name)),it(h,o),o.extensions&&st(r,h,o);const c=o.nodes||[],d=[];for(let i=0,t=c.length;i<t;i++)d.push(ct(c[i],h,e,l));return Promise.all(d).then((function(){return l.associations=(t=>{const e=new Map;for(const[t,r]of l.associations)(t instanceof n.Material||t instanceof n.Texture)&&e.set(t,r);return t.traverse((t=>{const r=l.associations.get(t);null!=r&&e.set(t,r)})),e})(h),h}))}}function ct(t,e,r,o){const l=r.nodes[t];return o.getDependency("node",t).then((function(t){if(void 0===l.skin)return t;let e;return o.getDependency("skin",l.skin).then((function(t){e=t;const r=[];for(let i=0,t=e.joints.length;i<t;i++)r.push(o.getDependency("node",e.joints[i]));return Promise.all(r)})).then((function(r){return t.traverse((function(t){if(!t.isMesh)return;const o=[],l=[];for(let t=0,h=r.length;t<h;t++){const h=r[t];if(h){o.push(h);const r=new n.Matrix4;void 0!==e.inverseBindMatrices&&r.fromArray(e.inverseBindMatrices.array,16*t),l.push(r)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[t])}t.bind(new n.Skeleton(o,l),t.matrixWorld)})),t}))})).then((function(t){e.add(t);const n=[];if(l.children){const e=l.children;for(let i=0,l=e.length;i<l;i++){const l=e[i];n.push(ct(l,t,r,o))}}return Promise.all(n)}))}function ut(t,e,r){const o=e.attributes,l=[];function h(e,n){return r.getDependency("accessor",e).then((function(e){t.setAttribute(n,e)}))}for(const e in o){const r=Z[e]||e.toLowerCase();r in t.attributes||l.push(h(o[e],r))}if(void 0!==e.indices&&!t.index){const n=r.getDependency("accessor",e.indices).then((function(e){t.setIndex(e)}));l.push(n)}return it(t,e),function(t,e,r){const o=e.attributes,l=new n.Box3;if(void 0===o.POSITION)return;{const t=r.json.accessors[o.POSITION],e=t.min,h=t.max;if(void 0===e||void 0===h)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(l.set(new n.Vector3(e[0],e[1],e[2]),new n.Vector3(h[0],h[1],h[2])),t.normalized){const e=lt(Q[t.componentType]);l.min.multiplyScalar(e),l.max.multiplyScalar(e)}}const h=e.targets;if(void 0!==h){const t=new n.Vector3,e=new n.Vector3;for(let i=0,n=h.length;i<n;i++){const n=h[i];if(void 0!==n.POSITION){const o=r.json.accessors[n.POSITION],l=o.min,h=o.max;if(void 0!==l&&void 0!==h){if(e.setX(Math.max(Math.abs(l[0]),Math.abs(h[0]))),e.setY(Math.max(Math.abs(l[1]),Math.abs(h[1]))),e.setZ(Math.max(Math.abs(l[2]),Math.abs(h[2]))),o.normalized){const t=lt(Q[o.componentType]);e.multiplyScalar(t)}t.max(e)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}l.expandByVector(t)}t.boundingBox=l;const c=new n.Sphere;l.getCenter(c.center),c.radius=l.min.distanceTo(l.max)/2,t.boundingSphere=c}(t,e,r),Promise.all(l).then((function(){return void 0!==e.targets?function(t,e,r){let n=!1,o=!1,l=!1;for(let i=0,t=e.length;i<t;i++){const t=e[i];if(void 0!==t.POSITION&&(n=!0),void 0!==t.NORMAL&&(o=!0),void 0!==t.COLOR_0&&(l=!0),n&&o&&l)break}if(!n&&!o&&!l)return Promise.resolve(t);const h=[],c=[],d=[];for(let i=0,m=e.length;i<m;i++){const m=e[i];if(n){const e=void 0!==m.POSITION?r.getDependency("accessor",m.POSITION):t.attributes.position;h.push(e)}if(o){const e=void 0!==m.NORMAL?r.getDependency("accessor",m.NORMAL):t.attributes.normal;c.push(e)}if(l){const e=void 0!==m.COLOR_0?r.getDependency("accessor",m.COLOR_0):t.attributes.color;d.push(e)}}return Promise.all([Promise.all(h),Promise.all(c),Promise.all(d)]).then((function(e){const r=e[0],h=e[1],c=e[2];return n&&(t.morphAttributes.position=r),o&&(t.morphAttributes.normal=h),l&&(t.morphAttributes.color=c),t.morphTargetsRelative=!0,t}))}(t,e.targets,r):t}))}function pt(t,e){let r=t.getIndex();if(null===r){const e=[],n=t.getAttribute("position");if(void 0===n)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let i=0;i<n.count;i++)e.push(i);t.setIndex(e),r=t.getIndex()}const o=r.count-2,l=[];if(e===n.TriangleFanDrawMode)for(let i=1;i<=o;i++)l.push(r.getX(0)),l.push(r.getX(i)),l.push(r.getX(i+1));else for(let i=0;i<o;i++)i%2==0?(l.push(r.getX(i)),l.push(r.getX(i+1)),l.push(r.getX(i+2))):(l.push(r.getX(i+2)),l.push(r.getX(i+1)),l.push(r.getX(i)));l.length/3!==o&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const h=t.clone();return h.setIndex(l),h}},655:function(t,e,r){"use strict";r.d(e,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"}},656:function(t,e,r){"use strict";r.d(e,"a",(function(){return l}));var n=r(27),o=r(651);class l extends o.b{constructor(t,e,r,o,l){super(),this.scene=t,this.camera=e,this.overrideMaterial=r,this.clearColor=o,this.clearAlpha=void 0!==l?l:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new n.Color}render(t,e,r){const n=t.autoClear;let o,l;t.autoClear=!1,void 0!==this.overrideMaterial&&(l=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(t.getClearColor(this._oldClearColor),o=t.getClearAlpha(),t.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&t.clearDepth(),t.setRenderTarget(this.renderToScreen?null:r),this.clear&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),t.render(this.scene,this.camera),this.clearColor&&t.setClearColor(this._oldClearColor,o),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=l),t.autoClear=n}}},657:function(t,e,r){"use strict";r.d(e,"a",(function(){return h}));var n=r(27),o=r(651),l=r(655);class h extends o.b{constructor(t,e,r,h){super(),this.renderScene=e,this.renderCamera=r,this.selectedObjects=void 0!==h?h:[],this.visibleEdgeColor=new n.Color(1,1,1),this.hiddenEdgeColor=new n.Color(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=void 0!==t?new n.Vector2(t.x,t.y):new n.Vector2(256,256);const c=Math.round(this.resolution.x/this.downSampleRatio),d=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new n.MeshDepthMaterial,this.depthMaterial.side=n.DoubleSide,this.depthMaterial.depthPacking=n.RGBADepthPacking,this.depthMaterial.blending=n.NoBlending,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=n.DoubleSide,this.prepareMaskMaterial.fragmentShader=function(t,e){const r=e.isPerspectiveCamera?"perspective":"orthographic";return t.replace(/DEPTH_TO_VIEW_Z/g,r+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new n.WebGLRenderTarget(c,d),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new n.WebGLRenderTarget(c,d),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new n.WebGLRenderTarget(Math.round(c/2),Math.round(d/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new n.WebGLRenderTarget(c,d),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new n.WebGLRenderTarget(Math.round(c/2),Math.round(d/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(c,d),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(c/2),Math.round(d/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===l.a&&console.error("THREE.OutlinePass relies on CopyShader");const m=l.a;this.copyUniforms=n.UniformsUtils.clone(m.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new n.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,blending:n.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new n.Color,this.oldClearAlpha=1,this.fsQuad=new o.a(null),this.tempPulseColor1=new n.Color,this.tempPulseColor2=new n.Color,this.textureMatrix=new n.Matrix4}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(t,e){this.renderTargetMaskBuffer.setSize(t,e),this.renderTargetDepthBuffer.setSize(t,e);let r=Math.round(t/this.downSampleRatio),n=Math.round(e/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(r,n),this.renderTargetBlurBuffer1.setSize(r,n),this.renderTargetEdgeBuffer1.setSize(r,n),this.separableBlurMaterial1.uniforms.texSize.value.set(r,n),r=Math.round(r/2),n=Math.round(n/2),this.renderTargetBlurBuffer2.setSize(r,n),this.renderTargetEdgeBuffer2.setSize(r,n),this.separableBlurMaterial2.uniforms.texSize.value.set(r,n)}changeVisibilityOfSelectedObjects(t){const e=this._visibilityCache;function r(object){object.isMesh&&(!0===t?object.visible=e.get(object):(e.set(object,object.visible),object.visible=t))}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(r)}}changeVisibilityOfNonSelectedObjects(t){const e=this._visibilityCache,r=[];function n(object){object.isMesh&&r.push(object)}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(n)}this.renderScene.traverse((function(object){if(object.isMesh||object.isSprite){let n=!1;for(let i=0;i<r.length;i++){if(r[i].id===object.id){n=!0;break}}if(!1===n){const r=object.visible;!1!==t&&!0!==e.get(object)||(object.visible=t),e.set(object,r)}}else(object.isPoints||object.isLine)&&(!0===t?object.visible=e.get(object):(e.set(object,object.visible),object.visible=t))}))}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(t,e,r,n,o){if(this.selectedObjects.length>0){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const e=t.autoClear;t.autoClear=!1,o&&t.state.buffers.stencil.setTest(!1),t.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const n=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,t.setRenderTarget(this.renderTargetDepthBuffer),t.clear(),t.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,t.setRenderTarget(this.renderTargetMaskBuffer),t.clear(),t.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=n,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,t.setRenderTarget(this.renderTargetMaskDownSampleBuffer),t.clear(),this.fsQuad.render(t),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const t=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(t),this.tempPulseColor2.multiplyScalar(t)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,t.setRenderTarget(this.renderTargetEdgeBuffer1),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=h.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,t.setRenderTarget(this.renderTargetBlurBuffer1),t.clear(),this.fsQuad.render(t),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=h.BlurDirectionY,t.setRenderTarget(this.renderTargetEdgeBuffer1),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=h.BlurDirectionX,t.setRenderTarget(this.renderTargetBlurBuffer2),t.clear(),this.fsQuad.render(t),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=h.BlurDirectionY,t.setRenderTarget(this.renderTargetEdgeBuffer2),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,o&&t.state.buffers.stencil.setTest(!0),t.setRenderTarget(r),this.fsQuad.render(t),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=e}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=r.texture,t.setRenderTarget(null),this.fsQuad.render(t))}getPrepareMaskMaterial(){return new n.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new n.Vector2(.5,.5)},textureMatrix:{value:null}},vertexShader:"#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",fragmentShader:"#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}"})}getEdgeDetectionMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},visibleEdgeColor:{value:new n.Vector3(1,1,1)},hiddenEdgeColor:{value:new n.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}"})}getSeperableBlurMaterial(t){return new n.ShaderMaterial({defines:{MAX_RADIUS:t},uniforms:{colorTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},direction:{value:new n.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}"})}getOverlayMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",blending:n.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}}h.BlurDirectionX=new n.Vector2(1,0),h.BlurDirectionY=new n.Vector2(0,1)},658:function(t,e,r){"use strict";r.d(e,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},resolution:{value:new(r(27).Vector2)(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t"}},659:function(t,e,r){"use strict";r.d(e,"a",(function(){return y}));var n=r(27);const o=new n.Raycaster,l=new n.Vector3,h=new n.Vector3,c=new n.Quaternion,d={X:new n.Vector3(1,0,0),Y:new n.Vector3(0,1,0),Z:new n.Vector3(0,0,1)},m={type:"change"},f={type:"mouseDown"},_={type:"mouseUp",mode:null},v={type:"objectChange"};class y extends n.Object3D{constructor(t,e){super(),void 0===e&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),e=document),this.visible=!1,this.domElement=e,this.domElement.style.touchAction="none";const r=new H;this._gizmo=r,this.add(r);const o=new V;this._plane=o,this.add(o);const l=this;function h(t,e){let n=e;Object.defineProperty(l,t,{get:function(){return void 0!==n?n:e},set:function(e){n!==e&&(n=e,o[t]=e,r[t]=e,l.dispatchEvent({type:t+"-changed",value:e}),l.dispatchEvent(m))}}),l[t]=e,o[t]=e,r[t]=e}h("camera",t),h("object",void 0),h("enabled",!0),h("axis",null),h("mode","translate"),h("translationSnap",null),h("rotationSnap",null),h("scaleSnap",null),h("space","world"),h("size",1),h("dragging",!1),h("showX",!0),h("showY",!0),h("showZ",!0);const c=new n.Vector3,d=new n.Vector3,f=new n.Quaternion,_=new n.Quaternion,v=new n.Vector3,y=new n.Quaternion,S=new n.Vector3,A=new n.Vector3,R=new n.Vector3,O=new n.Vector3;h("worldPosition",c),h("worldPositionStart",d),h("worldQuaternion",f),h("worldQuaternionStart",_),h("cameraPosition",v),h("cameraQuaternion",y),h("pointStart",S),h("pointEnd",A),h("rotationAxis",R),h("rotationAngle",0),h("eye",O),this._offset=new n.Vector3,this._startNorm=new n.Vector3,this._endNorm=new n.Vector3,this._cameraScale=new n.Vector3,this._parentPosition=new n.Vector3,this._parentQuaternion=new n.Quaternion,this._parentQuaternionInv=new n.Quaternion,this._parentScale=new n.Vector3,this._worldScaleStart=new n.Vector3,this._worldQuaternionInv=new n.Quaternion,this._worldScale=new n.Vector3,this._positionStart=new n.Vector3,this._quaternionStart=new n.Quaternion,this._scaleStart=new n.Vector3,this._getPointer=x.bind(this),this._onPointerDown=E.bind(this),this._onPointerHover=T.bind(this),this._onPointerMove=M.bind(this),this._onPointerUp=w.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(void 0===this.object||!0===this.dragging)return;o.setFromCamera(t,this.camera);const e=S(this._gizmo.picker[this.mode],o);this.axis=e?e.object.name:null}pointerDown(t){if(void 0!==this.object&&!0!==this.dragging&&0===t.button&&null!==this.axis){o.setFromCamera(t,this.camera);const e=S(this._plane,o,!0);e&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(e.point).sub(this.worldPositionStart)),this.dragging=!0,f.mode=this.mode,this.dispatchEvent(f)}}pointerMove(t){const e=this.axis,r=this.mode,object=this.object;let n=this.space;if("scale"===r?n="local":"E"!==e&&"XYZE"!==e&&"XYZ"!==e||(n="world"),void 0===object||null===e||!1===this.dragging||-1!==t.button)return;o.setFromCamera(t,this.camera);const f=S(this._plane,o,!0);if(f){if(this.pointEnd.copy(f.point).sub(this.worldPositionStart),"translate"===r)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===n&&"XYZ"!==e&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===e.indexOf("X")&&(this._offset.x=0),-1===e.indexOf("Y")&&(this._offset.y=0),-1===e.indexOf("Z")&&(this._offset.z=0),"local"===n&&"XYZ"!==e?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),object.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===n&&(object.position.applyQuaternion(c.copy(this._quaternionStart).invert()),-1!==e.search("X")&&(object.position.x=Math.round(object.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(object.position.y=Math.round(object.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(object.position.z=Math.round(object.position.z/this.translationSnap)*this.translationSnap),object.position.applyQuaternion(this._quaternionStart)),"world"===n&&(object.parent&&object.position.add(l.setFromMatrixPosition(object.parent.matrixWorld)),-1!==e.search("X")&&(object.position.x=Math.round(object.position.x/this.translationSnap)*this.translationSnap),-1!==e.search("Y")&&(object.position.y=Math.round(object.position.y/this.translationSnap)*this.translationSnap),-1!==e.search("Z")&&(object.position.z=Math.round(object.position.z/this.translationSnap)*this.translationSnap),object.parent&&object.position.sub(l.setFromMatrixPosition(object.parent.matrixWorld))));else if("scale"===r){if(-1!==e.search("XYZ")){let t=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(t*=-1),h.set(t,t,t)}else l.copy(this.pointStart),h.copy(this.pointEnd),l.applyQuaternion(this._worldQuaternionInv),h.applyQuaternion(this._worldQuaternionInv),h.divide(l),-1===e.search("X")&&(h.x=1),-1===e.search("Y")&&(h.y=1),-1===e.search("Z")&&(h.z=1);object.scale.copy(this._scaleStart).multiply(h),this.scaleSnap&&(-1!==e.search("X")&&(object.scale.x=Math.round(object.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Y")&&(object.scale.y=Math.round(object.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==e.search("Z")&&(object.scale.z=Math.round(object.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===r){this._offset.copy(this.pointEnd).sub(this.pointStart);const t=20/this.worldPosition.distanceTo(l.setFromMatrixPosition(this.camera.matrixWorld));"E"===e?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):"XYZE"===e?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(l.copy(this.rotationAxis).cross(this.eye))*t):"X"!==e&&"Y"!==e&&"Z"!==e||(this.rotationAxis.copy(d[e]),l.copy(d[e]),"local"===n&&l.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(l.cross(this.eye).normalize())*t),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===n&&"E"!==e&&"XYZE"!==e?(object.quaternion.copy(this._quaternionStart),object.quaternion.multiply(c.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),object.quaternion.copy(c.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),object.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(m),this.dispatchEvent(v)}}pointerUp(t){0===t.button&&(this.dragging&&null!==this.axis&&(_.mode=this.mode,this.dispatchEvent(_)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(t){t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}))}attach(object){return this.object=object,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(m),this.dispatchEvent(v),this.pointStart.copy(this.pointEnd))}getRaycaster(){return o}getMode(){return this.mode}setMode(t){this.mode=t}setTranslationSnap(t){this.translationSnap=t}setRotationSnap(t){this.rotationSnap=t}setScaleSnap(t){this.scaleSnap=t}setSize(t){this.size=t}setSpace(t){this.space=t}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function x(t){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:t.button};{const rect=this.domElement.getBoundingClientRect();return{x:(t.clientX-rect.left)/rect.width*2-1,y:-(t.clientY-rect.top)/rect.height*2+1,button:t.button}}}function T(t){if(this.enabled)switch(t.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(t))}}function E(t){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(t.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(t)),this.pointerDown(this._getPointer(t)))}function M(t){this.enabled&&this.pointerMove(this._getPointer(t))}function w(t){this.enabled&&(this.domElement.releasePointerCapture(t.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(t)))}function S(object,t,e){const r=t.intersectObject(object,!0);for(let i=0;i<r.length;i++)if(r[i].object.visible||e)return r[i];return!1}y.prototype.isTransformControls=!0;const A=new n.Euler,R=new n.Vector3(0,1,0),O=new n.Vector3(0,0,0),C=new n.Matrix4,P=new n.Quaternion,L=new n.Quaternion,I=new n.Vector3,D=new n.Matrix4,U=new n.Vector3(1,0,0),F=new n.Vector3(0,1,0),B=new n.Vector3(0,0,1),N=new n.Vector3,k=new n.Vector3,z=new n.Vector3;class H extends n.Object3D{constructor(){super(),this.type="TransformControlsGizmo";const t=new n.MeshBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=new n.LineBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),r=t.clone();r.opacity=.15;const o=e.clone();o.opacity=.5;const l=t.clone();l.color.setHex(16711680);const h=t.clone();h.color.setHex(65280);const c=t.clone();c.color.setHex(255);const d=t.clone();d.color.setHex(16711680),d.opacity=.5;const m=t.clone();m.color.setHex(65280),m.opacity=.5;const f=t.clone();f.color.setHex(255),f.opacity=.5;const _=t.clone();_.opacity=.25;const v=t.clone();v.color.setHex(16776960),v.opacity=.25;t.clone().color.setHex(16776960);const y=t.clone();y.color.setHex(7895160);const x=new n.CylinderGeometry(0,.04,.1,12);x.translate(0,.05,0);const T=new n.BoxGeometry(.08,.08,.08);T.translate(0,.04,0);const E=new n.BufferGeometry;E.setAttribute("position",new n.Float32BufferAttribute([0,0,0,1,0,0],3));const M=new n.CylinderGeometry(.0075,.0075,.5,3);function w(t,e){const r=new n.TorusGeometry(t,.0075,3,64,e*Math.PI*2);return r.rotateY(Math.PI/2),r.rotateX(Math.PI/2),r}M.translate(0,.25,0);const S={X:[[new n.Mesh(x,l),[.5,0,0],[0,0,-Math.PI/2]],[new n.Mesh(x,l),[-.5,0,0],[0,0,Math.PI/2]],[new n.Mesh(M,l),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new n.Mesh(x,h),[0,.5,0]],[new n.Mesh(x,h),[0,-.5,0],[Math.PI,0,0]],[new n.Mesh(M,h)]],Z:[[new n.Mesh(x,c),[0,0,.5],[Math.PI/2,0,0]],[new n.Mesh(x,c),[0,0,-.5],[-Math.PI/2,0,0]],[new n.Mesh(M,c),null,[Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.OctahedronGeometry(.1,0),_.clone()),[0,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),f.clone()),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),d.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),m.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},A={X:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[.3,0,0],[0,0,-Math.PI/2]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,.3,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,-.3,0],[0,0,Math.PI]]],Z:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,.3],[Math.PI/2,0,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.OctahedronGeometry(.2,0),r)]],XY:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,0,.15],[-Math.PI/2,0,0]]]},R={START:[[new n.Mesh(new n.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],END:[[new n.Mesh(new n.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],DELTA:[[new n.Line(function(){const t=new n.BufferGeometry;return t.setAttribute("position",new n.Float32BufferAttribute([0,0,0,1,1,1],3)),t}(),o),null,null,null,"helper"]],X:[[new n.Line(E,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new n.Line(E,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new n.Line(E,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},O={XYZE:[[new n.Mesh(w(.5,1),y),null,[0,Math.PI/2,0]]],X:[[new n.Mesh(w(.5,.5),l)]],Y:[[new n.Mesh(w(.5,.5),h),null,[0,0,-Math.PI/2]]],Z:[[new n.Mesh(w(.5,.5),c),null,[0,Math.PI/2,0]]],E:[[new n.Mesh(w(.75,1),v),null,[0,Math.PI/2,0]]]},C={AXIS:[[new n.Line(E,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},P={XYZE:[[new n.Mesh(new n.SphereGeometry(.25,10,8),r)]],X:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[Math.PI/2,0,0]]],Z:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[0,0,-Math.PI/2]]],E:[[new n.Mesh(new n.TorusGeometry(.75,.1,2,24),r)]]},L={X:[[new n.Mesh(T,l),[.5,0,0],[0,0,-Math.PI/2]],[new n.Mesh(M,l),[0,0,0],[0,0,-Math.PI/2]],[new n.Mesh(T,l),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(T,h),[0,.5,0]],[new n.Mesh(M,h)],[new n.Mesh(T,h),[0,-.5,0],[0,0,Math.PI]]],Z:[[new n.Mesh(T,c),[0,0,.5],[Math.PI/2,0,0]],[new n.Mesh(M,c),[0,0,0],[Math.PI/2,0,0]],[new n.Mesh(T,c),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),f),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),d),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),m),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.BoxGeometry(.1,.1,.1),_.clone())]]},I={X:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[.3,0,0],[0,0,-Math.PI/2]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,.3,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,-.3,0],[0,0,Math.PI]]],Z:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,.3],[Math.PI/2,0,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.2),r),[0,0,0]]]},D={X:[[new n.Line(E,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new n.Line(E,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new n.Line(E,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function U(t){const e=new n.Object3D;for(const r in t)for(let i=t[r].length;i--;){const object=t[r][i][0].clone(),n=t[r][i][1],o=t[r][i][2],l=t[r][i][3],h=t[r][i][4];object.name=r,object.tag=h,n&&object.position.set(n[0],n[1],n[2]),o&&object.rotation.set(o[0],o[1],o[2]),l&&object.scale.set(l[0],l[1],l[2]),object.updateMatrix();const c=object.geometry.clone();c.applyMatrix4(object.matrix),object.geometry=c,object.renderOrder=1/0,object.position.set(0,0,0),object.rotation.set(0,0,0),object.scale.set(1,1,1),e.add(object)}return e}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=U(S)),this.add(this.gizmo.rotate=U(O)),this.add(this.gizmo.scale=U(L)),this.add(this.picker.translate=U(A)),this.add(this.picker.rotate=U(P)),this.add(this.picker.scale=U(I)),this.add(this.helper.translate=U(R)),this.add(this.helper.rotate=U(C)),this.add(this.helper.scale=U(D)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(t){const e="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:L;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let r=[];r=r.concat(this.picker[this.mode].children),r=r.concat(this.gizmo[this.mode].children),r=r.concat(this.helper[this.mode].children);for(let i=0;i<r.length;i++){const t=r[i];let n;if(t.visible=!0,t.rotation.set(0,0,0),t.position.copy(this.worldPosition),n=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),t.scale.set(1,1,1).multiplyScalar(n*this.size/4),"helper"!==t.tag){if(t.quaternion.copy(e),"translate"===this.mode||"scale"===this.mode){const r=.99,n=.2;"X"===t.name&&Math.abs(R.copy(U).applyQuaternion(e).dot(this.eye))>r&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"Y"===t.name&&Math.abs(R.copy(F).applyQuaternion(e).dot(this.eye))>r&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"Z"===t.name&&Math.abs(R.copy(B).applyQuaternion(e).dot(this.eye))>r&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"XY"===t.name&&Math.abs(R.copy(B).applyQuaternion(e).dot(this.eye))<n&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"YZ"===t.name&&Math.abs(R.copy(U).applyQuaternion(e).dot(this.eye))<n&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1),"XZ"===t.name&&Math.abs(R.copy(F).applyQuaternion(e).dot(this.eye))<n&&(t.scale.set(1e-10,1e-10,1e-10),t.visible=!1)}else"rotate"===this.mode&&(P.copy(e),R.copy(this.eye).applyQuaternion(c.copy(e).invert()),-1!==t.name.search("E")&&t.quaternion.setFromRotationMatrix(C.lookAt(this.eye,O,F)),"X"===t.name&&(c.setFromAxisAngle(U,Math.atan2(-R.y,R.z)),c.multiplyQuaternions(P,c),t.quaternion.copy(c)),"Y"===t.name&&(c.setFromAxisAngle(F,Math.atan2(R.x,R.z)),c.multiplyQuaternions(P,c),t.quaternion.copy(c)),"Z"===t.name&&(c.setFromAxisAngle(B,Math.atan2(R.y,R.x)),c.multiplyQuaternions(P,c),t.quaternion.copy(c)));t.visible=t.visible&&(-1===t.name.indexOf("X")||this.showX),t.visible=t.visible&&(-1===t.name.indexOf("Y")||this.showY),t.visible=t.visible&&(-1===t.name.indexOf("Z")||this.showZ),t.visible=t.visible&&(-1===t.name.indexOf("E")||this.showX&&this.showY&&this.showZ),t.material._color=t.material._color||t.material.color.clone(),t.material._opacity=t.material._opacity||t.material.opacity,t.material.color.copy(t.material._color),t.material.opacity=t.material._opacity,this.enabled&&this.axis&&(t.name===this.axis||this.axis.split("").some((function(a){return t.name===a})))&&(t.material.color.setHex(16776960),t.material.opacity=1)}else t.visible=!1,"AXIS"===t.name?(t.position.copy(this.worldPositionStart),t.visible=!!this.axis,"X"===this.axis&&(c.setFromEuler(A.set(0,0,0)),t.quaternion.copy(e).multiply(c),Math.abs(R.copy(U).applyQuaternion(e).dot(this.eye))>.9&&(t.visible=!1)),"Y"===this.axis&&(c.setFromEuler(A.set(0,0,Math.PI/2)),t.quaternion.copy(e).multiply(c),Math.abs(R.copy(F).applyQuaternion(e).dot(this.eye))>.9&&(t.visible=!1)),"Z"===this.axis&&(c.setFromEuler(A.set(0,Math.PI/2,0)),t.quaternion.copy(e).multiply(c),Math.abs(R.copy(B).applyQuaternion(e).dot(this.eye))>.9&&(t.visible=!1)),"XYZE"===this.axis&&(c.setFromEuler(A.set(0,Math.PI/2,0)),R.copy(this.rotationAxis),t.quaternion.setFromRotationMatrix(C.lookAt(O,R,F)),t.quaternion.multiply(c),t.visible=this.dragging),"E"===this.axis&&(t.visible=!1)):"START"===t.name?(t.position.copy(this.worldPositionStart),t.visible=this.dragging):"END"===t.name?(t.position.copy(this.worldPosition),t.visible=this.dragging):"DELTA"===t.name?(t.position.copy(this.worldPositionStart),t.quaternion.copy(this.worldQuaternionStart),l.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),l.applyQuaternion(this.worldQuaternionStart.clone().invert()),t.scale.copy(l),t.visible=this.dragging):(t.quaternion.copy(e),this.dragging?t.position.copy(this.worldPositionStart):t.position.copy(this.worldPosition),this.axis&&(t.visible=-1!==this.axis.search(t.name)))}super.updateMatrixWorld(t)}}H.prototype.isTransformControlsGizmo=!0;class V extends n.Mesh{constructor(){super(new n.PlaneGeometry(1e5,1e5,2,2),new n.MeshBasicMaterial({visible:!1,wireframe:!0,side:n.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(t){let e=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(e="local"),N.copy(U).applyQuaternion("local"===e?this.worldQuaternion:L),k.copy(F).applyQuaternion("local"===e?this.worldQuaternion:L),z.copy(B).applyQuaternion("local"===e?this.worldQuaternion:L),R.copy(k),this.mode){case"translate":case"scale":switch(this.axis){case"X":R.copy(this.eye).cross(N),I.copy(N).cross(R);break;case"Y":R.copy(this.eye).cross(k),I.copy(k).cross(R);break;case"Z":R.copy(this.eye).cross(z),I.copy(z).cross(R);break;case"XY":I.copy(z);break;case"YZ":I.copy(N);break;case"XZ":R.copy(z),I.copy(k);break;case"XYZ":case"E":I.set(0,0,0)}break;default:I.set(0,0,0)}0===I.length()?this.quaternion.copy(this.cameraQuaternion):(D.lookAt(l.set(0,0,0),I,R),this.quaternion.setFromRotationMatrix(D)),super.updateMatrixWorld(t)}}V.prototype.isTransformControlsPlane=!0},660:function(t,e,r){"use strict";var n;function o(t){return t.isPerspectiveCamera}function l(t){return t.isOrthographicCamera}r.d(e,"a",(function(){return W})),function(t){t[t.NONE=0]="NONE",t[t.ROTATE=1]="ROTATE",t[t.TRUCK=2]="TRUCK",t[t.OFFSET=3]="OFFSET",t[t.DOLLY=4]="DOLLY",t[t.ZOOM=5]="ZOOM",t[t.TOUCH_ROTATE=6]="TOUCH_ROTATE",t[t.TOUCH_TRUCK=7]="TOUCH_TRUCK",t[t.TOUCH_OFFSET=8]="TOUCH_OFFSET",t[t.TOUCH_DOLLY=9]="TOUCH_DOLLY",t[t.TOUCH_ZOOM=10]="TOUCH_ZOOM",t[t.TOUCH_DOLLY_TRUCK=11]="TOUCH_DOLLY_TRUCK",t[t.TOUCH_DOLLY_OFFSET=12]="TOUCH_DOLLY_OFFSET",t[t.TOUCH_ZOOM_TRUCK=13]="TOUCH_ZOOM_TRUCK",t[t.TOUCH_ZOOM_OFFSET=14]="TOUCH_ZOOM_OFFSET"}(n||(n={}));const h=2*Math.PI,c=Math.PI/2;function d(t,e=1e-5){return Math.abs(t)<e}function m(a,b,t=1e-5){return d(a-b,t)}function f(t,e){return Math.round(t/e)*e}function _(t){return isFinite(t)?t:t<0?-Number.MAX_VALUE:Number.MAX_VALUE}function v(t){return Math.abs(t)<Number.MAX_VALUE?t:t*(1/0)}function y(t,e){e.set(0,0),t.forEach((t=>{e.x+=t.clientX,e.y+=t.clientY})),e.x/=t.length,e.y/=t.length}function x(t,e){return!!l(t)&&(console.warn(`${e} is not supported in OrthographicCamera`),!0)}function T(t){return t.invert?t.invert():t.inverse(),t}const E="undefined"!=typeof window,M=E&&/Mac/.test(navigator.platform),w=!(E&&"PointerEvent"in window),S=Object.freeze(n),A=1/8;let R,O,C,P,L,I,D,U,F,B,N,k,z,H,V,G,j,Q,X,Y,K,Z;class W extends class{constructor(){this._listeners={}}addEventListener(t,e){const r=this._listeners;void 0===r[t]&&(r[t]=[]),-1===r[t].indexOf(e)&&r[t].push(e)}removeEventListener(t,e){const r=this._listeners[t];if(void 0!==r){const t=r.indexOf(e);-1!==t&&r.splice(t,1)}}removeAllEventListeners(t){t?Array.isArray(this._listeners[t])&&(this._listeners[t].length=0):this._listeners={}}dispatchEvent(t){const e=this._listeners[t.type];if(void 0!==e){t.target=this;const r=e.slice(0);for(let i=0,e=r.length;i<e;i++)r[i].call(this,t)}}}{constructor(t,e){if(super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=0,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.dampingFactor=.05,this.draggingDampingFactor=.25,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=n.NONE,this._viewport=null,this._dollyControlAmount=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._activePointers=[],this._truckInternal=(t,e,r)=>{if(o(this._camera)){const n=I.copy(this._camera.position).sub(this._target),o=this._camera.getEffectiveFOV()*R.MathUtils.DEG2RAD,l=n.length()*Math.tan(.5*o),h=this.truckSpeed*t*l/this._elementRect.height,c=this.truckSpeed*e*l/this._elementRect.height;this.verticalDragToForward?(r?this.setFocalOffset(this._focalOffsetEnd.x+h,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(h,0,!0),this.forward(-c,!0)):r?this.setFocalOffset(this._focalOffsetEnd.x+h,this._focalOffsetEnd.y+c,this._focalOffsetEnd.z,!0):this.truck(h,c,!0)}else if(l(this._camera)){const n=this._camera,o=t*(n.right-n.left)/n.zoom/this._elementRect.width,l=e*(n.top-n.bottom)/n.zoom/this._elementRect.height;r?this.setFocalOffset(this._focalOffsetEnd.x+o,this._focalOffsetEnd.y+l,this._focalOffsetEnd.z,!0):this.truck(o,l,!0)}},this._rotateInternal=(t,e)=>{const r=h*this.azimuthRotateSpeed*t/this._elementRect.height,n=h*this.polarRotateSpeed*e/this._elementRect.height;this.rotate(r,n,!0)},this._dollyInternal=(t,e,r)=>{const n=Math.pow(.95,-t*this.dollySpeed),o=this._sphericalEnd.radius*n,l=this._sphericalEnd.radius,h=l*(t>=0?-1:1);this.dollyTo(o),this.infinityDolly&&(o<this.minDistance||this.maxDistance===this.minDistance)&&(this._camera.getWorldDirection(I),this._targetEnd.add(I.normalize().multiplyScalar(h)),this._target.add(I.normalize().multiplyScalar(h))),this.dollyToCursor&&(this._dollyControlAmount+=this._sphericalEnd.radius-l,this.infinityDolly&&(o<this.minDistance||this.maxDistance===this.minDistance)&&(this._dollyControlAmount-=h),this._dollyControlCoord.set(e,r))},this._zoomInternal=(t,e,r)=>{const n=Math.pow(.95,t*this.dollySpeed);this.zoomTo(this._zoom*n),this.dollyToCursor&&(this._dollyControlAmount=this._zoomEnd,this._dollyControlCoord.set(e,r))},void 0===R&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=t,this._yAxisUpSpace=(new R.Quaternion).setFromUnitVectors(this._camera.up,C),this._yAxisUpSpaceInverse=T(this._yAxisUpSpace.clone()),this._state=n.NONE,this._domElement=e,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._target=new R.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new R.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=(new R.Spherical).setFromVector3(I.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._nearPlaneCorners=[new R.Vector3,new R.Vector3,new R.Vector3,new R.Vector3],this._updateNearPlaneCorners(),this._boundary=new R.Box3(new R.Vector3(-1/0,-1/0,-1/0),new R.Vector3(1/0,1/0,1/0)),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlAmount=0,this._dollyControlCoord=new R.Vector2,this.mouseButtons={left:n.ROTATE,middle:n.DOLLY,right:n.TRUCK,wheel:o(this._camera)?n.DOLLY:l(this._camera)?n.ZOOM:n.NONE,shiftLeft:n.NONE},this.touches={one:n.TOUCH_ROTATE,two:o(this._camera)?n.TOUCH_DOLLY_TRUCK:l(this._camera)?n.TOUCH_ZOOM_TRUCK:n.NONE,three:n.TOUCH_TRUCK},this._domElement){const t=new R.Vector2,e=new R.Vector2,r=new R.Vector2,o=t=>{if(!this._enabled)return;const e={pointerId:t.pointerId,clientX:t.clientX,clientY:t.clientY};switch(this._activePointers.push(e),t.button){case R.MOUSE.LEFT:this._state=t.shiftKey?this.mouseButtons.shiftLeft:this.mouseButtons.left;break;case R.MOUSE.MIDDLE:this._state=this.mouseButtons.middle;break;case R.MOUSE.RIGHT:this._state=this.mouseButtons.right}if("touch"===t.pointerType)switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),S()},l=t=>{if(!this._enabled)return;const e={pointerId:0,clientX:t.clientX,clientY:t.clientY};switch(this._activePointers.push(e),t.button){case R.MOUSE.LEFT:this._state=t.shiftKey?this.mouseButtons.shiftLeft:this.mouseButtons.left;break;case R.MOUSE.MIDDLE:this._state=this.mouseButtons.middle;break;case R.MOUSE.RIGHT:this._state=this.mouseButtons.right}this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",_),this._domElement.ownerDocument.addEventListener("mousemove",d),this._domElement.ownerDocument.addEventListener("mouseup",_),S()},h=t=>{if(this._enabled){switch(t.preventDefault(),Array.prototype.forEach.call(t.changedTouches,(t=>{const e={pointerId:t.identifier,clientX:t.clientX,clientY:t.clientY};this._activePointers.push(e)})),this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("touchend",v),this._domElement.ownerDocument.addEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.addEventListener("touchend",v),S()}},c=t=>{t.cancelable&&t.preventDefault();const e=t.pointerId,r=this._findPointerById(e);r&&(r.clientX=t.clientX,r.clientY=t.clientY,O())},d=t=>{const e=this._findPointerById(0);e&&(e.clientX=t.clientX,e.clientY=t.clientY,O())},m=t=>{t.cancelable&&t.preventDefault(),Array.prototype.forEach.call(t.changedTouches,(t=>{const e=t.identifier,r=this._findPointerById(e);r&&(r.clientX=t.clientX,r.clientY=t.clientY)})),O()},f=t=>{const e=t.pointerId,r=this._findPointerById(e);if(r&&this._activePointers.splice(this._activePointers.indexOf(r),1),"touch"===t.pointerType)switch(this._activePointers.length){case 0:this._state=n.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}else this._state=n.NONE;C()},_=()=>{const t=this._findPointerById(0);t&&this._activePointers.splice(this._activePointers.indexOf(t),1),this._state=n.NONE,C()},v=t=>{switch(Array.prototype.forEach.call(t.changedTouches,(t=>{const e=t.identifier,r=this._findPointerById(e);r&&this._activePointers.splice(this._activePointers.indexOf(r),1)})),this._activePointers.length){case 0:this._state=n.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}C()};let x=-1;const T=t=>{if(!this._enabled||this.mouseButtons.wheel===n.NONE)return;if(t.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===n.ROTATE||this.mouseButtons.wheel===n.TRUCK){const t=performance.now();x-t<1e3&&this._getClientRect(this._elementRect),x=t}const e=M?-1:-3,r=1===t.deltaMode?t.deltaY/e:t.deltaY/(10*e),o=this.dollyToCursor?(t.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,l=this.dollyToCursor?(t.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case n.ROTATE:this._rotateInternal(t.deltaX,t.deltaY);break;case n.TRUCK:this._truckInternal(t.deltaX,t.deltaY,!1);break;case n.OFFSET:this._truckInternal(t.deltaX,t.deltaY,!0);break;case n.DOLLY:this._dollyInternal(-r,o,l);break;case n.ZOOM:this._zoomInternal(-r,o,l)}this.dispatchEvent({type:"control"})},E=t=>{this._enabled&&t.preventDefault()},S=()=>{if(!this._enabled)return;y(this._activePointers,L),this._getClientRect(this._elementRect),t.copy(L),e.copy(L);if(this._activePointers.length>=2){const t=L.x-this._activePointers[1].clientX,n=L.y-this._activePointers[1].clientY,o=Math.sqrt(t*t+n*n);r.set(0,o);const l=.5*(this._activePointers[0].clientX+this._activePointers[1].clientX),h=.5*(this._activePointers[0].clientY+this._activePointers[1].clientY);e.set(l,h)}this.dispatchEvent({type:"controlstart"})},O=()=>{if(!this._enabled)return;y(this._activePointers,L);const o=e.x-L.x,l=e.y-L.y;switch(e.copy(L),this._state){case n.ROTATE:case n.TOUCH_ROTATE:this._rotateInternal(o,l);break;case n.DOLLY:case n.ZOOM:{const e=this.dollyToCursor?(t.x-this._elementRect.x)/this._elementRect.width*2-1:0,r=this.dollyToCursor?(t.y-this._elementRect.y)/this._elementRect.height*-2+1:0;this._state===n.DOLLY?this._dollyInternal(l*A,e,r):this._zoomInternal(l*A,e,r);break}case n.TOUCH_DOLLY:case n.TOUCH_ZOOM:case n.TOUCH_DOLLY_TRUCK:case n.TOUCH_ZOOM_TRUCK:case n.TOUCH_DOLLY_OFFSET:case n.TOUCH_ZOOM_OFFSET:{const t=L.x-this._activePointers[1].clientX,h=L.y-this._activePointers[1].clientY,c=Math.sqrt(t*t+h*h),d=r.y-c;r.set(0,c);const m=this.dollyToCursor?(e.x-this._elementRect.x)/this._elementRect.width*2-1:0,f=this.dollyToCursor?(e.y-this._elementRect.y)/this._elementRect.height*-2+1:0;this._state===n.TOUCH_DOLLY||this._state===n.TOUCH_DOLLY_TRUCK||this._state===n.TOUCH_DOLLY_OFFSET?this._dollyInternal(d*A,m,f):this._zoomInternal(d*A,m,f),this._state===n.TOUCH_DOLLY_TRUCK||this._state===n.TOUCH_ZOOM_TRUCK?this._truckInternal(o,l,!1):this._state!==n.TOUCH_DOLLY_OFFSET&&this._state!==n.TOUCH_ZOOM_OFFSET||this._truckInternal(o,l,!0);break}case n.TRUCK:case n.TOUCH_TRUCK:this._truckInternal(o,l,!1);break;case n.OFFSET:case n.TOUCH_OFFSET:this._truckInternal(o,l,!0)}this.dispatchEvent({type:"control"})},C=()=>{y(this._activePointers,L),e.copy(L),0===this._activePointers.length&&(this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("touchend",v),this.dispatchEvent({type:"controlend"}))};this._domElement.addEventListener("pointerdown",o),w&&this._domElement.addEventListener("mousedown",l),w&&this._domElement.addEventListener("touchstart",h),this._domElement.addEventListener("pointercancel",f),this._domElement.addEventListener("wheel",T,{passive:!1}),this._domElement.addEventListener("contextmenu",E),this._removeAllEventListeners=()=>{this._domElement.removeEventListener("pointerdown",o),this._domElement.removeEventListener("mousedown",l),this._domElement.removeEventListener("touchstart",h),this._domElement.removeEventListener("pointercancel",f),this._domElement.removeEventListener("wheel",T,{passive:!1}),this._domElement.removeEventListener("contextmenu",E),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",_),this._domElement.ownerDocument.removeEventListener("touchend",v)},this.cancel=()=>{this._state!==n.NONE&&(this._state=n.NONE,this._activePointers.length=0,C())}}this.update(0)}static install(t){R=t.THREE,O=Object.freeze(new R.Vector3(0,0,0)),C=Object.freeze(new R.Vector3(0,1,0)),P=Object.freeze(new R.Vector3(0,0,1)),L=new R.Vector2,I=new R.Vector3,D=new R.Vector3,U=new R.Vector3,F=new R.Vector3,B=new R.Vector3,N=new R.Vector3,k=new R.Vector3,z=new R.Vector3,H=new R.Spherical,V=new R.Spherical,G=new R.Box3,j=new R.Box3,Q=new R.Sphere,X=new R.Quaternion,Y=new R.Quaternion,K=new R.Matrix4,Z=new R.Raycaster}static get ACTION(){return S}get camera(){return this._camera}set camera(t){this._camera=t,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(t){this._enabled=t,t?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="")}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(t){this._spherical.radius===t&&this._sphericalEnd.radius===t||(this._spherical.radius=t,this._sphericalEnd.radius=t,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(t){this._spherical.theta===t&&this._sphericalEnd.theta===t||(this._spherical.theta=t,this._sphericalEnd.theta=t,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(t){this._spherical.phi===t&&this._sphericalEnd.phi===t||(this._spherical.phi=t,this._sphericalEnd.phi=t,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(t){this._boundaryEnclosesCamera=t,this._needsUpdate=!0}addEventListener(t,e){super.addEventListener(t,e)}removeEventListener(t,e){super.removeEventListener(t,e)}rotate(t,e,r=!1){return this.rotateTo(this._sphericalEnd.theta+t,this._sphericalEnd.phi+e,r)}rotateAzimuthTo(t,e=!1){return this.rotateTo(t,this._sphericalEnd.phi,e)}rotatePolarTo(t,e=!1){return this.rotateTo(this._sphericalEnd.theta,t,e)}rotateTo(t,e,r=!1){const n=R.MathUtils.clamp(t,this.minAzimuthAngle,this.maxAzimuthAngle),o=R.MathUtils.clamp(e,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=n,this._sphericalEnd.phi=o,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,r||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const l=!r||m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(l)}dolly(t,e=!1){return this.dollyTo(this._sphericalEnd.radius-t,e)}dollyTo(t,e=!1){const r=this._sphericalEnd.radius,n=R.MathUtils.clamp(t,this.minDistance,this.maxDistance);if(this.colliderMeshes.length>=1){const t=this._collisionTest(),e=m(t,this._spherical.radius);if(!(r>n)&&e)return Promise.resolve();this._sphericalEnd.radius=Math.min(n,t)}else this._sphericalEnd.radius=n;this._needsUpdate=!0,e||(this._spherical.radius=this._sphericalEnd.radius);const o=!e||m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(o)}zoom(t,e=!1){return this.zoomTo(this._zoomEnd+t,e)}zoomTo(t,e=!1){this._zoomEnd=R.MathUtils.clamp(t,this.minZoom,this.maxZoom),this._needsUpdate=!0,e||(this._zoom=this._zoomEnd);const r=!e||m(this._zoom,this._zoomEnd,this.restThreshold);return this._createOnRestPromise(r)}pan(t,e,r=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(t,e,r)}truck(t,e,r=!1){this._camera.updateMatrix(),F.setFromMatrixColumn(this._camera.matrix,0),B.setFromMatrixColumn(this._camera.matrix,1),F.multiplyScalar(t),B.multiplyScalar(-e);const n=I.copy(F).add(B),o=D.copy(this._targetEnd).add(n);return this.moveTo(o.x,o.y,o.z,r)}forward(t,e=!1){I.setFromMatrixColumn(this._camera.matrix,0),I.crossVectors(this._camera.up,I),I.multiplyScalar(t);const r=D.copy(this._targetEnd).add(I);return this.moveTo(r.x,r.y,r.z,e)}moveTo(t,e,r,n=!1){const o=I.set(t,e,r).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,o,this.boundaryFriction),this._needsUpdate=!0,n||this._target.copy(this._targetEnd);const l=!n||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(l)}fitToBox(t,e,{paddingLeft:r=0,paddingRight:n=0,paddingBottom:h=0,paddingTop:d=0}={}){const _=[],v=t.isBox3?G.copy(t):G.setFromObject(t);v.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const y=f(this._sphericalEnd.theta,c),x=f(this._sphericalEnd.phi,c);_.push(this.rotateTo(y,x,e));const T=I.setFromSpherical(this._sphericalEnd).normalize(),E=X.setFromUnitVectors(T,P);m(Math.abs(T.y),1)&&E.multiply(Y.setFromAxisAngle(C,y));const M=j.makeEmpty();D.copy(v.min).applyQuaternion(E),M.expandByPoint(D),D.copy(v.min).setX(v.max.x).applyQuaternion(E),M.expandByPoint(D),D.copy(v.min).setY(v.max.y).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).setZ(v.min.z).applyQuaternion(E),M.expandByPoint(D),D.copy(v.min).setZ(v.max.z).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).setY(v.min.y).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).setX(v.min.x).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).applyQuaternion(E),M.expandByPoint(D),E.setFromUnitVectors(P,T),M.min.x-=r,M.min.y-=h,M.max.x+=n,M.max.y+=d;const w=M.getSize(I),S=M.getCenter(D).applyQuaternion(E);if(o(this._camera)){const t=this.getDistanceToFitBox(w.x,w.y,w.z);_.push(this.moveTo(S.x,S.y,S.z,e)),_.push(this.dollyTo(t,e)),_.push(this.setFocalOffset(0,0,0,e))}else if(l(this._camera)){const t=this._camera,r=t.right-t.left,n=t.top-t.bottom,o=Math.min(r/w.x,n/w.y);_.push(this.moveTo(S.x,S.y,S.z,e)),_.push(this.zoomTo(o,e)),_.push(this.setFocalOffset(0,0,0,e))}return Promise.all(_)}fitToSphere(t,e){const r=[],n=t instanceof R.Sphere?Q.copy(t):function(t,e){const r=e,n=r.center;G.makeEmpty(),t.traverseVisible((object=>{object.isMesh&&G.expandByObject(object)})),G.getCenter(n);let o=0;return t.traverseVisible((object=>{if(!object.isMesh)return;const t=object,e=t.geometry.clone();if(e.applyMatrix4(t.matrixWorld),e.isBufferGeometry){const t=e.attributes.position;for(let i=0,e=t.count;i<e;i++)I.fromBufferAttribute(t,i),o=Math.max(o,n.distanceToSquared(I))}else{const t=e.attributes.position,r=new R.Vector3;for(let i=0,e=t.count;i<e;i++)r.fromBufferAttribute(t,i),o=Math.max(o,n.distanceToSquared(r))}})),r.radius=Math.sqrt(o),r}(t,Q);if(r.push(this.moveTo(n.center.x,n.center.y,n.center.z,e)),o(this._camera)){const t=this.getDistanceToFitSphere(n.radius);r.push(this.dollyTo(t,e))}else if(l(this._camera)){const t=this._camera.right-this._camera.left,o=this._camera.top-this._camera.bottom,l=2*n.radius,h=Math.min(t/l,o/l);r.push(this.zoomTo(h,e))}return r.push(this.setFocalOffset(0,0,0,e)),Promise.all(r)}setLookAt(t,e,r,n,o,l,h=!1){const c=D.set(n,o,l),d=I.set(t,e,r);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(d.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,h||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const f=!h||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold)&&m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(f)}lerpLookAt(t,e,r,n,o,l,h,c,d,f,_,v,y,x=!1){const T=I.set(n,o,l),E=D.set(t,e,r);H.setFromVector3(E.sub(T).applyQuaternion(this._yAxisUpSpace));const M=U.set(f,_,v),w=D.set(h,c,d);V.setFromVector3(w.sub(M).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(T.lerp(M,y));const S=V.theta-H.theta,A=V.phi-H.phi,R=V.radius-H.radius;this._sphericalEnd.set(H.radius+R*y,H.phi+A*y,H.theta+S*y),this.normalizeRotations(),this._needsUpdate=!0,x||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const O=!x||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold)&&m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(O)}setPosition(t,e,r,n=!1){return this.setLookAt(t,e,r,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,n)}setTarget(t,e,r,n=!1){const o=this.getPosition(I);return this.setLookAt(o.x,o.y,o.z,t,e,r,n)}setFocalOffset(t,e,r,n=!1){this._focalOffsetEnd.set(t,e,r),this._needsUpdate=!0,n||this._focalOffset.copy(this._focalOffsetEnd);const o=!n||m(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&m(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&m(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}setOrbitPoint(t,e,r){F.setFromMatrixColumn(this._camera.matrixWorldInverse,0),B.setFromMatrixColumn(this._camera.matrixWorldInverse,1),N.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const n=I.set(t,e,r),o=n.distanceTo(this._camera.position),l=n.sub(this._camera.position);F.multiplyScalar(l.x),B.multiplyScalar(l.y),N.multiplyScalar(l.z),I.copy(F).add(B).add(N),I.z=I.z+o,this.dollyTo(o,!1),this.setFocalOffset(-I.x,I.y,-I.z,!1),this.moveTo(t,e,r,!1)}setBoundary(t){if(!t)return this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),void(this._needsUpdate=!0);this._boundary.copy(t),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(t,e,r,n){null!==t?(this._viewport=this._viewport||new R.Vector4,"number"==typeof t?this._viewport.set(t,e,r,n):this._viewport.copy(t)):this._viewport=null}getDistanceToFitBox(t,e,r){if(x(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const n=t/e,o=this._camera.getEffectiveFOV()*R.MathUtils.DEG2RAD,l=this._camera.aspect;return.5*(n<l?e:t/l)/Math.tan(.5*o)+.5*r}getDistanceToFitSphere(t){if(x(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const e=this._camera.getEffectiveFOV()*R.MathUtils.DEG2RAD,r=2*Math.atan(Math.tan(.5*e)*this._camera.aspect),n=1<this._camera.aspect?e:r;return t/Math.sin(.5*n)}getTarget(t){return(t&&t.isVector3?t:new R.Vector3).copy(this._targetEnd)}getPosition(t){return(t&&t.isVector3?t:new R.Vector3).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd)}getFocalOffset(t){return(t&&t.isVector3?t:new R.Vector3).copy(this._focalOffsetEnd)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%h,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=h),this._spherical.theta+=h*Math.round((this._sphericalEnd.theta-this._spherical.theta)/h)}reset(t=!1){const e=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,t),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,t),this.zoomTo(this._zoom0,t)];return Promise.all(e)}saveState(){this._target0.copy(this._target),this._position0.copy(this._camera.position),this._zoom0=this._zoom}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,C),T(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace))}update(t){const e=this._state===n.NONE?this.dampingFactor:this.draggingDampingFactor,r=Math.min(e*t*60,1),h=this._sphericalEnd.theta-this._spherical.theta,c=this._sphericalEnd.phi-this._spherical.phi,m=this._sphericalEnd.radius-this._spherical.radius,f=k.subVectors(this._targetEnd,this._target),_=z.subVectors(this._focalOffsetEnd,this._focalOffset);if(d(h)&&d(c)&&d(m)&&d(f.x)&&d(f.y)&&d(f.z)&&d(_.x)&&d(_.y)&&d(_.z)?(this._spherical.copy(this._sphericalEnd),this._target.copy(this._targetEnd),this._focalOffset.copy(this._focalOffsetEnd)):(this._spherical.set(this._spherical.radius+m*r,this._spherical.phi+c*r,this._spherical.theta+h*r),this._target.add(f.multiplyScalar(r)),this._focalOffset.add(_.multiplyScalar(r)),this._needsUpdate=!0),0!==this._dollyControlAmount){if(o(this._camera)){const t=this._camera,e=I.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(),r=D.copy(e).cross(t.up).normalize();0===r.lengthSq()&&(r.x=1);const n=U.crossVectors(r,e),o=this._sphericalEnd.radius*Math.tan(t.getEffectiveFOV()*R.MathUtils.DEG2RAD*.5),l=(this._sphericalEnd.radius-this._dollyControlAmount-this._sphericalEnd.radius)/this._sphericalEnd.radius,cursor=I.copy(this._targetEnd).add(r.multiplyScalar(this._dollyControlCoord.x*o*t.aspect)).add(n.multiplyScalar(this._dollyControlCoord.y*o));this._targetEnd.lerp(cursor,l),this._target.copy(this._targetEnd)}else if(l(this._camera)){const t=this._camera,e=I.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(t.near+t.far)/(t.near-t.far)).unproject(t),r=D.set(0,0,-1).applyQuaternion(t.quaternion),n=r.dot(t.up),o=d(n)?-e.dot(t.up):-e.dot(t.up)/n,cursor=U.copy(e).add(r.multiplyScalar(o));this._targetEnd.lerp(cursor,1-t.zoom/this._dollyControlAmount),this._target.copy(this._targetEnd)}this._dollyControlAmount=0}const v=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,v),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target);(!d(this._focalOffset.x)||!d(this._focalOffset.y)||!d(this._focalOffset.z))&&(this._camera.updateMatrix(),F.setFromMatrixColumn(this._camera.matrix,0),B.setFromMatrixColumn(this._camera.matrix,1),N.setFromMatrixColumn(this._camera.matrix,2),F.multiplyScalar(this._focalOffset.x),B.multiplyScalar(-this._focalOffset.y),N.multiplyScalar(this._focalOffset.z),I.copy(F).add(B).add(N),this._camera.position.add(I)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),I.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const y=this._zoomEnd-this._zoom;this._zoom+=y*r,this._camera.zoom!==this._zoom&&(d(y)&&(this._zoom=this._zoomEnd),this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0);const x=this._needsUpdate;return x&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):x?(this.dispatchEvent({type:"update"}),d(h,this.restThreshold)&&d(c,this.restThreshold)&&d(m,this.restThreshold)&&d(f.x,this.restThreshold)&&d(f.y,this.restThreshold)&&d(f.z,this.restThreshold)&&d(_.x,this.restThreshold)&&d(_.y,this.restThreshold)&&d(_.z,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!x&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._updatedLastTime=x,this._needsUpdate=!1,x}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:_(this.maxDistance),minZoom:this.minZoom,maxZoom:_(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:_(this.maxPolarAngle),minAzimuthAngle:_(this.minAzimuthAngle),maxAzimuthAngle:_(this.maxAzimuthAngle),dampingFactor:this.dampingFactor,draggingDampingFactor:this.draggingDampingFactor,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:I.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(t,e=!1){const r=JSON.parse(t),n=I.fromArray(r.position);this.enabled=r.enabled,this.minDistance=r.minDistance,this.maxDistance=v(r.maxDistance),this.minZoom=r.minZoom,this.maxZoom=v(r.maxZoom),this.minPolarAngle=r.minPolarAngle,this.maxPolarAngle=v(r.maxPolarAngle),this.minAzimuthAngle=v(r.minAzimuthAngle),this.maxAzimuthAngle=v(r.maxAzimuthAngle),this.dampingFactor=r.dampingFactor,this.draggingDampingFactor=r.draggingDampingFactor,this.dollySpeed=r.dollySpeed,this.truckSpeed=r.truckSpeed,this.dollyToCursor=r.dollyToCursor,this.verticalDragToForward=r.verticalDragToForward,this._target0.fromArray(r.target0),this._position0.fromArray(r.position0),this._zoom0=r.zoom0,this._focalOffset0.fromArray(r.focalOffset0),this.moveTo(r.target[0],r.target[1],r.target[2],e),H.setFromVector3(n.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(H.theta,H.phi,e),this.zoomTo(r.zoom,e),this.setFocalOffset(r.focalOffset[0],r.focalOffset[1],r.focalOffset[2],e),this._needsUpdate=!0}dispose(){this._removeAllEventListeners()}_findPointerById(t){let e=null;return this._activePointers.some((r=>r.pointerId===t&&(e=r,!0))),e}_encloseToBoundary(t,e,r){const n=e.lengthSq();if(0===n)return t;const o=D.copy(e).add(t),l=this._boundary.clampPoint(o,U).sub(o),h=l.lengthSq();if(0===h)return t.add(e);if(h===n)return t;if(0===r)return t.add(e).add(l);{const n=1+r*h/e.dot(l);return t.add(D.copy(e).multiplyScalar(n)).add(l.multiplyScalar(1-r))}}_updateNearPlaneCorners(){if(o(this._camera)){const t=this._camera,e=t.near,r=t.getEffectiveFOV()*R.MathUtils.DEG2RAD,n=Math.tan(.5*r)*e,o=n*t.aspect;this._nearPlaneCorners[0].set(-o,-n,0),this._nearPlaneCorners[1].set(o,-n,0),this._nearPlaneCorners[2].set(o,n,0),this._nearPlaneCorners[3].set(-o,n,0)}else if(l(this._camera)){const t=this._camera,e=1/t.zoom,r=t.left*e,n=t.right*e,o=t.top*e,l=t.bottom*e;this._nearPlaneCorners[0].set(r,o,0),this._nearPlaneCorners[1].set(n,o,0),this._nearPlaneCorners[2].set(n,l,0),this._nearPlaneCorners[3].set(r,l,0)}}_collisionTest(){let t=1/0;if(!(this.colliderMeshes.length>=1))return t;if(x(this._camera,"_collisionTest"))return t;const e=I.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);K.lookAt(O,e,this._camera.up);for(let i=0;i<4;i++){const r=D.copy(this._nearPlaneCorners[i]);r.applyMatrix4(K);const n=U.addVectors(this._target,r);Z.set(n,e),Z.far=this._spherical.radius+1;const o=Z.intersectObjects(this.colliderMeshes);0!==o.length&&o[0].distance<t&&(t=o[0].distance)}return t}_getClientRect(t){const rect=this._domElement.getBoundingClientRect();return t.x=rect.left,t.y=rect.top,this._viewport?(t.x+=this._viewport.x,t.y+=rect.height-this._viewport.w-this._viewport.y,t.width=this._viewport.z,t.height=this._viewport.w):(t.width=rect.width,t.height=rect.height),t}_createOnRestPromise(t){return t?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise((t=>{const e=()=>{this.removeEventListener("rest",e),t()};this.addEventListener("rest",e)})))}_removeAllEventListeners(){}}},663:function(t,e,r){"use strict";r.d(e,"a",(function(){return m}));var n=r(27),o=r(655),l=r(652),h=r(651);class c extends h.b{constructor(t,e){super(),this.scene=t,this.camera=e,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(t,e,r){const n=t.getContext(),o=t.state;let l,h;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(l=0,h=1):(l=1,h=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),o.buffers.stencil.setFunc(n.ALWAYS,l,4294967295),o.buffers.stencil.setClear(h),o.buffers.stencil.setLocked(!0),t.setRenderTarget(r),this.clear&&t.clear(),t.render(this.scene,this.camera),t.setRenderTarget(e),this.clear&&t.clear(),t.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(n.EQUAL,1,4294967295),o.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),o.buffers.stencil.setLocked(!0)}}class d extends h.b{constructor(){super(),this.needsSwap=!1}render(t){t.state.buffers.stencil.setLocked(!1),t.state.buffers.stencil.setTest(!1)}}class m{constructor(t,e){if(this.renderer=t,void 0===e){const r=t.getSize(new n.Vector2);this._pixelRatio=t.getPixelRatio(),this._width=r.width,this._height=r.height,(e=new n.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=e.width,this._height=e.height;this.renderTarget1=e,this.renderTarget2=e.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===o.a&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===l.a&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new l.a(o.a),this.clock=new n.Clock}swapBuffers(){const t=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=t}addPass(t){this.passes.push(t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(t,e){this.passes.splice(e,0,t),t.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(t){const e=this.passes.indexOf(t);-1!==e&&this.passes.splice(e,1)}isLastEnabledPass(t){for(let i=t+1;i<this.passes.length;i++)if(this.passes[i].enabled)return!1;return!0}render(t){void 0===t&&(t=this.clock.getDelta());const e=this.renderer.getRenderTarget();let r=!1;for(let i=0,e=this.passes.length;i<e;i++){const e=this.passes[i];if(!1!==e.enabled){if(e.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(i),e.render(this.renderer,this.writeBuffer,this.readBuffer,t,r),e.needsSwap){if(r){const e=this.renderer.getContext(),r=this.renderer.state.buffers.stencil;r.setFunc(e.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,t),r.setFunc(e.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==c&&(e instanceof c?r=!0:e instanceof d&&(r=!1))}}this.renderer.setRenderTarget(e)}reset(t){if(void 0===t){const e=this.renderer.getSize(new n.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=e.width,this._height=e.height,(t=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(t,e){this._width=t,this._height=e;const r=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(r,n),this.renderTarget2.setSize(r,n);for(let i=0;i<this.passes.length;i++)this.passes[i].setSize(r,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}}new n.OrthographicCamera(-1,1,1,-1,0,1);const f=new n.BufferGeometry;f.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),f.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2))},673:function(t,e,r){"use strict";r(7),r(3),r(8),r(105),r(29),r(393),r(289),r(88),r(111);var n=r(2);var o,l=r(43);e.a=(o="container",n.a.extend({name:"v-".concat(o),functional:!0,props:{id:String,tag:{type:String,default:"div"}},render:function(t,e){var r=e.props,data=e.data,n=e.children;data.staticClass="".concat(o," ").concat(data.staticClass||"").trim();var l=data.attrs;if(l){data.attrs={};var h=Object.keys(l).filter((function(t){if("slot"===t)return!1;var e=l[t];return t.startsWith("data-")?(data.attrs[t]=e,!1):e||"string"==typeof e}));h.length&&(data.staticClass+=" ".concat(h.join(" ")))}return r.id&&(data.domProps=data.domProps||{},data.domProps.id=r.id),t(r.tag,data,n)}})).extend({name:"v-container",functional:!0,props:{id:String,tag:{type:String,default:"div"},fluid:{type:Boolean,default:!1}},render:function(t,e){var r,n=e.props,data=e.data,o=e.children,h=data.attrs;return h&&(data.attrs={},r=Object.keys(h).filter((function(t){if("slot"===t)return!1;var e=h[t];return t.startsWith("data-")?(data.attrs[t]=e,!1):e||"string"==typeof e}))),n.id&&(data.domProps=data.domProps||{},data.domProps.id=n.id),t(n.tag,Object(l.a)(data,{staticClass:"container",class:Array({"container--fluid":n.fluid}).concat(r||[])}),o)}})}}]);