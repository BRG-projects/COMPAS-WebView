/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{648:function(e,t,r){"use strict";r.d(t,"b",(function(){return o})),r.d(t,"a",(function(){return c}));var n=r(27);class o{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const l=new n.OrthographicCamera(-1,1,1,-1,0,1),h=new n.BufferGeometry;h.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),h.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2));class c{constructor(e){this._mesh=new n.Mesh(h,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,l)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}},649:function(e,t,r){"use strict";r.d(t,"a",(function(){return l}));var n=r(27),o=r(648);class l extends o.b{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof n.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=n.UniformsUtils.clone(e.uniforms),this.material=new n.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new o.a(this.material)}render(e,t,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}},651:function(e,t,r){"use strict";r.d(t,"a",(function(){return o}));var n=r(27);class o extends n.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new f(e)})),this.register((function(e){return new y(e)})),this.register((function(e){return new M(e)})),this.register((function(e){return new _(e)})),this.register((function(e){return new v(e)})),this.register((function(e){return new T(e)})),this.register((function(e){return new x(e)})),this.register((function(e){return new m(e)})),this.register((function(e){return new E(e)})),this.register((function(e){return new c(e)})),this.register((function(e){return new S(e)}))}load(e,t,r,o){const l=this;let h;h=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:n.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const c=function(t){o?o(t):console.error(t),l.manager.itemError(e),l.manager.itemEnd(e)},d=new n.FileLoader(this.manager);d.setPath(this.path),d.setResponseType("arraybuffer"),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(e,(function(data){try{l.parse(data,h,(function(r){t(r),l.manager.itemEnd(e)}),c)}catch(e){c(e)}}),r,c)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(data,path,e,t){let content;const r={},o={};if("string"==typeof data)content=data;else{if(n.LoaderUtils.decodeText(new Uint8Array(data,0,4))===R){try{r[h.KHR_BINARY_GLTF]=new A(data)}catch(e){return void(t&&t(e))}content=r[h.KHR_BINARY_GLTF].content}else content=n.LoaderUtils.decodeText(new Uint8Array(data))}const l=JSON.parse(content);if(void 0===l.asset||l.asset.version[0]<2)return void(t&&t(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new le(l,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let i=0;i<this.pluginCallbacks.length;i++){const e=this.pluginCallbacks[i](c);o[e.name]=e,r[e.name]=!0}if(l.extensionsUsed)for(let i=0;i<l.extensionsUsed.length;++i){const e=l.extensionsUsed[i],t=l.extensionsRequired||[];switch(e){case h.KHR_MATERIALS_UNLIT:r[e]=new d;break;case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:r[e]=new D;break;case h.KHR_DRACO_MESH_COMPRESSION:r[e]=new C(l,this.dracoLoader);break;case h.KHR_TEXTURE_TRANSFORM:r[e]=new L;break;case h.KHR_MESH_QUANTIZATION:r[e]=new U;break;default:t.indexOf(e)>=0&&void 0===o[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}c.setExtensions(r),c.setPlugins(o),c.parse(e,t)}parseAsync(data,path){const e=this;return new Promise((function(t,r){e.parse(data,path,t,r)}))}}function l(){let e={};return{get:function(t){return e[t]},add:function(t,object){e[t]=object},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const h={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class c{constructor(e){this.parser=e,this.name=h.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let r=0,n=t.length;r<n;r++){const n=t[r];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){const t=this.parser,r="light:"+e;let o=t.cache.get(r);if(o)return o;const l=t.json,h=((l.extensions&&l.extensions[this.name]||{}).lights||[])[e];let c;const d=new n.Color(16777215);void 0!==h.color&&d.fromArray(h.color);const m=void 0!==h.range?h.range:0;switch(h.type){case"directional":c=new n.DirectionalLight(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new n.PointLight(d),c.distance=m;break;case"spot":c=new n.SpotLight(d),c.distance=m,h.spot=h.spot||{},h.spot.innerConeAngle=void 0!==h.spot.innerConeAngle?h.spot.innerConeAngle:0,h.spot.outerConeAngle=void 0!==h.spot.outerConeAngle?h.spot.outerConeAngle:Math.PI/4,c.angle=h.spot.outerConeAngle,c.penumbra=1-h.spot.innerConeAngle/h.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+h.type)}return c.position.set(0,0,0),c.decay=2,void 0!==h.intensity&&(c.intensity=h.intensity),c.name=t.createUniqueName(h.name||"light_"+e),o=Promise.resolve(c),t.cache.add(r,o),o}createNodeAttachment(e){const t=this,r=this.parser,n=r.json.nodes[e],o=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===o?null:this._loadLight(o).then((function(e){return r._getNodeRef(t.cache,o,e)}))}}class d{constructor(){this.name=h.KHR_MATERIALS_UNLIT}getMaterialType(){return n.MeshBasicMaterial}extendParams(e,t,r){const o=[];e.color=new n.Color(1,1,1),e.opacity=1;const l=t.pbrMetallicRoughness;if(l){if(Array.isArray(l.baseColorFactor)){const t=l.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==l.baseColorTexture&&o.push(r.assignTexture(e,"map",l.baseColorTexture,n.sRGBEncoding))}return Promise.all(o)}}class m{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name].emissiveStrength;return void 0!==n&&(t.emissiveIntensity=n),Promise.resolve()}}class f{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],h=o.extensions[this.name];if(void 0!==h.clearcoatFactor&&(t.clearcoat=h.clearcoatFactor),void 0!==h.clearcoatTexture&&l.push(r.assignTexture(t,"clearcoatMap",h.clearcoatTexture)),void 0!==h.clearcoatRoughnessFactor&&(t.clearcoatRoughness=h.clearcoatRoughnessFactor),void 0!==h.clearcoatRoughnessTexture&&l.push(r.assignTexture(t,"clearcoatRoughnessMap",h.clearcoatRoughnessTexture)),void 0!==h.clearcoatNormalTexture&&(l.push(r.assignTexture(t,"clearcoatNormalMap",h.clearcoatNormalTexture)),void 0!==h.clearcoatNormalTexture.scale)){const e=h.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new n.Vector2(e,e)}return Promise.all(l)}}class _{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[];t.sheenColor=new n.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const h=o.extensions[this.name];return void 0!==h.sheenColorFactor&&t.sheenColor.fromArray(h.sheenColorFactor),void 0!==h.sheenRoughnessFactor&&(t.sheenRoughness=h.sheenRoughnessFactor),void 0!==h.sheenColorTexture&&l.push(r.assignTexture(t,"sheenColorMap",h.sheenColorTexture,n.sRGBEncoding)),void 0!==h.sheenRoughnessTexture&&l.push(r.assignTexture(t,"sheenRoughnessMap",h.sheenRoughnessTexture)),Promise.all(l)}}class v{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,n=r.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],l=n.extensions[this.name];return void 0!==l.transmissionFactor&&(t.transmission=l.transmissionFactor),void 0!==l.transmissionTexture&&o.push(r.assignTexture(t,"transmissionMap",l.transmissionTexture)),Promise.all(o)}}class T{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],h=o.extensions[this.name];t.thickness=void 0!==h.thicknessFactor?h.thicknessFactor:0,void 0!==h.thicknessTexture&&l.push(r.assignTexture(t,"thicknessMap",h.thicknessTexture)),t.attenuationDistance=h.attenuationDistance||0;const c=h.attenuationColor||[1,1,1];return t.attenuationColor=new n.Color(c[0],c[1],c[2]),Promise.all(l)}}class x{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name];return t.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class E{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],h=o.extensions[this.name];t.specularIntensity=void 0!==h.specularFactor?h.specularFactor:1,void 0!==h.specularTexture&&l.push(r.assignTexture(t,"specularIntensityMap",h.specularTexture));const c=h.specularColorFactor||[1,1,1];return t.specularColor=new n.Color(c[0],c[1],c[2]),void 0!==h.specularColorTexture&&l.push(r.assignTexture(t,"specularColorMap",h.specularColorTexture,n.sRGBEncoding)),Promise.all(l)}}class y{constructor(e){this.parser=e,this.name=h.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,r=t.json,n=r.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name],l=t.options.ktx2Loader;if(!l){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,o.source,l)}}class M{constructor(e){this.parser=e,this.name=h.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,r=this.parser,n=r.json,o=n.textures[e];if(!o.extensions||!o.extensions[t])return null;const l=o.extensions[t],source=n.images[l.source];let h=r.textureLoader;if(source.uri){const e=r.options.manager.getHandler(source.uri);null!==e&&(h=e)}return this.detectSupport().then((function(o){if(o)return r.loadTextureImage(e,l.source,h);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",image.onload=image.onerror=function(){e(1===image.height)}}))),this.isSupported}}class S{constructor(e){this.name=h.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,r=t.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const e=r.extensions[this.name],n=this.parser.getDependency("buffer",e.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([n,o.ready]).then((function(t){const r=e.byteOffset||0,n=e.byteLength||0,l=e.count,h=e.byteStride,c=new ArrayBuffer(l*h),source=new Uint8Array(t[0],r,n);return o.decodeGltfBuffer(new Uint8Array(c),l,h,source,e.mode,e.filter),c}))}return null}}const R="glTF",w=1313821514,O=5130562;class A{constructor(data){this.name=h.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(data,0,12);if(this.header={magic:n.LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==R)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const t=this.header.length-12,r=new DataView(data,12);let o=0;for(;o<t;){const e=r.getUint32(o,!0);o+=4;const t=r.getUint32(o,!0);if(o+=4,t===w){const t=new Uint8Array(data,12+o,e);this.content=n.LoaderUtils.decodeText(t)}else if(t===O){const t=12+o;this.body=data.slice(t,t+e)}o+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class C{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=h.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const r=this.json,n=this.dracoLoader,o=e.extensions[this.name].bufferView,l=e.extensions[this.name].attributes,h={},c={},d={};for(const e in l){const t=W[e]||e.toLowerCase();h[t]=l[e]}for(const t in e.attributes){const n=W[t]||t.toLowerCase();if(void 0!==l[t]){const o=r.accessors[e.attributes[t]],l=K[o.componentType];d[n]=l,c[n]=!0===o.normalized}}return t.getDependency("bufferView",o).then((function(e){return new Promise((function(t){n.decodeDracoFile(e,(function(e){for(const t in e.attributes){const r=e.attributes[t],n=c[t];void 0!==n&&(r.normalized=n)}t(e)}),h,d)}))}))}}class L{constructor(){this.name=h.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class P extends n.MeshStandardMaterial{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),r=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),o=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),l=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),h=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),c={specular:{value:(new n.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=c,this.onBeforeCompile=function(e){for(const t in c)e.uniforms[t]=c[t];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",r).replace("#include <roughnessmap_fragment>",o).replace("#include <metalnessmap_fragment>",l).replace("#include <lights_physical_fragment>",h)},Object.defineProperties(this,{specular:{get:function(){return c.specular.value},set:function(e){c.specular.value=e}},specularMap:{get:function(){return c.specularMap.value},set:function(e){c.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return c.glossiness.value},set:function(e){c.glossiness.value=e}},glossinessMap:{get:function(){return c.glossinessMap.value},set:function(e){c.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(source){return super.copy(source),this.specularMap=source.specularMap,this.specular.copy(source.specular),this.glossinessMap=source.glossinessMap,this.glossiness=source.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class D{constructor(){this.name=h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return P}extendParams(e,t,r){const o=t.extensions[this.name];e.color=new n.Color(1,1,1),e.opacity=1;const l=[];if(Array.isArray(o.diffuseFactor)){const t=o.diffuseFactor;e.color.fromArray(t),e.opacity=t[3]}if(void 0!==o.diffuseTexture&&l.push(r.assignTexture(e,"map",o.diffuseTexture,n.sRGBEncoding)),e.emissive=new n.Color(0,0,0),e.glossiness=void 0!==o.glossinessFactor?o.glossinessFactor:1,e.specular=new n.Color(1,1,1),Array.isArray(o.specularFactor)&&e.specular.fromArray(o.specularFactor),void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;l.push(r.assignTexture(e,"glossinessMap",t)),l.push(r.assignTexture(e,"specularMap",t,n.sRGBEncoding))}return Promise.all(l)}createMaterial(e){const t=new P(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=void 0===e.emissiveIntensity?1:e.emissiveIntensity,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=n.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t}}class U{constructor(){this.name=h.KHR_MESH_QUANTIZATION}}class F extends n.Interpolant{constructor(e,t,r,n){super(e,t,r,n)}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,n=this.valueSize,o=e*n*3+n;for(let i=0;i!==n;i++)t[i]=r[o+i];return t}}F.prototype.beforeStart_=F.prototype.copySampleValue_,F.prototype.afterEnd_=F.prototype.copySampleValue_,F.prototype.interpolate_=function(e,t,r,n){const o=this.resultBuffer,l=this.sampleValues,h=this.valueSize,c=2*h,d=3*h,td=n-t,p=(r-t)/td,m=p*p,f=m*p,_=e*d,v=_-d,T=-2*f+3*m,x=f-m,E=1-T,y=x-m+p;for(let i=0;i!==h;i++){const e=l[v+i+h],t=l[v+i+c]*td,r=l[_+i+h],n=l[_+i]*td;o[i]=E*e+y*t+T*r+x*n}return o};const I=new n.Quaternion;class N extends F{interpolate_(e,t,r,n){const o=super.interpolate_(e,t,r,n);return I.fromArray(o).normalize().toArray(o),o}}const B=0,k=1,H=2,z=3,V=4,G=5,j=6,K={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Y={9728:n.NearestFilter,9729:n.LinearFilter,9984:n.NearestMipmapNearestFilter,9985:n.LinearMipmapNearestFilter,9986:n.NearestMipmapLinearFilter,9987:n.LinearMipmapLinearFilter},X={33071:n.ClampToEdgeWrapping,33648:n.MirroredRepeatWrapping,10497:n.RepeatWrapping},Q={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},W={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Z={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},J={CUBICSPLINE:void 0,LINEAR:n.InterpolateLinear,STEP:n.InterpolateDiscrete},$="OPAQUE",ee="MASK",te="BLEND";function se(e,object,t){for(const r in t.extensions)void 0===e[r]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[r]=t.extensions[r])}function re(object,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(object.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function ie(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,r=t.weights.length;i<r;i++)e.morphTargetInfluences[i]=t.weights[i];if(t.extras&&Array.isArray(t.extras.targetNames)){const r=t.extras.targetNames;if(e.morphTargetInfluences.length===r.length){e.morphTargetDictionary={};for(let i=0,t=r.length;i<t;i++)e.morphTargetDictionary[r[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ne(e){const t=e.extensions&&e.extensions[h.KHR_DRACO_MESH_COMPRESSION];let r;return r=t?"draco:"+t.bufferView+":"+t.indices+":"+ae(t.attributes):e.indices+":"+ae(e.attributes)+":"+e.mode,r}function ae(e){let t="";const r=Object.keys(e).sort();for(let i=0,n=r.length;i<n;i++)t+=r[i]+":"+e[r[i]]+";";return t}function oe(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class le{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new l,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const r=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),o=navigator.userAgent.indexOf("Firefox")>-1,h=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||r||o&&h<98?this.textureLoader=new n.TextureLoader(this.options.manager):this.textureLoader=new n.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new n.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const r=this,n=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])})).then((function(t){const l={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:r,userData:{}};se(o,l,n),re(l,n),Promise.all(r._invokeAll((function(e){return e.afterRoot&&e.afterRoot(l)}))).then((function(){e(l)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],r=this.json.meshes||[];for(let r=0,n=t.length;r<n;r++){const n=t[r].joints;for(let i=0,t=n.length;i<t;i++)e[n[i]].isBone=!0}for(let t=0,n=e.length;t<n;t++){const n=e[t];void 0!==n.mesh&&(this._addNodeRef(this.meshCache,n.mesh),void 0!==n.skin&&(r[n.mesh].isSkinnedMesh=!0)),void 0!==n.camera&&this._addNodeRef(this.cameraCache,n.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,object){if(e.refs[t]<=1)return object;const r=object.clone(),n=(e,t)=>{const r=this.associations.get(e);null!=r&&this.associations.set(t,r);for(const[i,r]of e.children.entries())n(r,t.children[i])};return n(object,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const r=[];for(let i=0;i<t.length;i++){const n=e(t[i]);n&&r.push(n)}return r}getDependency(e,t){const r=e+":"+t;let n=this.cache.get(r);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this.loadNode(t);break;case"mesh":n=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":n=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":n=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(r,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const r=this,defs=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(defs.map((function(t,n){return r.getDependency(e,n)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],r=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);const o=this.options;return new Promise((function(e,l){r.load(n.LoaderUtils.resolveURL(t.uri,o.path),e,void 0,(function(){l(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const r=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+r)}))}loadAccessor(e){const t=this,r=this.json,o=this.json.accessors[e];if(void 0===o.bufferView&&void 0===o.sparse)return Promise.resolve(null);const l=[];return void 0!==o.bufferView?l.push(this.getDependency("bufferView",o.bufferView)):l.push(null),void 0!==o.sparse&&(l.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),l.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(l).then((function(e){const l=e[0],h=Q[o.type],c=K[o.componentType],d=c.BYTES_PER_ELEMENT,m=d*h,f=o.byteOffset||0,_=void 0!==o.bufferView?r.bufferViews[o.bufferView].byteStride:void 0,v=!0===o.normalized;let T,x;if(_&&_!==m){const e=Math.floor(f/_),r="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+e+":"+o.count;let m=t.cache.get(r);m||(T=new c(l,e*_,o.count*_/d),m=new n.InterleavedBuffer(T,_/d),t.cache.add(r,m)),x=new n.InterleavedBufferAttribute(m,h,f%_/d,v)}else T=null===l?new c(o.count*h):new c(l,f,o.count*h),x=new n.BufferAttribute(T,h,v);if(void 0!==o.sparse){const t=Q.SCALAR,r=K[o.sparse.indices.componentType],d=o.sparse.indices.byteOffset||0,m=o.sparse.values.byteOffset||0,f=new r(e[1],d,o.sparse.count*t),_=new c(e[2],m,o.sparse.count*h);null!==l&&(x=new n.BufferAttribute(x.array.slice(),x.itemSize,x.normalized));for(let i=0,e=f.length;i<e;i++){const e=f[i];if(x.setX(e,_[i*h]),h>=2&&x.setY(e,_[i*h+1]),h>=3&&x.setZ(e,_[i*h+2]),h>=4&&x.setW(e,_[i*h+3]),h>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return x}))}loadTexture(e){const t=this.json,r=this.options,n=t.textures[e].source,o=t.images[n];let l=this.textureLoader;if(o.uri){const e=r.manager.getHandler(o.uri);null!==e&&(l=e)}return this.loadTextureImage(e,n,l)}loadTextureImage(e,t,r){const o=this,l=this.json,h=l.textures[e],c=l.images[t],d=(c.uri||c.bufferView)+":"+h.sampler;if(this.textureCache[d])return this.textureCache[d];const m=this.loadImageSource(t,r).then((function(t){t.flipY=!1,h.name&&(t.name=h.name);const r=(l.samplers||{})[h.sampler]||{};return t.magFilter=Y[r.magFilter]||n.LinearFilter,t.minFilter=Y[r.minFilter]||n.LinearMipmapLinearFilter,t.wrapS=X[r.wrapS]||n.RepeatWrapping,t.wrapT=X[r.wrapT]||n.RepeatWrapping,o.associations.set(t,{textures:e}),t})).catch((function(){return null}));return this.textureCache[d]=m,m}loadImageSource(e,t){const r=this,o=this.json,l=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then((e=>e.clone()));const h=o.images[e],c=self.URL||self.webkitURL;let d=h.uri||"",m=!1;if(void 0!==h.bufferView)d=r.getDependency("bufferView",h.bufferView).then((function(e){m=!0;const t=new Blob([e],{type:h.mimeType});return d=c.createObjectURL(t),d}));else if(void 0===h.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const f=Promise.resolve(d).then((function(e){return new Promise((function(r,o){let h=r;!0===t.isImageBitmapLoader&&(h=function(e){const t=new n.Texture(e);t.needsUpdate=!0,r(t)}),t.load(n.LoaderUtils.resolveURL(e,l.path),h,void 0,o)}))})).then((function(e){var t;return!0===m&&c.revokeObjectURL(d),e.userData.mimeType=h.mimeType||((t=h.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":"image/png"),e})).catch((function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",d),e}));return this.sourceCache[e]=f,f}assignTexture(e,t,r,n){const o=this;return this.getDependency("texture",r.index).then((function(l){if(void 0===r.texCoord||0==r.texCoord||"aoMap"===t&&1==r.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+t+" not yet supported."),o.extensions[h.KHR_TEXTURE_TRANSFORM]){const e=void 0!==r.extensions?r.extensions[h.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=o.associations.get(l);l=o.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(l,e),o.associations.set(l,t)}}return void 0!==n&&(l.encoding=n),e[t]=l,l}))}assignFinalMaterial(e){const t=e.geometry;let r=e.material;const o=void 0===t.attributes.tangent,l=void 0!==t.attributes.color,h=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+r.uuid;let t=this.cache.get(e);t||(t=new n.PointsMaterial,n.Material.prototype.copy.call(t,r),t.color.copy(r.color),t.map=r.map,t.sizeAttenuation=!1,this.cache.add(e,t)),r=t}else if(e.isLine){const e="LineBasicMaterial:"+r.uuid;let t=this.cache.get(e);t||(t=new n.LineBasicMaterial,n.Material.prototype.copy.call(t,r),t.color.copy(r.color),this.cache.add(e,t)),r=t}if(o||l||h){let e="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),o&&(e+="derivative-tangents:"),l&&(e+="vertex-colors:"),h&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=r.clone(),l&&(t.vertexColors=!0),h&&(t.flatShading=!0),o&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(r))),r=t}r.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=r}getMaterialType(){return n.MeshStandardMaterial}loadMaterial(e){const t=this,r=this.json,o=this.extensions,l=r.materials[e];let c;const d={},m=l.extensions||{},f=[];if(m[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const e=o[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];c=e.getMaterialType(),f.push(e.extendParams(d,l,t))}else if(m[h.KHR_MATERIALS_UNLIT]){const e=o[h.KHR_MATERIALS_UNLIT];c=e.getMaterialType(),f.push(e.extendParams(d,l,t))}else{const r=l.pbrMetallicRoughness||{};if(d.color=new n.Color(1,1,1),d.opacity=1,Array.isArray(r.baseColorFactor)){const e=r.baseColorFactor;d.color.fromArray(e),d.opacity=e[3]}void 0!==r.baseColorTexture&&f.push(t.assignTexture(d,"map",r.baseColorTexture,n.sRGBEncoding)),d.metalness=void 0!==r.metallicFactor?r.metallicFactor:1,d.roughness=void 0!==r.roughnessFactor?r.roughnessFactor:1,void 0!==r.metallicRoughnessTexture&&(f.push(t.assignTexture(d,"metalnessMap",r.metallicRoughnessTexture)),f.push(t.assignTexture(d,"roughnessMap",r.metallicRoughnessTexture))),c=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),f.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,d)}))))}!0===l.doubleSided&&(d.side=n.DoubleSide);const _=l.alphaMode||$;if(_===te?(d.transparent=!0,d.depthWrite=!1):(d.transparent=!1,_===ee&&(d.alphaTest=void 0!==l.alphaCutoff?l.alphaCutoff:.5)),void 0!==l.normalTexture&&c!==n.MeshBasicMaterial&&(f.push(t.assignTexture(d,"normalMap",l.normalTexture)),d.normalScale=new n.Vector2(1,1),void 0!==l.normalTexture.scale)){const e=l.normalTexture.scale;d.normalScale.set(e,e)}return void 0!==l.occlusionTexture&&c!==n.MeshBasicMaterial&&(f.push(t.assignTexture(d,"aoMap",l.occlusionTexture)),void 0!==l.occlusionTexture.strength&&(d.aoMapIntensity=l.occlusionTexture.strength)),void 0!==l.emissiveFactor&&c!==n.MeshBasicMaterial&&(d.emissive=(new n.Color).fromArray(l.emissiveFactor)),void 0!==l.emissiveTexture&&c!==n.MeshBasicMaterial&&f.push(t.assignTexture(d,"emissiveMap",l.emissiveTexture,n.sRGBEncoding)),Promise.all(f).then((function(){let r;return r=c===P?o[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(d):new c(d),l.name&&(r.name=l.name),re(r,l),t.associations.set(r,{materials:e}),l.extensions&&se(o,r,l),r}))}createUniqueName(e){const t=n.PropertyBinding.sanitizeNodeName(e||"");let r=t;for(let i=1;this.nodeNamesUsed[r];++i)r=t+"_"+i;return this.nodeNamesUsed[r]=!0,r}loadGeometries(e){const t=this,r=this.extensions,o=this.primitiveCache;function l(e){return r[h.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(r){return ce(r,e,t)}))}const c=[];for(let i=0,r=e.length;i<r;i++){const r=e[i],d=ne(r),m=o[d];if(m)c.push(m.promise);else{let e;e=r.extensions&&r.extensions[h.KHR_DRACO_MESH_COMPRESSION]?l(r):ce(new n.BufferGeometry,r,t),o[d]={primitive:r,promise:e},c.push(e)}}return Promise.all(c)}loadMesh(e){const t=this,r=this.json,o=this.extensions,l=r.meshes[e],h=l.primitives,c=[];for(let i=0,e=h.length;i<e;i++){const e=void 0===h[i].material?(void 0===(d=this.cache).DefaultMaterial&&(d.DefaultMaterial=new n.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:n.FrontSide})),d.DefaultMaterial):this.getDependency("material",h[i].material);c.push(e)}var d;return c.push(t.loadGeometries(h)),Promise.all(c).then((function(r){const c=r.slice(0,r.length-1),d=r[r.length-1],m=[];for(let i=0,r=d.length;i<r;i++){const r=d[i],f=h[i];let _;const v=c[i];if(f.mode===V||f.mode===G||f.mode===j||void 0===f.mode)_=!0===l.isSkinnedMesh?new n.SkinnedMesh(r,v):new n.Mesh(r,v),!0!==_.isSkinnedMesh||_.geometry.attributes.skinWeight.normalized||_.normalizeSkinWeights(),f.mode===G?_.geometry=ue(_.geometry,n.TriangleStripDrawMode):f.mode===j&&(_.geometry=ue(_.geometry,n.TriangleFanDrawMode));else if(f.mode===k)_=new n.LineSegments(r,v);else if(f.mode===z)_=new n.Line(r,v);else if(f.mode===H)_=new n.LineLoop(r,v);else{if(f.mode!==B)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+f.mode);_=new n.Points(r,v)}Object.keys(_.geometry.morphAttributes).length>0&&ie(_,l),_.name=t.createUniqueName(l.name||"mesh_"+e),re(_,l),f.extensions&&se(o,_,f),t.assignFinalMaterial(_),m.push(_)}for(let i=0,r=m.length;i<r;i++)t.associations.set(m[i],{meshes:e,primitives:i});if(1===m.length)return m[0];const f=new n.Group;t.associations.set(f,{meshes:e});for(let i=0,e=m.length;i<e;i++)f.add(m[i]);return f}))}loadCamera(e){let t;const r=this.json.cameras[e],o=r[r.type];if(o)return"perspective"===r.type?t=new n.PerspectiveCamera(n.MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):"orthographic"===r.type&&(t=new n.OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),r.name&&(t.name=this.createUniqueName(r.name)),re(t,r),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],r={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(r):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return r.inverseBindMatrices=e,r}))}loadAnimation(e){const t=this.json.animations[e],r=[],o=[],l=[],h=[],c=[];for(let i=0,e=t.channels.length;i<e;i++){const e=t.channels[i],n=t.samplers[e.sampler],d=e.target,m=void 0!==d.node?d.node:d.id,input=void 0!==t.parameters?t.parameters[n.input]:n.input,output=void 0!==t.parameters?t.parameters[n.output]:n.output;r.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",input)),l.push(this.getDependency("accessor",output)),h.push(n),c.push(d)}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(l),Promise.all(h),Promise.all(c)]).then((function(r){const o=r[0],l=r[1],h=r[2],c=r[3],d=r[4],m=[];for(let i=0,e=o.length;i<e;i++){const e=o[i],t=l[i],r=h[i],f=c[i],_=d[i];if(void 0===e)continue;let v;switch(e.updateMatrix(),e.matrixAutoUpdate=!0,Z[_.path]){case Z.weights:v=n.NumberKeyframeTrack;break;case Z.rotation:v=n.QuaternionKeyframeTrack;break;default:v=n.VectorKeyframeTrack}const T=e.name?e.name:e.uuid,x=void 0!==f.interpolation?J[f.interpolation]:n.InterpolateLinear,E=[];Z[_.path]===Z.weights?e.traverse((function(object){object.morphTargetInfluences&&E.push(object.name?object.name:object.uuid)})):E.push(T);let y=r.array;if(r.normalized){const e=oe(y.constructor),t=new Float32Array(y.length);for(let r=0,n=y.length;r<n;r++)t[r]=y[r]*e;y=t}for(let e=0,r=E.length;e<r;e++){const track=new v(E[e]+"."+Z[_.path],t.array,y,x);"CUBICSPLINE"===f.interpolation&&(track.createInterpolant=function(e){return new(this instanceof n.QuaternionKeyframeTrack?N:F)(this.times,this.values,this.getValueSize()/3,e)},track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(track)}}const f=t.name?t.name:"animation_"+e;return new n.AnimationClip(f,void 0,m)}))}createNodeMesh(e){const t=this.json,r=this,n=t.nodes[e];return void 0===n.mesh?null:r.getDependency("mesh",n.mesh).then((function(e){const t=r._getNodeRef(r.meshCache,n.mesh,e);return void 0!==n.weights&&t.traverse((function(e){if(e.isMesh)for(let i=0,t=n.weights.length;i<t;i++)e.morphTargetInfluences[i]=n.weights[i]})),t}))}loadNode(e){const t=this.json,r=this.extensions,o=this,l=t.nodes[e],h=l.name?o.createUniqueName(l.name):"";return function(){const t=[],r=o._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return r&&t.push(r),void 0!==l.camera&&t.push(o.getDependency("camera",l.camera).then((function(e){return o._getNodeRef(o.cameraCache,l.camera,e)}))),o._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){t.push(e)})),Promise.all(t)}().then((function(t){let c;if(c=!0===l.isBone?new n.Bone:t.length>1?new n.Group:1===t.length?t[0]:new n.Object3D,c!==t[0])for(let i=0,e=t.length;i<e;i++)c.add(t[i]);if(l.name&&(c.userData.name=l.name,c.name=h),re(c,l),l.extensions&&se(r,c,l),void 0!==l.matrix){const e=new n.Matrix4;e.fromArray(l.matrix),c.applyMatrix4(e)}else void 0!==l.translation&&c.position.fromArray(l.translation),void 0!==l.rotation&&c.quaternion.fromArray(l.rotation),void 0!==l.scale&&c.scale.fromArray(l.scale);return o.associations.has(c)||o.associations.set(c,{}),o.associations.get(c).nodes=e,c}))}loadScene(e){const t=this.json,r=this.extensions,o=this.json.scenes[e],l=this,h=new n.Group;o.name&&(h.name=l.createUniqueName(o.name)),re(h,o),o.extensions&&se(r,h,o);const c=o.nodes||[],d=[];for(let i=0,e=c.length;i<e;i++)d.push(he(c[i],h,t,l));return Promise.all(d).then((function(){return l.associations=(e=>{const t=new Map;for(const[e,r]of l.associations)(e instanceof n.Material||e instanceof n.Texture)&&t.set(e,r);return e.traverse((e=>{const r=l.associations.get(e);null!=r&&t.set(e,r)})),t})(h),h}))}}function he(e,t,r,o){const l=r.nodes[e];return o.getDependency("node",e).then((function(e){if(void 0===l.skin)return e;let t;return o.getDependency("skin",l.skin).then((function(e){t=e;const r=[];for(let i=0,e=t.joints.length;i<e;i++)r.push(o.getDependency("node",t.joints[i]));return Promise.all(r)})).then((function(r){return e.traverse((function(e){if(!e.isMesh)return;const o=[],l=[];for(let e=0,h=r.length;e<h;e++){const h=r[e];if(h){o.push(h);const r=new n.Matrix4;void 0!==t.inverseBindMatrices&&r.fromArray(t.inverseBindMatrices.array,16*e),l.push(r)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}e.bind(new n.Skeleton(o,l),e.matrixWorld)})),e}))})).then((function(e){t.add(e);const n=[];if(l.children){const t=l.children;for(let i=0,l=t.length;i<l;i++){const l=t[i];n.push(he(l,e,r,o))}}return Promise.all(n)}))}function ce(e,t,r){const o=t.attributes,l=[];function h(t,n){return r.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(const t in o){const r=W[t]||t.toLowerCase();r in e.attributes||l.push(h(o[t],r))}if(void 0!==t.indices&&!e.index){const n=r.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));l.push(n)}return re(e,t),function(e,t,r){const o=t.attributes,l=new n.Box3;if(void 0===o.POSITION)return;{const e=r.json.accessors[o.POSITION],t=e.min,h=e.max;if(void 0===t||void 0===h)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(l.set(new n.Vector3(t[0],t[1],t[2]),new n.Vector3(h[0],h[1],h[2])),e.normalized){const t=oe(K[e.componentType]);l.min.multiplyScalar(t),l.max.multiplyScalar(t)}}const h=t.targets;if(void 0!==h){const e=new n.Vector3,t=new n.Vector3;for(let i=0,n=h.length;i<n;i++){const n=h[i];if(void 0!==n.POSITION){const o=r.json.accessors[n.POSITION],l=o.min,h=o.max;if(void 0!==l&&void 0!==h){if(t.setX(Math.max(Math.abs(l[0]),Math.abs(h[0]))),t.setY(Math.max(Math.abs(l[1]),Math.abs(h[1]))),t.setZ(Math.max(Math.abs(l[2]),Math.abs(h[2]))),o.normalized){const e=oe(K[o.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}l.expandByVector(e)}e.boundingBox=l;const c=new n.Sphere;l.getCenter(c.center),c.radius=l.min.distanceTo(l.max)/2,e.boundingSphere=c}(e,t,r),Promise.all(l).then((function(){return void 0!==t.targets?function(e,t,r){let n=!1,o=!1,l=!1;for(let i=0,e=t.length;i<e;i++){const e=t[i];if(void 0!==e.POSITION&&(n=!0),void 0!==e.NORMAL&&(o=!0),void 0!==e.COLOR_0&&(l=!0),n&&o&&l)break}if(!n&&!o&&!l)return Promise.resolve(e);const h=[],c=[],d=[];for(let i=0,m=t.length;i<m;i++){const m=t[i];if(n){const t=void 0!==m.POSITION?r.getDependency("accessor",m.POSITION):e.attributes.position;h.push(t)}if(o){const t=void 0!==m.NORMAL?r.getDependency("accessor",m.NORMAL):e.attributes.normal;c.push(t)}if(l){const t=void 0!==m.COLOR_0?r.getDependency("accessor",m.COLOR_0):e.attributes.color;d.push(t)}}return Promise.all([Promise.all(h),Promise.all(c),Promise.all(d)]).then((function(t){const r=t[0],h=t[1],c=t[2];return n&&(e.morphAttributes.position=r),o&&(e.morphAttributes.normal=h),l&&(e.morphAttributes.color=c),e.morphTargetsRelative=!0,e}))}(e,t.targets,r):e}))}function ue(e,t){let r=e.getIndex();if(null===r){const t=[],n=e.getAttribute("position");if(void 0===n)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let i=0;i<n.count;i++)t.push(i);e.setIndex(t),r=e.getIndex()}const o=r.count-2,l=[];if(t===n.TriangleFanDrawMode)for(let i=1;i<=o;i++)l.push(r.getX(0)),l.push(r.getX(i)),l.push(r.getX(i+1));else for(let i=0;i<o;i++)i%2==0?(l.push(r.getX(i)),l.push(r.getX(i+1)),l.push(r.getX(i+2))):(l.push(r.getX(i+2)),l.push(r.getX(i+1)),l.push(r.getX(i)));l.length/3!==o&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const h=e.clone();return h.setIndex(l),h}},652:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"}},653:function(e,t,r){"use strict";r.d(t,"a",(function(){return l}));var n=r(27),o=r(648);class l extends o.b{constructor(e,t,r,o,l){super(),this.scene=e,this.camera=t,this.overrideMaterial=r,this.clearColor=o,this.clearAlpha=void 0!==l?l:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new n.Color}render(e,t,r){const n=e.autoClear;let o,l;e.autoClear=!1,void 0!==this.overrideMaterial&&(l=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),o=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:r),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,o),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=l),e.autoClear=n}}},654:function(e,t,r){"use strict";r.d(t,"a",(function(){return h}));var n=r(27),o=r(648),l=r(652);class h extends o.b{constructor(e,t,r,h){super(),this.renderScene=t,this.renderCamera=r,this.selectedObjects=void 0!==h?h:[],this.visibleEdgeColor=new n.Color(1,1,1),this.hiddenEdgeColor=new n.Color(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=void 0!==e?new n.Vector2(e.x,e.y):new n.Vector2(256,256);const c=Math.round(this.resolution.x/this.downSampleRatio),d=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new n.MeshDepthMaterial,this.depthMaterial.side=n.DoubleSide,this.depthMaterial.depthPacking=n.RGBADepthPacking,this.depthMaterial.blending=n.NoBlending,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=n.DoubleSide,this.prepareMaskMaterial.fragmentShader=function(e,t){const r=t.isPerspectiveCamera?"perspective":"orthographic";return e.replace(/DEPTH_TO_VIEW_Z/g,r+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new n.WebGLRenderTarget(c,d),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new n.WebGLRenderTarget(c,d),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new n.WebGLRenderTarget(Math.round(c/2),Math.round(d/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new n.WebGLRenderTarget(c,d),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new n.WebGLRenderTarget(Math.round(c/2),Math.round(d/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(c,d),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(c/2),Math.round(d/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===l.a&&console.error("THREE.OutlinePass relies on CopyShader");const m=l.a;this.copyUniforms=n.UniformsUtils.clone(m.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new n.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,blending:n.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new n.Color,this.oldClearAlpha=1,this.fsQuad=new o.a(null),this.tempPulseColor1=new n.Color,this.tempPulseColor2=new n.Color,this.textureMatrix=new n.Matrix4}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t),this.renderTargetDepthBuffer.setSize(e,t);let r=Math.round(e/this.downSampleRatio),n=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(r,n),this.renderTargetBlurBuffer1.setSize(r,n),this.renderTargetEdgeBuffer1.setSize(r,n),this.separableBlurMaterial1.uniforms.texSize.value.set(r,n),r=Math.round(r/2),n=Math.round(n/2),this.renderTargetBlurBuffer2.setSize(r,n),this.renderTargetEdgeBuffer2.setSize(r,n),this.separableBlurMaterial2.uniforms.texSize.value.set(r,n)}changeVisibilityOfSelectedObjects(e){const t=this._visibilityCache;function r(object){object.isMesh&&(!0===e?object.visible=t.get(object):(t.set(object,object.visible),object.visible=e))}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(r)}}changeVisibilityOfNonSelectedObjects(e){const t=this._visibilityCache,r=[];function n(object){object.isMesh&&r.push(object)}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(n)}this.renderScene.traverse((function(object){if(object.isMesh||object.isSprite){let n=!1;for(let i=0;i<r.length;i++){if(r[i].id===object.id){n=!0;break}}if(!1===n){const r=object.visible;!1!==e&&!0!==t.get(object)||(object.visible=e),t.set(object,r)}}else(object.isPoints||object.isLine)&&(!0===e?object.visible=t.get(object):(t.set(object,object.visible),object.visible=e))}))}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(e,t,r,n,o){if(this.selectedObjects.length>0){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const t=e.autoClear;e.autoClear=!1,o&&e.state.buffers.stencil.setTest(!1),e.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const n=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=n,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const e=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(e),this.tempPulseColor2.multiplyScalar(e)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=h.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=h.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=h.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=h.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,o&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(r),this.fsQuad.render(e),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=t}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=r.texture,e.setRenderTarget(null),this.fsQuad.render(e))}getPrepareMaskMaterial(){return new n.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new n.Vector2(.5,.5)},textureMatrix:{value:null}},vertexShader:"#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",fragmentShader:"#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}"})}getEdgeDetectionMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},visibleEdgeColor:{value:new n.Vector3(1,1,1)},hiddenEdgeColor:{value:new n.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}"})}getSeperableBlurMaterial(e){return new n.ShaderMaterial({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},direction:{value:new n.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}"})}getOverlayMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",blending:n.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}}h.BlurDirectionX=new n.Vector2(1,0),h.BlurDirectionY=new n.Vector2(0,1)},655:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},resolution:{value:new(r(27).Vector2)(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t"}},656:function(e,t,r){"use strict";var n;function o(e){return e.isPerspectiveCamera}function l(e){return e.isOrthographicCamera}r.d(t,"a",(function(){return Z})),function(e){e[e.NONE=0]="NONE",e[e.ROTATE=1]="ROTATE",e[e.TRUCK=2]="TRUCK",e[e.OFFSET=3]="OFFSET",e[e.DOLLY=4]="DOLLY",e[e.ZOOM=5]="ZOOM",e[e.TOUCH_ROTATE=6]="TOUCH_ROTATE",e[e.TOUCH_TRUCK=7]="TOUCH_TRUCK",e[e.TOUCH_OFFSET=8]="TOUCH_OFFSET",e[e.TOUCH_DOLLY=9]="TOUCH_DOLLY",e[e.TOUCH_ZOOM=10]="TOUCH_ZOOM",e[e.TOUCH_DOLLY_TRUCK=11]="TOUCH_DOLLY_TRUCK",e[e.TOUCH_DOLLY_OFFSET=12]="TOUCH_DOLLY_OFFSET",e[e.TOUCH_ZOOM_TRUCK=13]="TOUCH_ZOOM_TRUCK",e[e.TOUCH_ZOOM_OFFSET=14]="TOUCH_ZOOM_OFFSET"}(n||(n={}));const h=2*Math.PI,c=Math.PI/2;function d(e,t=1e-5){return Math.abs(e)<t}function m(a,b,e=1e-5){return d(a-b,e)}function f(e,t){return Math.round(e/t)*t}function _(e){return isFinite(e)?e:e<0?-Number.MAX_VALUE:Number.MAX_VALUE}function v(e){return Math.abs(e)<Number.MAX_VALUE?e:e*(1/0)}function T(e,t){t.set(0,0),e.forEach((e=>{t.x+=e.clientX,t.y+=e.clientY})),t.x/=e.length,t.y/=e.length}function x(e,t){return!!l(e)&&(console.warn(`${t} is not supported in OrthographicCamera`),!0)}function E(e){return e.invert?e.invert():e.inverse(),e}const y="undefined"!=typeof window,M=y&&/Mac/.test(navigator.platform),S=!(y&&"PointerEvent"in window),R=Object.freeze(n),w=1/8;let O,A,C,L,P,D,U,F,I,N,B,k,H,z,V,G,j,K,Y,X,Q,W;class Z extends class{constructor(){this._listeners={}}addEventListener(e,t){const r=this._listeners;void 0===r[e]&&(r[e]=[]),-1===r[e].indexOf(t)&&r[e].push(t)}removeEventListener(e,t){const r=this._listeners[e];if(void 0!==r){const e=r.indexOf(t);-1!==e&&r.splice(e,1)}}removeAllEventListeners(e){e?Array.isArray(this._listeners[e])&&(this._listeners[e].length=0):this._listeners={}}dispatchEvent(e){const t=this._listeners[e.type];if(void 0!==t){e.target=this;const r=t.slice(0);for(let i=0,t=r.length;i<t;i++)r[i].call(this,e)}}}{constructor(e,t){if(super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=0,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.dampingFactor=.05,this.draggingDampingFactor=.25,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=n.NONE,this._viewport=null,this._dollyControlAmount=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._activePointers=[],this._truckInternal=(e,t,r)=>{if(o(this._camera)){const n=D.copy(this._camera.position).sub(this._target),o=this._camera.getEffectiveFOV()*O.MathUtils.DEG2RAD,l=n.length()*Math.tan(.5*o),h=this.truckSpeed*e*l/this._elementRect.height,c=this.truckSpeed*t*l/this._elementRect.height;this.verticalDragToForward?(r?this.setFocalOffset(this._focalOffsetEnd.x+h,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(h,0,!0),this.forward(-c,!0)):r?this.setFocalOffset(this._focalOffsetEnd.x+h,this._focalOffsetEnd.y+c,this._focalOffsetEnd.z,!0):this.truck(h,c,!0)}else if(l(this._camera)){const n=this._camera,o=e*(n.right-n.left)/n.zoom/this._elementRect.width,l=t*(n.top-n.bottom)/n.zoom/this._elementRect.height;r?this.setFocalOffset(this._focalOffsetEnd.x+o,this._focalOffsetEnd.y+l,this._focalOffsetEnd.z,!0):this.truck(o,l,!0)}},this._rotateInternal=(e,t)=>{const r=h*this.azimuthRotateSpeed*e/this._elementRect.height,n=h*this.polarRotateSpeed*t/this._elementRect.height;this.rotate(r,n,!0)},this._dollyInternal=(e,t,r)=>{const n=Math.pow(.95,-e*this.dollySpeed),o=this._sphericalEnd.radius*n,l=this._sphericalEnd.radius,h=l*(e>=0?-1:1);this.dollyTo(o),this.infinityDolly&&(o<this.minDistance||this.maxDistance===this.minDistance)&&(this._camera.getWorldDirection(D),this._targetEnd.add(D.normalize().multiplyScalar(h)),this._target.add(D.normalize().multiplyScalar(h))),this.dollyToCursor&&(this._dollyControlAmount+=this._sphericalEnd.radius-l,this.infinityDolly&&(o<this.minDistance||this.maxDistance===this.minDistance)&&(this._dollyControlAmount-=h),this._dollyControlCoord.set(t,r))},this._zoomInternal=(e,t,r)=>{const n=Math.pow(.95,e*this.dollySpeed);this.zoomTo(this._zoom*n),this.dollyToCursor&&(this._dollyControlAmount=this._zoomEnd,this._dollyControlCoord.set(t,r))},void 0===O&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=(new O.Quaternion).setFromUnitVectors(this._camera.up,C),this._yAxisUpSpaceInverse=E(this._yAxisUpSpace.clone()),this._state=n.NONE,this._domElement=t,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._target=new O.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new O.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=(new O.Spherical).setFromVector3(D.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._nearPlaneCorners=[new O.Vector3,new O.Vector3,new O.Vector3,new O.Vector3],this._updateNearPlaneCorners(),this._boundary=new O.Box3(new O.Vector3(-1/0,-1/0,-1/0),new O.Vector3(1/0,1/0,1/0)),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlAmount=0,this._dollyControlCoord=new O.Vector2,this.mouseButtons={left:n.ROTATE,middle:n.DOLLY,right:n.TRUCK,wheel:o(this._camera)?n.DOLLY:l(this._camera)?n.ZOOM:n.NONE,shiftLeft:n.NONE},this.touches={one:n.TOUCH_ROTATE,two:o(this._camera)?n.TOUCH_DOLLY_TRUCK:l(this._camera)?n.TOUCH_ZOOM_TRUCK:n.NONE,three:n.TOUCH_TRUCK},this._domElement){const e=new O.Vector2,t=new O.Vector2,r=new O.Vector2,o=e=>{if(!this._enabled)return;const t={pointerId:e.pointerId,clientX:e.clientX,clientY:e.clientY};switch(this._activePointers.push(t),e.button){case O.MOUSE.LEFT:this._state=e.shiftKey?this.mouseButtons.shiftLeft:this.mouseButtons.left;break;case O.MOUSE.MIDDLE:this._state=this.mouseButtons.middle;break;case O.MOUSE.RIGHT:this._state=this.mouseButtons.right}if("touch"===e.pointerType)switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),R()},l=e=>{if(!this._enabled)return;const t={pointerId:0,clientX:e.clientX,clientY:e.clientY};switch(this._activePointers.push(t),e.button){case O.MOUSE.LEFT:this._state=e.shiftKey?this.mouseButtons.shiftLeft:this.mouseButtons.left;break;case O.MOUSE.MIDDLE:this._state=this.mouseButtons.middle;break;case O.MOUSE.RIGHT:this._state=this.mouseButtons.right}this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",_),this._domElement.ownerDocument.addEventListener("mousemove",d),this._domElement.ownerDocument.addEventListener("mouseup",_),R()},h=e=>{if(this._enabled){switch(e.preventDefault(),Array.prototype.forEach.call(e.changedTouches,(e=>{const t={pointerId:e.identifier,clientX:e.clientX,clientY:e.clientY};this._activePointers.push(t)})),this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("touchend",v),this._domElement.ownerDocument.addEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.addEventListener("touchend",v),R()}},c=e=>{e.cancelable&&e.preventDefault();const t=e.pointerId,r=this._findPointerById(t);r&&(r.clientX=e.clientX,r.clientY=e.clientY,A())},d=e=>{const t=this._findPointerById(0);t&&(t.clientX=e.clientX,t.clientY=e.clientY,A())},m=e=>{e.cancelable&&e.preventDefault(),Array.prototype.forEach.call(e.changedTouches,(e=>{const t=e.identifier,r=this._findPointerById(t);r&&(r.clientX=e.clientX,r.clientY=e.clientY)})),A()},f=e=>{const t=e.pointerId,r=this._findPointerById(t);if(r&&this._activePointers.splice(this._activePointers.indexOf(r),1),"touch"===e.pointerType)switch(this._activePointers.length){case 0:this._state=n.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}else this._state=n.NONE;C()},_=()=>{const e=this._findPointerById(0);e&&this._activePointers.splice(this._activePointers.indexOf(e),1),this._state=n.NONE,C()},v=e=>{switch(Array.prototype.forEach.call(e.changedTouches,(e=>{const t=e.identifier,r=this._findPointerById(t);r&&this._activePointers.splice(this._activePointers.indexOf(r),1)})),this._activePointers.length){case 0:this._state=n.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}C()};let x=-1;const E=e=>{if(!this._enabled||this.mouseButtons.wheel===n.NONE)return;if(e.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===n.ROTATE||this.mouseButtons.wheel===n.TRUCK){const e=performance.now();x-e<1e3&&this._getClientRect(this._elementRect),x=e}const t=M?-1:-3,r=1===e.deltaMode?e.deltaY/t:e.deltaY/(10*t),o=this.dollyToCursor?(e.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,l=this.dollyToCursor?(e.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case n.ROTATE:this._rotateInternal(e.deltaX,e.deltaY);break;case n.TRUCK:this._truckInternal(e.deltaX,e.deltaY,!1);break;case n.OFFSET:this._truckInternal(e.deltaX,e.deltaY,!0);break;case n.DOLLY:this._dollyInternal(-r,o,l);break;case n.ZOOM:this._zoomInternal(-r,o,l)}this.dispatchEvent({type:"control"})},y=e=>{this._enabled&&e.preventDefault()},R=()=>{if(!this._enabled)return;T(this._activePointers,P),this._getClientRect(this._elementRect),e.copy(P),t.copy(P);if(this._activePointers.length>=2){const e=P.x-this._activePointers[1].clientX,n=P.y-this._activePointers[1].clientY,o=Math.sqrt(e*e+n*n);r.set(0,o);const l=.5*(this._activePointers[0].clientX+this._activePointers[1].clientX),h=.5*(this._activePointers[0].clientY+this._activePointers[1].clientY);t.set(l,h)}this.dispatchEvent({type:"controlstart"})},A=()=>{if(!this._enabled)return;T(this._activePointers,P);const o=t.x-P.x,l=t.y-P.y;switch(t.copy(P),this._state){case n.ROTATE:case n.TOUCH_ROTATE:this._rotateInternal(o,l);break;case n.DOLLY:case n.ZOOM:{const t=this.dollyToCursor?(e.x-this._elementRect.x)/this._elementRect.width*2-1:0,r=this.dollyToCursor?(e.y-this._elementRect.y)/this._elementRect.height*-2+1:0;this._state===n.DOLLY?this._dollyInternal(l*w,t,r):this._zoomInternal(l*w,t,r);break}case n.TOUCH_DOLLY:case n.TOUCH_ZOOM:case n.TOUCH_DOLLY_TRUCK:case n.TOUCH_ZOOM_TRUCK:case n.TOUCH_DOLLY_OFFSET:case n.TOUCH_ZOOM_OFFSET:{const e=P.x-this._activePointers[1].clientX,h=P.y-this._activePointers[1].clientY,c=Math.sqrt(e*e+h*h),d=r.y-c;r.set(0,c);const m=this.dollyToCursor?(t.x-this._elementRect.x)/this._elementRect.width*2-1:0,f=this.dollyToCursor?(t.y-this._elementRect.y)/this._elementRect.height*-2+1:0;this._state===n.TOUCH_DOLLY||this._state===n.TOUCH_DOLLY_TRUCK||this._state===n.TOUCH_DOLLY_OFFSET?this._dollyInternal(d*w,m,f):this._zoomInternal(d*w,m,f),this._state===n.TOUCH_DOLLY_TRUCK||this._state===n.TOUCH_ZOOM_TRUCK?this._truckInternal(o,l,!1):this._state!==n.TOUCH_DOLLY_OFFSET&&this._state!==n.TOUCH_ZOOM_OFFSET||this._truckInternal(o,l,!0);break}case n.TRUCK:case n.TOUCH_TRUCK:this._truckInternal(o,l,!1);break;case n.OFFSET:case n.TOUCH_OFFSET:this._truckInternal(o,l,!0)}this.dispatchEvent({type:"control"})},C=()=>{T(this._activePointers,P),t.copy(P),0===this._activePointers.length&&(this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("touchend",v),this.dispatchEvent({type:"controlend"}))};this._domElement.addEventListener("pointerdown",o),S&&this._domElement.addEventListener("mousedown",l),S&&this._domElement.addEventListener("touchstart",h),this._domElement.addEventListener("pointercancel",f),this._domElement.addEventListener("wheel",E,{passive:!1}),this._domElement.addEventListener("contextmenu",y),this._removeAllEventListeners=()=>{this._domElement.removeEventListener("pointerdown",o),this._domElement.removeEventListener("mousedown",l),this._domElement.removeEventListener("touchstart",h),this._domElement.removeEventListener("pointercancel",f),this._domElement.removeEventListener("wheel",E,{passive:!1}),this._domElement.removeEventListener("contextmenu",y),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",_),this._domElement.ownerDocument.removeEventListener("touchend",v)},this.cancel=()=>{this._state!==n.NONE&&(this._state=n.NONE,this._activePointers.length=0,C())}}this.update(0)}static install(e){O=e.THREE,A=Object.freeze(new O.Vector3(0,0,0)),C=Object.freeze(new O.Vector3(0,1,0)),L=Object.freeze(new O.Vector3(0,0,1)),P=new O.Vector2,D=new O.Vector3,U=new O.Vector3,F=new O.Vector3,I=new O.Vector3,N=new O.Vector3,B=new O.Vector3,k=new O.Vector3,H=new O.Vector3,z=new O.Spherical,V=new O.Spherical,G=new O.Box3,j=new O.Box3,K=new O.Sphere,Y=new O.Quaternion,X=new O.Quaternion,Q=new O.Matrix4,W=new O.Raycaster}static get ACTION(){return R}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="")}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,r=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,r)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,r=!1){const n=O.MathUtils.clamp(e,this.minAzimuthAngle,this.maxAzimuthAngle),o=O.MathUtils.clamp(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=n,this._sphericalEnd.phi=o,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,r||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const l=!r||m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(l)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){const r=this._sphericalEnd.radius,n=O.MathUtils.clamp(e,this.minDistance,this.maxDistance);if(this.colliderMeshes.length>=1){const e=this._collisionTest(),t=m(e,this._spherical.radius);if(!(r>n)&&t)return Promise.resolve();this._sphericalEnd.radius=Math.min(n,e)}else this._sphericalEnd.radius=n;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const o=!t||m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(o)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._zoomEnd=O.MathUtils.clamp(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const r=!t||m(this._zoom,this._zoomEnd,this.restThreshold);return this._createOnRestPromise(r)}pan(e,t,r=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,r)}truck(e,t,r=!1){this._camera.updateMatrix(),I.setFromMatrixColumn(this._camera.matrix,0),N.setFromMatrixColumn(this._camera.matrix,1),I.multiplyScalar(e),N.multiplyScalar(-t);const n=D.copy(I).add(N),o=U.copy(this._targetEnd).add(n);return this.moveTo(o.x,o.y,o.z,r)}forward(e,t=!1){D.setFromMatrixColumn(this._camera.matrix,0),D.crossVectors(this._camera.up,D),D.multiplyScalar(e);const r=U.copy(this._targetEnd).add(D);return this.moveTo(r.x,r.y,r.z,t)}moveTo(e,t,r,n=!1){const o=D.set(e,t,r).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,o,this.boundaryFriction),this._needsUpdate=!0,n||this._target.copy(this._targetEnd);const l=!n||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(l)}fitToBox(e,t,{paddingLeft:r=0,paddingRight:n=0,paddingBottom:h=0,paddingTop:d=0}={}){const _=[],v=e.isBox3?G.copy(e):G.setFromObject(e);v.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const T=f(this._sphericalEnd.theta,c),x=f(this._sphericalEnd.phi,c);_.push(this.rotateTo(T,x,t));const E=D.setFromSpherical(this._sphericalEnd).normalize(),y=Y.setFromUnitVectors(E,L);m(Math.abs(E.y),1)&&y.multiply(X.setFromAxisAngle(C,T));const M=j.makeEmpty();U.copy(v.min).applyQuaternion(y),M.expandByPoint(U),U.copy(v.min).setX(v.max.x).applyQuaternion(y),M.expandByPoint(U),U.copy(v.min).setY(v.max.y).applyQuaternion(y),M.expandByPoint(U),U.copy(v.max).setZ(v.min.z).applyQuaternion(y),M.expandByPoint(U),U.copy(v.min).setZ(v.max.z).applyQuaternion(y),M.expandByPoint(U),U.copy(v.max).setY(v.min.y).applyQuaternion(y),M.expandByPoint(U),U.copy(v.max).setX(v.min.x).applyQuaternion(y),M.expandByPoint(U),U.copy(v.max).applyQuaternion(y),M.expandByPoint(U),y.setFromUnitVectors(L,E),M.min.x-=r,M.min.y-=h,M.max.x+=n,M.max.y+=d;const S=M.getSize(D),R=M.getCenter(U).applyQuaternion(y);if(o(this._camera)){const e=this.getDistanceToFitBox(S.x,S.y,S.z);_.push(this.moveTo(R.x,R.y,R.z,t)),_.push(this.dollyTo(e,t)),_.push(this.setFocalOffset(0,0,0,t))}else if(l(this._camera)){const e=this._camera,r=e.right-e.left,n=e.top-e.bottom,o=Math.min(r/S.x,n/S.y);_.push(this.moveTo(R.x,R.y,R.z,t)),_.push(this.zoomTo(o,t)),_.push(this.setFocalOffset(0,0,0,t))}return Promise.all(_)}fitToSphere(e,t){const r=[],n=e instanceof O.Sphere?K.copy(e):function(e,t){const r=t,n=r.center;G.makeEmpty(),e.traverseVisible((object=>{object.isMesh&&G.expandByObject(object)})),G.getCenter(n);let o=0;return e.traverseVisible((object=>{if(!object.isMesh)return;const e=object,t=e.geometry.clone();if(t.applyMatrix4(e.matrixWorld),t.isBufferGeometry){const e=t.attributes.position;for(let i=0,t=e.count;i<t;i++)D.fromBufferAttribute(e,i),o=Math.max(o,n.distanceToSquared(D))}else{const e=t.attributes.position,r=new O.Vector3;for(let i=0,t=e.count;i<t;i++)r.fromBufferAttribute(e,i),o=Math.max(o,n.distanceToSquared(r))}})),r.radius=Math.sqrt(o),r}(e,K);if(r.push(this.moveTo(n.center.x,n.center.y,n.center.z,t)),o(this._camera)){const e=this.getDistanceToFitSphere(n.radius);r.push(this.dollyTo(e,t))}else if(l(this._camera)){const e=this._camera.right-this._camera.left,o=this._camera.top-this._camera.bottom,l=2*n.radius,h=Math.min(e/l,o/l);r.push(this.zoomTo(h,t))}return r.push(this.setFocalOffset(0,0,0,t)),Promise.all(r)}setLookAt(e,t,r,n,o,l,h=!1){const c=U.set(n,o,l),d=D.set(e,t,r);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(d.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,h||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const f=!h||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold)&&m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(f)}lerpLookAt(e,t,r,n,o,l,h,c,d,f,_,v,T,x=!1){const E=D.set(n,o,l),y=U.set(e,t,r);z.setFromVector3(y.sub(E).applyQuaternion(this._yAxisUpSpace));const M=F.set(f,_,v),S=U.set(h,c,d);V.setFromVector3(S.sub(M).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(E.lerp(M,T));const R=V.theta-z.theta,w=V.phi-z.phi,O=V.radius-z.radius;this._sphericalEnd.set(z.radius+O*T,z.phi+w*T,z.theta+R*T),this.normalizeRotations(),this._needsUpdate=!0,x||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const A=!x||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold)&&m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(A)}setPosition(e,t,r,n=!1){return this.setLookAt(e,t,r,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,n)}setTarget(e,t,r,n=!1){const o=this.getPosition(D);return this.setLookAt(o.x,o.y,o.z,e,t,r,n)}setFocalOffset(e,t,r,n=!1){this._focalOffsetEnd.set(e,t,r),this._needsUpdate=!0,n||this._focalOffset.copy(this._focalOffsetEnd);const o=!n||m(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&m(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&m(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}setOrbitPoint(e,t,r){I.setFromMatrixColumn(this._camera.matrixWorldInverse,0),N.setFromMatrixColumn(this._camera.matrixWorldInverse,1),B.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const n=D.set(e,t,r),o=n.distanceTo(this._camera.position),l=n.sub(this._camera.position);I.multiplyScalar(l.x),N.multiplyScalar(l.y),B.multiplyScalar(l.z),D.copy(I).add(N).add(B),D.z=D.z+o,this.dollyTo(o,!1),this.setFocalOffset(-D.x,D.y,-D.z,!1),this.moveTo(e,t,r,!1)}setBoundary(e){if(!e)return this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),void(this._needsUpdate=!0);this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,r,n){null!==e?(this._viewport=this._viewport||new O.Vector4,"number"==typeof e?this._viewport.set(e,t,r,n):this._viewport.copy(e)):this._viewport=null}getDistanceToFitBox(e,t,r){if(x(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const n=e/t,o=this._camera.getEffectiveFOV()*O.MathUtils.DEG2RAD,l=this._camera.aspect;return.5*(n<l?t:e/l)/Math.tan(.5*o)+.5*r}getDistanceToFitSphere(e){if(x(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*O.MathUtils.DEG2RAD,r=2*Math.atan(Math.tan(.5*t)*this._camera.aspect),n=1<this._camera.aspect?t:r;return e/Math.sin(.5*n)}getTarget(e){return(e&&e.isVector3?e:new O.Vector3).copy(this._targetEnd)}getPosition(e){return(e&&e.isVector3?e:new O.Vector3).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd)}getFocalOffset(e){return(e&&e.isVector3?e:new O.Vector3).copy(this._focalOffsetEnd)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%h,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=h),this._spherical.theta+=h*Math.round((this._sphericalEnd.theta-this._spherical.theta)/h)}reset(e=!1){const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._target0.copy(this._target),this._position0.copy(this._camera.position),this._zoom0=this._zoom}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,C),E(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace))}update(e){const t=this._state===n.NONE?this.dampingFactor:this.draggingDampingFactor,r=Math.min(t*e*60,1),h=this._sphericalEnd.theta-this._spherical.theta,c=this._sphericalEnd.phi-this._spherical.phi,m=this._sphericalEnd.radius-this._spherical.radius,f=k.subVectors(this._targetEnd,this._target),_=H.subVectors(this._focalOffsetEnd,this._focalOffset);if(d(h)&&d(c)&&d(m)&&d(f.x)&&d(f.y)&&d(f.z)&&d(_.x)&&d(_.y)&&d(_.z)?(this._spherical.copy(this._sphericalEnd),this._target.copy(this._targetEnd),this._focalOffset.copy(this._focalOffsetEnd)):(this._spherical.set(this._spherical.radius+m*r,this._spherical.phi+c*r,this._spherical.theta+h*r),this._target.add(f.multiplyScalar(r)),this._focalOffset.add(_.multiplyScalar(r)),this._needsUpdate=!0),0!==this._dollyControlAmount){if(o(this._camera)){const e=this._camera,t=D.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(),r=U.copy(t).cross(e.up).normalize();0===r.lengthSq()&&(r.x=1);const n=F.crossVectors(r,t),o=this._sphericalEnd.radius*Math.tan(e.getEffectiveFOV()*O.MathUtils.DEG2RAD*.5),l=(this._sphericalEnd.radius-this._dollyControlAmount-this._sphericalEnd.radius)/this._sphericalEnd.radius,cursor=D.copy(this._targetEnd).add(r.multiplyScalar(this._dollyControlCoord.x*o*e.aspect)).add(n.multiplyScalar(this._dollyControlCoord.y*o));this._targetEnd.lerp(cursor,l),this._target.copy(this._targetEnd)}else if(l(this._camera)){const e=this._camera,t=D.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(e.near+e.far)/(e.near-e.far)).unproject(e),r=U.set(0,0,-1).applyQuaternion(e.quaternion),n=r.dot(e.up),o=d(n)?-t.dot(e.up):-t.dot(e.up)/n,cursor=F.copy(t).add(r.multiplyScalar(o));this._targetEnd.lerp(cursor,1-e.zoom/this._dollyControlAmount),this._target.copy(this._targetEnd)}this._dollyControlAmount=0}const v=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,v),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target);(!d(this._focalOffset.x)||!d(this._focalOffset.y)||!d(this._focalOffset.z))&&(this._camera.updateMatrix(),I.setFromMatrixColumn(this._camera.matrix,0),N.setFromMatrixColumn(this._camera.matrix,1),B.setFromMatrixColumn(this._camera.matrix,2),I.multiplyScalar(this._focalOffset.x),N.multiplyScalar(-this._focalOffset.y),B.multiplyScalar(this._focalOffset.z),D.copy(I).add(N).add(B),this._camera.position.add(D)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),D.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const T=this._zoomEnd-this._zoom;this._zoom+=T*r,this._camera.zoom!==this._zoom&&(d(T)&&(this._zoom=this._zoomEnd),this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0);const x=this._needsUpdate;return x&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):x?(this.dispatchEvent({type:"update"}),d(h,this.restThreshold)&&d(c,this.restThreshold)&&d(m,this.restThreshold)&&d(f.x,this.restThreshold)&&d(f.y,this.restThreshold)&&d(f.z,this.restThreshold)&&d(_.x,this.restThreshold)&&d(_.y,this.restThreshold)&&d(_.z,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!x&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._updatedLastTime=x,this._needsUpdate=!1,x}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:_(this.maxDistance),minZoom:this.minZoom,maxZoom:_(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:_(this.maxPolarAngle),minAzimuthAngle:_(this.minAzimuthAngle),maxAzimuthAngle:_(this.maxAzimuthAngle),dampingFactor:this.dampingFactor,draggingDampingFactor:this.draggingDampingFactor,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:D.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const r=JSON.parse(e),n=D.fromArray(r.position);this.enabled=r.enabled,this.minDistance=r.minDistance,this.maxDistance=v(r.maxDistance),this.minZoom=r.minZoom,this.maxZoom=v(r.maxZoom),this.minPolarAngle=r.minPolarAngle,this.maxPolarAngle=v(r.maxPolarAngle),this.minAzimuthAngle=v(r.minAzimuthAngle),this.maxAzimuthAngle=v(r.maxAzimuthAngle),this.dampingFactor=r.dampingFactor,this.draggingDampingFactor=r.draggingDampingFactor,this.dollySpeed=r.dollySpeed,this.truckSpeed=r.truckSpeed,this.dollyToCursor=r.dollyToCursor,this.verticalDragToForward=r.verticalDragToForward,this._target0.fromArray(r.target0),this._position0.fromArray(r.position0),this._zoom0=r.zoom0,this._focalOffset0.fromArray(r.focalOffset0),this.moveTo(r.target[0],r.target[1],r.target[2],t),z.setFromVector3(n.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(z.theta,z.phi,t),this.zoomTo(r.zoom,t),this.setFocalOffset(r.focalOffset[0],r.focalOffset[1],r.focalOffset[2],t),this._needsUpdate=!0}dispose(){this._removeAllEventListeners()}_findPointerById(e){let t=null;return this._activePointers.some((r=>r.pointerId===e&&(t=r,!0))),t}_encloseToBoundary(e,t,r){const n=t.lengthSq();if(0===n)return e;const o=U.copy(t).add(e),l=this._boundary.clampPoint(o,F).sub(o),h=l.lengthSq();if(0===h)return e.add(t);if(h===n)return e;if(0===r)return e.add(t).add(l);{const n=1+r*h/t.dot(l);return e.add(U.copy(t).multiplyScalar(n)).add(l.multiplyScalar(1-r))}}_updateNearPlaneCorners(){if(o(this._camera)){const e=this._camera,t=e.near,r=e.getEffectiveFOV()*O.MathUtils.DEG2RAD,n=Math.tan(.5*r)*t,o=n*e.aspect;this._nearPlaneCorners[0].set(-o,-n,0),this._nearPlaneCorners[1].set(o,-n,0),this._nearPlaneCorners[2].set(o,n,0),this._nearPlaneCorners[3].set(-o,n,0)}else if(l(this._camera)){const e=this._camera,t=1/e.zoom,r=e.left*t,n=e.right*t,o=e.top*t,l=e.bottom*t;this._nearPlaneCorners[0].set(r,o,0),this._nearPlaneCorners[1].set(n,o,0),this._nearPlaneCorners[2].set(n,l,0),this._nearPlaneCorners[3].set(r,l,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1))return e;if(x(this._camera,"_collisionTest"))return e;const t=D.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);Q.lookAt(A,t,this._camera.up);for(let i=0;i<4;i++){const r=U.copy(this._nearPlaneCorners[i]);r.applyMatrix4(Q);const n=F.addVectors(this._target,r);W.set(n,t),W.far=this._spherical.radius+1;const o=W.intersectObjects(this.colliderMeshes);0!==o.length&&o[0].distance<e&&(e=o[0].distance)}return e}_getClientRect(e){const rect=this._domElement.getBoundingClientRect();return e.x=rect.left,e.y=rect.top,this._viewport?(e.x+=this._viewport.x,e.y+=rect.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=rect.width,e.height=rect.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise((e=>{const t=()=>{this.removeEventListener("rest",t),e()};this.addEventListener("rest",t)})))}_removeAllEventListeners(){}}},659:function(e,t,r){"use strict";r.d(t,"a",(function(){return m}));var n=r(27),o=r(652),l=r(649),h=r(648);class c extends h.b{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,r){const n=e.getContext(),o=e.state;let l,h;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(l=0,h=1):(l=1,h=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),o.buffers.stencil.setFunc(n.ALWAYS,l,4294967295),o.buffers.stencil.setClear(h),o.buffers.stencil.setLocked(!0),e.setRenderTarget(r),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(n.EQUAL,1,4294967295),o.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),o.buffers.stencil.setLocked(!0)}}class d extends h.b{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class m{constructor(e,t){if(this.renderer=e,void 0===t){const r=e.getSize(new n.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=r.width,this._height=r.height,(t=new n.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===o.a&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===l.a&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new l.a(o.a),this.clock=new n.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let i=e+1;i<this.passes.length;i++)if(this.passes[i].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let r=!1;for(let i=0,t=this.passes.length;i<t;i++){const t=this.passes[i];if(!1!==t.enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(i),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,r),t.needsSwap){if(r){const t=this.renderer.getContext(),r=this.renderer.state.buffers.stencil;r.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),r.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==c&&(t instanceof c?r=!0:t instanceof d&&(r=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new n.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const r=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(r,n),this.renderTarget2.setSize(r,n);for(let i=0;i<this.passes.length;i++)this.passes[i].setSize(r,n)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new n.OrthographicCamera(-1,1,1,-1,0,1);const f=new n.BufferGeometry;f.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),f.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2))},669:function(e,t,r){"use strict";r(7),r(3),r(8),r(105),r(29),r(392),r(288),r(88),r(111);var n=r(2);var o,l=r(43);t.a=(o="container",n.a.extend({name:"v-".concat(o),functional:!0,props:{id:String,tag:{type:String,default:"div"}},render:function(e,t){var r=t.props,data=t.data,n=t.children;data.staticClass="".concat(o," ").concat(data.staticClass||"").trim();var l=data.attrs;if(l){data.attrs={};var h=Object.keys(l).filter((function(e){if("slot"===e)return!1;var t=l[e];return e.startsWith("data-")?(data.attrs[e]=t,!1):t||"string"==typeof t}));h.length&&(data.staticClass+=" ".concat(h.join(" ")))}return r.id&&(data.domProps=data.domProps||{},data.domProps.id=r.id),e(r.tag,data,n)}})).extend({name:"v-container",functional:!0,props:{id:String,tag:{type:String,default:"div"},fluid:{type:Boolean,default:!1}},render:function(e,t){var r,n=t.props,data=t.data,o=t.children,h=data.attrs;return h&&(data.attrs={},r=Object.keys(h).filter((function(e){if("slot"===e)return!1;var t=h[e];return e.startsWith("data-")?(data.attrs[e]=t,!1):t||"string"==typeof t}))),n.id&&(data.domProps=data.domProps||{},data.domProps.id=n.id),e(n.tag,Object(l.a)(data,{staticClass:"container",class:Array({"container--fluid":n.fluid}).concat(r||[])}),o)}})}}]);