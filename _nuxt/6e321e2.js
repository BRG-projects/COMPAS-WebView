/*! For license information please see LICENSES */
(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{673:function(e,t,r){"use strict";r.d(t,"b",(function(){return o})),r.d(t,"a",(function(){return c}));var n=r(14);class o{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const h=new n.OrthographicCamera(-1,1,1,-1,0,1),l=new n.BufferGeometry;l.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),l.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2));class c{constructor(e){this._mesh=new n.Mesh(l,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,h)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}},674:function(e,t,r){"use strict";r.d(t,"a",(function(){return h}));var n=r(14),o=r(673);class h extends o.b{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof n.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=n.UniformsUtils.clone(e.uniforms),this.material=new n.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new o.a(this.material)}render(e,t,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}},676:function(e,t,r){"use strict";r.d(t,"a",(function(){return o}));var n=r(14);class o extends n.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new f(e)})),this.register((function(e){return new E(e)})),this.register((function(e){return new M(e)})),this.register((function(e){return new _(e)})),this.register((function(e){return new v(e)})),this.register((function(e){return new y(e)})),this.register((function(e){return new x(e)})),this.register((function(e){return new m(e)})),this.register((function(e){return new T(e)})),this.register((function(e){return new c(e)})),this.register((function(e){return new w(e)}))}load(e,t,r,o){const h=this;let l;l=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:n.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const c=function(t){o?o(t):console.error(t),h.manager.itemError(e),h.manager.itemEnd(e)},d=new n.FileLoader(this.manager);d.setPath(this.path),d.setResponseType("arraybuffer"),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(e,(function(data){try{h.parse(data,l,(function(r){t(r),h.manager.itemEnd(e)}),c)}catch(e){c(e)}}),r,c)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(data,path,e,t){let content;const r={},o={};if("string"==typeof data)content=data;else{if(n.LoaderUtils.decodeText(new Uint8Array(data,0,4))===S){try{r[l.KHR_BINARY_GLTF]=new O(data)}catch(e){return void(t&&t(e))}content=r[l.KHR_BINARY_GLTF].content}else content=n.LoaderUtils.decodeText(new Uint8Array(data))}const h=JSON.parse(content);if(void 0===h.asset||h.asset.version[0]<2)return void(t&&t(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new he(h,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let i=0;i<this.pluginCallbacks.length;i++){const e=this.pluginCallbacks[i](c);o[e.name]=e,r[e.name]=!0}if(h.extensionsUsed)for(let i=0;i<h.extensionsUsed.length;++i){const e=h.extensionsUsed[i],t=h.extensionsRequired||[];switch(e){case l.KHR_MATERIALS_UNLIT:r[e]=new d;break;case l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:r[e]=new I;break;case l.KHR_DRACO_MESH_COMPRESSION:r[e]=new C(h,this.dracoLoader);break;case l.KHR_TEXTURE_TRANSFORM:r[e]=new P;break;case l.KHR_MESH_QUANTIZATION:r[e]=new D;break;default:t.indexOf(e)>=0&&void 0===o[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}c.setExtensions(r),c.setPlugins(o),c.parse(e,t)}parseAsync(data,path){const e=this;return new Promise((function(t,r){e.parse(data,path,t,r)}))}}function h(){let e={};return{get:function(t){return e[t]},add:function(t,object){e[t]=object},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const l={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class c{constructor(e){this.parser=e,this.name=l.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let r=0,n=t.length;r<n;r++){const n=t[r];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){const t=this.parser,r="light:"+e;let o=t.cache.get(r);if(o)return o;const h=t.json,l=((h.extensions&&h.extensions[this.name]||{}).lights||[])[e];let c;const d=new n.Color(16777215);void 0!==l.color&&d.fromArray(l.color);const m=void 0!==l.range?l.range:0;switch(l.type){case"directional":c=new n.DirectionalLight(d),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new n.PointLight(d),c.distance=m;break;case"spot":c=new n.SpotLight(d),c.distance=m,l.spot=l.spot||{},l.spot.innerConeAngle=void 0!==l.spot.innerConeAngle?l.spot.innerConeAngle:0,l.spot.outerConeAngle=void 0!==l.spot.outerConeAngle?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,void 0!==l.intensity&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),o=Promise.resolve(c),t.cache.add(r,o),o}createNodeAttachment(e){const t=this,r=this.parser,n=r.json.nodes[e],o=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===o?null:this._loadLight(o).then((function(e){return r._getNodeRef(t.cache,o,e)}))}}class d{constructor(){this.name=l.KHR_MATERIALS_UNLIT}getMaterialType(){return n.MeshBasicMaterial}extendParams(e,t,r){const o=[];e.color=new n.Color(1,1,1),e.opacity=1;const h=t.pbrMetallicRoughness;if(h){if(Array.isArray(h.baseColorFactor)){const t=h.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==h.baseColorTexture&&o.push(r.assignTexture(e,"map",h.baseColorTexture,n.sRGBEncoding))}return Promise.all(o)}}class m{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name].emissiveStrength;return void 0!==n&&(t.emissiveIntensity=n),Promise.resolve()}}class f{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const h=[],l=o.extensions[this.name];if(void 0!==l.clearcoatFactor&&(t.clearcoat=l.clearcoatFactor),void 0!==l.clearcoatTexture&&h.push(r.assignTexture(t,"clearcoatMap",l.clearcoatTexture)),void 0!==l.clearcoatRoughnessFactor&&(t.clearcoatRoughness=l.clearcoatRoughnessFactor),void 0!==l.clearcoatRoughnessTexture&&h.push(r.assignTexture(t,"clearcoatRoughnessMap",l.clearcoatRoughnessTexture)),void 0!==l.clearcoatNormalTexture&&(h.push(r.assignTexture(t,"clearcoatNormalMap",l.clearcoatNormalTexture)),void 0!==l.clearcoatNormalTexture.scale)){const e=l.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new n.Vector2(e,e)}return Promise.all(h)}}class _{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const h=[];t.sheenColor=new n.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const l=o.extensions[this.name];return void 0!==l.sheenColorFactor&&t.sheenColor.fromArray(l.sheenColorFactor),void 0!==l.sheenRoughnessFactor&&(t.sheenRoughness=l.sheenRoughnessFactor),void 0!==l.sheenColorTexture&&h.push(r.assignTexture(t,"sheenColorMap",l.sheenColorTexture,n.sRGBEncoding)),void 0!==l.sheenRoughnessTexture&&h.push(r.assignTexture(t,"sheenRoughnessMap",l.sheenRoughnessTexture)),Promise.all(h)}}class v{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,n=r.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],h=n.extensions[this.name];return void 0!==h.transmissionFactor&&(t.transmission=h.transmissionFactor),void 0!==h.transmissionTexture&&o.push(r.assignTexture(t,"transmissionMap",h.transmissionTexture)),Promise.all(o)}}class y{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const h=[],l=o.extensions[this.name];t.thickness=void 0!==l.thicknessFactor?l.thicknessFactor:0,void 0!==l.thicknessTexture&&h.push(r.assignTexture(t,"thicknessMap",l.thicknessTexture)),t.attenuationDistance=l.attenuationDistance||0;const c=l.attenuationColor||[1,1,1];return t.attenuationColor=new n.Color(c[0],c[1],c[2]),Promise.all(h)}}class x{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name];return t.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class T{constructor(e){this.parser=e,this.name=l.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const h=[],l=o.extensions[this.name];t.specularIntensity=void 0!==l.specularFactor?l.specularFactor:1,void 0!==l.specularTexture&&h.push(r.assignTexture(t,"specularIntensityMap",l.specularTexture));const c=l.specularColorFactor||[1,1,1];return t.specularColor=new n.Color(c[0],c[1],c[2]),void 0!==l.specularColorTexture&&h.push(r.assignTexture(t,"specularColorMap",l.specularColorTexture,n.sRGBEncoding)),Promise.all(h)}}class E{constructor(e){this.parser=e,this.name=l.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,r=t.json,n=r.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name],h=t.options.ktx2Loader;if(!h){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,o.source,h)}}class M{constructor(e){this.parser=e,this.name=l.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,r=this.parser,n=r.json,o=n.textures[e];if(!o.extensions||!o.extensions[t])return null;const h=o.extensions[t],source=n.images[h.source];let l=r.textureLoader;if(source.uri){const e=r.options.manager.getHandler(source.uri);null!==e&&(l=e)}return this.detectSupport().then((function(o){if(o)return r.loadTextureImage(e,h.source,l);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",image.onload=image.onerror=function(){e(1===image.height)}}))),this.isSupported}}class w{constructor(e){this.name=l.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,r=t.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const e=r.extensions[this.name],n=this.parser.getDependency("buffer",e.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([n,o.ready]).then((function(t){const r=e.byteOffset||0,n=e.byteLength||0,h=e.count,l=e.byteStride,c=new ArrayBuffer(h*l),source=new Uint8Array(t[0],r,n);return o.decodeGltfBuffer(new Uint8Array(c),h,l,source,e.mode,e.filter),c}))}return null}}const S="glTF",A=1313821514,R=5130562;class O{constructor(data){this.name=l.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(data,0,12);if(this.header={magic:n.LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==S)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const t=this.header.length-12,r=new DataView(data,12);let o=0;for(;o<t;){const e=r.getUint32(o,!0);o+=4;const t=r.getUint32(o,!0);if(o+=4,t===A){const t=new Uint8Array(data,12+o,e);this.content=n.LoaderUtils.decodeText(t)}else if(t===R){const t=12+o;this.body=data.slice(t,t+e)}o+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class C{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=l.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const r=this.json,n=this.dracoLoader,o=e.extensions[this.name].bufferView,h=e.extensions[this.name].attributes,l={},c={},d={};for(const e in h){const t=Z[e]||e.toLowerCase();l[t]=h[e]}for(const t in e.attributes){const n=Z[t]||t.toLowerCase();if(void 0!==h[t]){const o=r.accessors[e.attributes[t]],h=j[o.componentType];d[n]=h,c[n]=!0===o.normalized}}return t.getDependency("bufferView",o).then((function(e){return new Promise((function(t){n.decodeDracoFile(e,(function(e){for(const t in e.attributes){const r=e.attributes[t],n=c[t];void 0!==n&&(r.normalized=n)}t(e)}),l,d)}))}))}}class P{constructor(){this.name=l.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class L extends n.MeshStandardMaterial{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),r=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),o=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),h=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),l=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),c={specular:{value:(new n.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=c,this.onBeforeCompile=function(e){for(const t in c)e.uniforms[t]=c[t];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",r).replace("#include <roughnessmap_fragment>",o).replace("#include <metalnessmap_fragment>",h).replace("#include <lights_physical_fragment>",l)},Object.defineProperties(this,{specular:{get:function(){return c.specular.value},set:function(e){c.specular.value=e}},specularMap:{get:function(){return c.specularMap.value},set:function(e){c.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return c.glossiness.value},set:function(e){c.glossiness.value=e}},glossinessMap:{get:function(){return c.glossinessMap.value},set:function(e){c.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(source){return super.copy(source),this.specularMap=source.specularMap,this.specular.copy(source.specular),this.glossinessMap=source.glossinessMap,this.glossiness=source.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class I{constructor(){this.name=l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return L}extendParams(e,t,r){const o=t.extensions[this.name];e.color=new n.Color(1,1,1),e.opacity=1;const h=[];if(Array.isArray(o.diffuseFactor)){const t=o.diffuseFactor;e.color.fromArray(t),e.opacity=t[3]}if(void 0!==o.diffuseTexture&&h.push(r.assignTexture(e,"map",o.diffuseTexture,n.sRGBEncoding)),e.emissive=new n.Color(0,0,0),e.glossiness=void 0!==o.glossinessFactor?o.glossinessFactor:1,e.specular=new n.Color(1,1,1),Array.isArray(o.specularFactor)&&e.specular.fromArray(o.specularFactor),void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;h.push(r.assignTexture(e,"glossinessMap",t)),h.push(r.assignTexture(e,"specularMap",t,n.sRGBEncoding))}return Promise.all(h)}createMaterial(e){const t=new L(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=void 0===e.emissiveIntensity?1:e.emissiveIntensity,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=n.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t}}class D{constructor(){this.name=l.KHR_MESH_QUANTIZATION}}class U extends n.Interpolant{constructor(e,t,r,n){super(e,t,r,n)}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,n=this.valueSize,o=e*n*3+n;for(let i=0;i!==n;i++)t[i]=r[o+i];return t}}U.prototype.beforeStart_=U.prototype.copySampleValue_,U.prototype.afterEnd_=U.prototype.copySampleValue_,U.prototype.interpolate_=function(e,t,r,n){const o=this.resultBuffer,h=this.sampleValues,l=this.valueSize,c=2*l,d=3*l,td=n-t,p=(r-t)/td,m=p*p,f=m*p,_=e*d,v=_-d,y=-2*f+3*m,x=f-m,T=1-y,E=x-m+p;for(let i=0;i!==l;i++){const e=h[v+i+l],t=h[v+i+c]*td,r=h[_+i+l],n=h[_+i]*td;o[i]=T*e+E*t+y*r+x*n}return o};const F=new n.Quaternion;class B extends U{interpolate_(e,t,r,n){const o=super.interpolate_(e,t,r,n);return F.fromArray(o).normalize().toArray(o),o}}const N=0,k=1,z=2,H=3,V=4,G=5,Q=6,j={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},X={9728:n.NearestFilter,9729:n.LinearFilter,9984:n.NearestMipmapNearestFilter,9985:n.LinearMipmapNearestFilter,9986:n.NearestMipmapLinearFilter,9987:n.LinearMipmapLinearFilter},Y={33071:n.ClampToEdgeWrapping,33648:n.MirroredRepeatWrapping,10497:n.RepeatWrapping},K={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Z={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},W={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},J={CUBICSPLINE:void 0,LINEAR:n.InterpolateLinear,STEP:n.InterpolateDiscrete},$="OPAQUE",ee="MASK",te="BLEND";function se(e,object,t){for(const r in t.extensions)void 0===e[r]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[r]=t.extensions[r])}function ie(object,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(object.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function re(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,r=t.weights.length;i<r;i++)e.morphTargetInfluences[i]=t.weights[i];if(t.extras&&Array.isArray(t.extras.targetNames)){const r=t.extras.targetNames;if(e.morphTargetInfluences.length===r.length){e.morphTargetDictionary={};for(let i=0,t=r.length;i<t;i++)e.morphTargetDictionary[r[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ne(e){const t=e.extensions&&e.extensions[l.KHR_DRACO_MESH_COMPRESSION];let r;return r=t?"draco:"+t.bufferView+":"+t.indices+":"+ae(t.attributes):e.indices+":"+ae(e.attributes)+":"+e.mode,r}function ae(e){let t="";const r=Object.keys(e).sort();for(let i=0,n=r.length;i<n;i++)t+=r[i]+":"+e[r[i]]+";";return t}function oe(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class he{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new h,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const r=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),o=navigator.userAgent.indexOf("Firefox")>-1,l=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||r||o&&l<98?this.textureLoader=new n.TextureLoader(this.options.manager):this.textureLoader=new n.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new n.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const r=this,n=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])})).then((function(t){const h={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:r,userData:{}};se(o,h,n),ie(h,n),Promise.all(r._invokeAll((function(e){return e.afterRoot&&e.afterRoot(h)}))).then((function(){e(h)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],r=this.json.meshes||[];for(let r=0,n=t.length;r<n;r++){const n=t[r].joints;for(let i=0,t=n.length;i<t;i++)e[n[i]].isBone=!0}for(let t=0,n=e.length;t<n;t++){const n=e[t];void 0!==n.mesh&&(this._addNodeRef(this.meshCache,n.mesh),void 0!==n.skin&&(r[n.mesh].isSkinnedMesh=!0)),void 0!==n.camera&&this._addNodeRef(this.cameraCache,n.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,object){if(e.refs[t]<=1)return object;const r=object.clone(),n=(e,t)=>{const r=this.associations.get(e);null!=r&&this.associations.set(t,r);for(const[i,r]of e.children.entries())n(r,t.children[i])};return n(object,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const r=[];for(let i=0;i<t.length;i++){const n=e(t[i]);n&&r.push(n)}return r}getDependency(e,t){const r=e+":"+t;let n=this.cache.get(r);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this.loadNode(t);break;case"mesh":n=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":n=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":n=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(r,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const r=this,defs=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(defs.map((function(t,n){return r.getDependency(e,n)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],r=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[l.KHR_BINARY_GLTF].body);const o=this.options;return new Promise((function(e,h){r.load(n.LoaderUtils.resolveURL(t.uri,o.path),e,void 0,(function(){h(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const r=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+r)}))}loadAccessor(e){const t=this,r=this.json,o=this.json.accessors[e];if(void 0===o.bufferView&&void 0===o.sparse)return Promise.resolve(null);const h=[];return void 0!==o.bufferView?h.push(this.getDependency("bufferView",o.bufferView)):h.push(null),void 0!==o.sparse&&(h.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),h.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(h).then((function(e){const h=e[0],l=K[o.type],c=j[o.componentType],d=c.BYTES_PER_ELEMENT,m=d*l,f=o.byteOffset||0,_=void 0!==o.bufferView?r.bufferViews[o.bufferView].byteStride:void 0,v=!0===o.normalized;let y,x;if(_&&_!==m){const e=Math.floor(f/_),r="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+e+":"+o.count;let m=t.cache.get(r);m||(y=new c(h,e*_,o.count*_/d),m=new n.InterleavedBuffer(y,_/d),t.cache.add(r,m)),x=new n.InterleavedBufferAttribute(m,l,f%_/d,v)}else y=null===h?new c(o.count*l):new c(h,f,o.count*l),x=new n.BufferAttribute(y,l,v);if(void 0!==o.sparse){const t=K.SCALAR,r=j[o.sparse.indices.componentType],d=o.sparse.indices.byteOffset||0,m=o.sparse.values.byteOffset||0,f=new r(e[1],d,o.sparse.count*t),_=new c(e[2],m,o.sparse.count*l);null!==h&&(x=new n.BufferAttribute(x.array.slice(),x.itemSize,x.normalized));for(let i=0,e=f.length;i<e;i++){const e=f[i];if(x.setX(e,_[i*l]),l>=2&&x.setY(e,_[i*l+1]),l>=3&&x.setZ(e,_[i*l+2]),l>=4&&x.setW(e,_[i*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return x}))}loadTexture(e){const t=this.json,r=this.options,n=t.textures[e].source,o=t.images[n];let h=this.textureLoader;if(o.uri){const e=r.manager.getHandler(o.uri);null!==e&&(h=e)}return this.loadTextureImage(e,n,h)}loadTextureImage(e,t,r){const o=this,h=this.json,l=h.textures[e],c=h.images[t],d=(c.uri||c.bufferView)+":"+l.sampler;if(this.textureCache[d])return this.textureCache[d];const m=this.loadImageSource(t,r).then((function(t){t.flipY=!1,l.name&&(t.name=l.name);const r=(h.samplers||{})[l.sampler]||{};return t.magFilter=X[r.magFilter]||n.LinearFilter,t.minFilter=X[r.minFilter]||n.LinearMipmapLinearFilter,t.wrapS=Y[r.wrapS]||n.RepeatWrapping,t.wrapT=Y[r.wrapT]||n.RepeatWrapping,o.associations.set(t,{textures:e}),t})).catch((function(){return null}));return this.textureCache[d]=m,m}loadImageSource(e,t){const r=this,o=this.json,h=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then((e=>e.clone()));const l=o.images[e],c=self.URL||self.webkitURL;let d=l.uri||"",m=!1;if(void 0!==l.bufferView)d=r.getDependency("bufferView",l.bufferView).then((function(e){m=!0;const t=new Blob([e],{type:l.mimeType});return d=c.createObjectURL(t),d}));else if(void 0===l.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const f=Promise.resolve(d).then((function(e){return new Promise((function(r,o){let l=r;!0===t.isImageBitmapLoader&&(l=function(e){const t=new n.Texture(e);t.needsUpdate=!0,r(t)}),t.load(n.LoaderUtils.resolveURL(e,h.path),l,void 0,o)}))})).then((function(e){var t;return!0===m&&c.revokeObjectURL(d),e.userData.mimeType=l.mimeType||((t=l.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":"image/png"),e})).catch((function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",d),e}));return this.sourceCache[e]=f,f}assignTexture(e,t,r,n){const o=this;return this.getDependency("texture",r.index).then((function(h){if(void 0===r.texCoord||0==r.texCoord||"aoMap"===t&&1==r.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+t+" not yet supported."),o.extensions[l.KHR_TEXTURE_TRANSFORM]){const e=void 0!==r.extensions?r.extensions[l.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=o.associations.get(h);h=o.extensions[l.KHR_TEXTURE_TRANSFORM].extendTexture(h,e),o.associations.set(h,t)}}return void 0!==n&&(h.encoding=n),e[t]=h,h}))}assignFinalMaterial(e){const t=e.geometry;let r=e.material;const o=void 0===t.attributes.tangent,h=void 0!==t.attributes.color,l=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+r.uuid;let t=this.cache.get(e);t||(t=new n.PointsMaterial,n.Material.prototype.copy.call(t,r),t.color.copy(r.color),t.map=r.map,t.sizeAttenuation=!1,this.cache.add(e,t)),r=t}else if(e.isLine){const e="LineBasicMaterial:"+r.uuid;let t=this.cache.get(e);t||(t=new n.LineBasicMaterial,n.Material.prototype.copy.call(t,r),t.color.copy(r.color),this.cache.add(e,t)),r=t}if(o||h||l){let e="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),o&&(e+="derivative-tangents:"),h&&(e+="vertex-colors:"),l&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=r.clone(),h&&(t.vertexColors=!0),l&&(t.flatShading=!0),o&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(r))),r=t}r.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=r}getMaterialType(){return n.MeshStandardMaterial}loadMaterial(e){const t=this,r=this.json,o=this.extensions,h=r.materials[e];let c;const d={},m=h.extensions||{},f=[];if(m[l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const e=o[l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];c=e.getMaterialType(),f.push(e.extendParams(d,h,t))}else if(m[l.KHR_MATERIALS_UNLIT]){const e=o[l.KHR_MATERIALS_UNLIT];c=e.getMaterialType(),f.push(e.extendParams(d,h,t))}else{const r=h.pbrMetallicRoughness||{};if(d.color=new n.Color(1,1,1),d.opacity=1,Array.isArray(r.baseColorFactor)){const e=r.baseColorFactor;d.color.fromArray(e),d.opacity=e[3]}void 0!==r.baseColorTexture&&f.push(t.assignTexture(d,"map",r.baseColorTexture,n.sRGBEncoding)),d.metalness=void 0!==r.metallicFactor?r.metallicFactor:1,d.roughness=void 0!==r.roughnessFactor?r.roughnessFactor:1,void 0!==r.metallicRoughnessTexture&&(f.push(t.assignTexture(d,"metalnessMap",r.metallicRoughnessTexture)),f.push(t.assignTexture(d,"roughnessMap",r.metallicRoughnessTexture))),c=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),f.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,d)}))))}!0===h.doubleSided&&(d.side=n.DoubleSide);const _=h.alphaMode||$;if(_===te?(d.transparent=!0,d.depthWrite=!1):(d.transparent=!1,_===ee&&(d.alphaTest=void 0!==h.alphaCutoff?h.alphaCutoff:.5)),void 0!==h.normalTexture&&c!==n.MeshBasicMaterial&&(f.push(t.assignTexture(d,"normalMap",h.normalTexture)),d.normalScale=new n.Vector2(1,1),void 0!==h.normalTexture.scale)){const e=h.normalTexture.scale;d.normalScale.set(e,e)}return void 0!==h.occlusionTexture&&c!==n.MeshBasicMaterial&&(f.push(t.assignTexture(d,"aoMap",h.occlusionTexture)),void 0!==h.occlusionTexture.strength&&(d.aoMapIntensity=h.occlusionTexture.strength)),void 0!==h.emissiveFactor&&c!==n.MeshBasicMaterial&&(d.emissive=(new n.Color).fromArray(h.emissiveFactor)),void 0!==h.emissiveTexture&&c!==n.MeshBasicMaterial&&f.push(t.assignTexture(d,"emissiveMap",h.emissiveTexture,n.sRGBEncoding)),Promise.all(f).then((function(){let r;return r=c===L?o[l.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(d):new c(d),h.name&&(r.name=h.name),ie(r,h),t.associations.set(r,{materials:e}),h.extensions&&se(o,r,h),r}))}createUniqueName(e){const t=n.PropertyBinding.sanitizeNodeName(e||"");let r=t;for(let i=1;this.nodeNamesUsed[r];++i)r=t+"_"+i;return this.nodeNamesUsed[r]=!0,r}loadGeometries(e){const t=this,r=this.extensions,o=this.primitiveCache;function h(e){return r[l.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(r){return ce(r,e,t)}))}const c=[];for(let i=0,r=e.length;i<r;i++){const r=e[i],d=ne(r),m=o[d];if(m)c.push(m.promise);else{let e;e=r.extensions&&r.extensions[l.KHR_DRACO_MESH_COMPRESSION]?h(r):ce(new n.BufferGeometry,r,t),o[d]={primitive:r,promise:e},c.push(e)}}return Promise.all(c)}loadMesh(e){const t=this,r=this.json,o=this.extensions,h=r.meshes[e],l=h.primitives,c=[];for(let i=0,e=l.length;i<e;i++){const e=void 0===l[i].material?(void 0===(d=this.cache).DefaultMaterial&&(d.DefaultMaterial=new n.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:n.FrontSide})),d.DefaultMaterial):this.getDependency("material",l[i].material);c.push(e)}var d;return c.push(t.loadGeometries(l)),Promise.all(c).then((function(r){const c=r.slice(0,r.length-1),d=r[r.length-1],m=[];for(let i=0,r=d.length;i<r;i++){const r=d[i],f=l[i];let _;const v=c[i];if(f.mode===V||f.mode===G||f.mode===Q||void 0===f.mode)_=!0===h.isSkinnedMesh?new n.SkinnedMesh(r,v):new n.Mesh(r,v),!0!==_.isSkinnedMesh||_.geometry.attributes.skinWeight.normalized||_.normalizeSkinWeights(),f.mode===G?_.geometry=de(_.geometry,n.TriangleStripDrawMode):f.mode===Q&&(_.geometry=de(_.geometry,n.TriangleFanDrawMode));else if(f.mode===k)_=new n.LineSegments(r,v);else if(f.mode===H)_=new n.Line(r,v);else if(f.mode===z)_=new n.LineLoop(r,v);else{if(f.mode!==N)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+f.mode);_=new n.Points(r,v)}Object.keys(_.geometry.morphAttributes).length>0&&re(_,h),_.name=t.createUniqueName(h.name||"mesh_"+e),ie(_,h),f.extensions&&se(o,_,f),t.assignFinalMaterial(_),m.push(_)}for(let i=0,r=m.length;i<r;i++)t.associations.set(m[i],{meshes:e,primitives:i});if(1===m.length)return m[0];const f=new n.Group;t.associations.set(f,{meshes:e});for(let i=0,e=m.length;i<e;i++)f.add(m[i]);return f}))}loadCamera(e){let t;const r=this.json.cameras[e],o=r[r.type];if(o)return"perspective"===r.type?t=new n.PerspectiveCamera(n.MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):"orthographic"===r.type&&(t=new n.OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),r.name&&(t.name=this.createUniqueName(r.name)),ie(t,r),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],r={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(r):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return r.inverseBindMatrices=e,r}))}loadAnimation(e){const t=this.json.animations[e],r=[],o=[],h=[],l=[],c=[];for(let i=0,e=t.channels.length;i<e;i++){const e=t.channels[i],n=t.samplers[e.sampler],d=e.target,m=void 0!==d.node?d.node:d.id,input=void 0!==t.parameters?t.parameters[n.input]:n.input,output=void 0!==t.parameters?t.parameters[n.output]:n.output;r.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",input)),h.push(this.getDependency("accessor",output)),l.push(n),c.push(d)}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(h),Promise.all(l),Promise.all(c)]).then((function(r){const o=r[0],h=r[1],l=r[2],c=r[3],d=r[4],m=[];for(let i=0,e=o.length;i<e;i++){const e=o[i],t=h[i],r=l[i],f=c[i],_=d[i];if(void 0===e)continue;let v;switch(e.updateMatrix(),e.matrixAutoUpdate=!0,W[_.path]){case W.weights:v=n.NumberKeyframeTrack;break;case W.rotation:v=n.QuaternionKeyframeTrack;break;default:v=n.VectorKeyframeTrack}const y=e.name?e.name:e.uuid,x=void 0!==f.interpolation?J[f.interpolation]:n.InterpolateLinear,T=[];W[_.path]===W.weights?e.traverse((function(object){object.morphTargetInfluences&&T.push(object.name?object.name:object.uuid)})):T.push(y);let E=r.array;if(r.normalized){const e=oe(E.constructor),t=new Float32Array(E.length);for(let r=0,n=E.length;r<n;r++)t[r]=E[r]*e;E=t}for(let e=0,r=T.length;e<r;e++){const track=new v(T[e]+"."+W[_.path],t.array,E,x);"CUBICSPLINE"===f.interpolation&&(track.createInterpolant=function(e){return new(this instanceof n.QuaternionKeyframeTrack?B:U)(this.times,this.values,this.getValueSize()/3,e)},track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(track)}}const f=t.name?t.name:"animation_"+e;return new n.AnimationClip(f,void 0,m)}))}createNodeMesh(e){const t=this.json,r=this,n=t.nodes[e];return void 0===n.mesh?null:r.getDependency("mesh",n.mesh).then((function(e){const t=r._getNodeRef(r.meshCache,n.mesh,e);return void 0!==n.weights&&t.traverse((function(e){if(e.isMesh)for(let i=0,t=n.weights.length;i<t;i++)e.morphTargetInfluences[i]=n.weights[i]})),t}))}loadNode(e){const t=this.json,r=this.extensions,o=this,h=t.nodes[e],l=h.name?o.createUniqueName(h.name):"";return function(){const t=[],r=o._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return r&&t.push(r),void 0!==h.camera&&t.push(o.getDependency("camera",h.camera).then((function(e){return o._getNodeRef(o.cameraCache,h.camera,e)}))),o._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){t.push(e)})),Promise.all(t)}().then((function(t){let c;if(c=!0===h.isBone?new n.Bone:t.length>1?new n.Group:1===t.length?t[0]:new n.Object3D,c!==t[0])for(let i=0,e=t.length;i<e;i++)c.add(t[i]);if(h.name&&(c.userData.name=h.name,c.name=l),ie(c,h),h.extensions&&se(r,c,h),void 0!==h.matrix){const e=new n.Matrix4;e.fromArray(h.matrix),c.applyMatrix4(e)}else void 0!==h.translation&&c.position.fromArray(h.translation),void 0!==h.rotation&&c.quaternion.fromArray(h.rotation),void 0!==h.scale&&c.scale.fromArray(h.scale);return o.associations.has(c)||o.associations.set(c,{}),o.associations.get(c).nodes=e,c}))}loadScene(e){const t=this.json,r=this.extensions,o=this.json.scenes[e],h=this,l=new n.Group;o.name&&(l.name=h.createUniqueName(o.name)),ie(l,o),o.extensions&&se(r,l,o);const c=o.nodes||[],d=[];for(let i=0,e=c.length;i<e;i++)d.push(le(c[i],l,t,h));return Promise.all(d).then((function(){return h.associations=(e=>{const t=new Map;for(const[e,r]of h.associations)(e instanceof n.Material||e instanceof n.Texture)&&t.set(e,r);return e.traverse((e=>{const r=h.associations.get(e);null!=r&&t.set(e,r)})),t})(l),l}))}}function le(e,t,r,o){const h=r.nodes[e];return o.getDependency("node",e).then((function(e){if(void 0===h.skin)return e;let t;return o.getDependency("skin",h.skin).then((function(e){t=e;const r=[];for(let i=0,e=t.joints.length;i<e;i++)r.push(o.getDependency("node",t.joints[i]));return Promise.all(r)})).then((function(r){return e.traverse((function(e){if(!e.isMesh)return;const o=[],h=[];for(let e=0,l=r.length;e<l;e++){const l=r[e];if(l){o.push(l);const r=new n.Matrix4;void 0!==t.inverseBindMatrices&&r.fromArray(t.inverseBindMatrices.array,16*e),h.push(r)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}e.bind(new n.Skeleton(o,h),e.matrixWorld)})),e}))})).then((function(e){t.add(e);const n=[];if(h.children){const t=h.children;for(let i=0,h=t.length;i<h;i++){const h=t[i];n.push(le(h,e,r,o))}}return Promise.all(n)}))}function ce(e,t,r){const o=t.attributes,h=[];function l(t,n){return r.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(const t in o){const r=Z[t]||t.toLowerCase();r in e.attributes||h.push(l(o[t],r))}if(void 0!==t.indices&&!e.index){const n=r.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));h.push(n)}return ie(e,t),function(e,t,r){const o=t.attributes,h=new n.Box3;if(void 0===o.POSITION)return;{const e=r.json.accessors[o.POSITION],t=e.min,l=e.max;if(void 0===t||void 0===l)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(h.set(new n.Vector3(t[0],t[1],t[2]),new n.Vector3(l[0],l[1],l[2])),e.normalized){const t=oe(j[e.componentType]);h.min.multiplyScalar(t),h.max.multiplyScalar(t)}}const l=t.targets;if(void 0!==l){const e=new n.Vector3,t=new n.Vector3;for(let i=0,n=l.length;i<n;i++){const n=l[i];if(void 0!==n.POSITION){const o=r.json.accessors[n.POSITION],h=o.min,l=o.max;if(void 0!==h&&void 0!==l){if(t.setX(Math.max(Math.abs(h[0]),Math.abs(l[0]))),t.setY(Math.max(Math.abs(h[1]),Math.abs(l[1]))),t.setZ(Math.max(Math.abs(h[2]),Math.abs(l[2]))),o.normalized){const e=oe(j[o.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}h.expandByVector(e)}e.boundingBox=h;const c=new n.Sphere;h.getCenter(c.center),c.radius=h.min.distanceTo(h.max)/2,e.boundingSphere=c}(e,t,r),Promise.all(h).then((function(){return void 0!==t.targets?function(e,t,r){let n=!1,o=!1,h=!1;for(let i=0,e=t.length;i<e;i++){const e=t[i];if(void 0!==e.POSITION&&(n=!0),void 0!==e.NORMAL&&(o=!0),void 0!==e.COLOR_0&&(h=!0),n&&o&&h)break}if(!n&&!o&&!h)return Promise.resolve(e);const l=[],c=[],d=[];for(let i=0,m=t.length;i<m;i++){const m=t[i];if(n){const t=void 0!==m.POSITION?r.getDependency("accessor",m.POSITION):e.attributes.position;l.push(t)}if(o){const t=void 0!==m.NORMAL?r.getDependency("accessor",m.NORMAL):e.attributes.normal;c.push(t)}if(h){const t=void 0!==m.COLOR_0?r.getDependency("accessor",m.COLOR_0):e.attributes.color;d.push(t)}}return Promise.all([Promise.all(l),Promise.all(c),Promise.all(d)]).then((function(t){const r=t[0],l=t[1],c=t[2];return n&&(e.morphAttributes.position=r),o&&(e.morphAttributes.normal=l),h&&(e.morphAttributes.color=c),e.morphTargetsRelative=!0,e}))}(e,t.targets,r):e}))}function de(e,t){let r=e.getIndex();if(null===r){const t=[],n=e.getAttribute("position");if(void 0===n)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let i=0;i<n.count;i++)t.push(i);e.setIndex(t),r=e.getIndex()}const o=r.count-2,h=[];if(t===n.TriangleFanDrawMode)for(let i=1;i<=o;i++)h.push(r.getX(0)),h.push(r.getX(i)),h.push(r.getX(i+1));else for(let i=0;i<o;i++)i%2==0?(h.push(r.getX(i)),h.push(r.getX(i+1)),h.push(r.getX(i+2))):(h.push(r.getX(i+2)),h.push(r.getX(i+1)),h.push(r.getX(i)));h.length/3!==o&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const l=e.clone();return l.setIndex(h),l}},677:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"}},678:function(e,t,r){"use strict";r.d(t,"a",(function(){return h}));var n=r(14),o=r(673);class h extends o.b{constructor(e,t,r,o,h){super(),this.scene=e,this.camera=t,this.overrideMaterial=r,this.clearColor=o,this.clearAlpha=void 0!==h?h:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new n.Color}render(e,t,r){const n=e.autoClear;let o,h;e.autoClear=!1,void 0!==this.overrideMaterial&&(h=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),o=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:r),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,o),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=h),e.autoClear=n}}},679:function(e,t,r){"use strict";r.d(t,"a",(function(){return l}));var n=r(14),o=r(673),h=r(677);class l extends o.b{constructor(e,t,r,l){super(),this.renderScene=t,this.renderCamera=r,this.selectedObjects=void 0!==l?l:[],this.visibleEdgeColor=new n.Color(1,1,1),this.hiddenEdgeColor=new n.Color(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=void 0!==e?new n.Vector2(e.x,e.y):new n.Vector2(256,256);const c=Math.round(this.resolution.x/this.downSampleRatio),d=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new n.MeshDepthMaterial,this.depthMaterial.side=n.DoubleSide,this.depthMaterial.depthPacking=n.RGBADepthPacking,this.depthMaterial.blending=n.NoBlending,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=n.DoubleSide,this.prepareMaskMaterial.fragmentShader=function(e,t){const r=t.isPerspectiveCamera?"perspective":"orthographic";return e.replace(/DEPTH_TO_VIEW_Z/g,r+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new n.WebGLRenderTarget(c,d),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new n.WebGLRenderTarget(c,d),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new n.WebGLRenderTarget(Math.round(c/2),Math.round(d/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new n.WebGLRenderTarget(c,d),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new n.WebGLRenderTarget(Math.round(c/2),Math.round(d/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(c,d),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(c/2),Math.round(d/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===h.a&&console.error("THREE.OutlinePass relies on CopyShader");const m=h.a;this.copyUniforms=n.UniformsUtils.clone(m.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new n.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,blending:n.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new n.Color,this.oldClearAlpha=1,this.fsQuad=new o.a(null),this.tempPulseColor1=new n.Color,this.tempPulseColor2=new n.Color,this.textureMatrix=new n.Matrix4}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t),this.renderTargetDepthBuffer.setSize(e,t);let r=Math.round(e/this.downSampleRatio),n=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(r,n),this.renderTargetBlurBuffer1.setSize(r,n),this.renderTargetEdgeBuffer1.setSize(r,n),this.separableBlurMaterial1.uniforms.texSize.value.set(r,n),r=Math.round(r/2),n=Math.round(n/2),this.renderTargetBlurBuffer2.setSize(r,n),this.renderTargetEdgeBuffer2.setSize(r,n),this.separableBlurMaterial2.uniforms.texSize.value.set(r,n)}changeVisibilityOfSelectedObjects(e){const t=this._visibilityCache;function r(object){object.isMesh&&(!0===e?object.visible=t.get(object):(t.set(object,object.visible),object.visible=e))}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(r)}}changeVisibilityOfNonSelectedObjects(e){const t=this._visibilityCache,r=[];function n(object){object.isMesh&&r.push(object)}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(n)}this.renderScene.traverse((function(object){if(object.isMesh||object.isSprite){let n=!1;for(let i=0;i<r.length;i++){if(r[i].id===object.id){n=!0;break}}if(!1===n){const r=object.visible;!1!==e&&!0!==t.get(object)||(object.visible=e),t.set(object,r)}}else(object.isPoints||object.isLine)&&(!0===e?object.visible=t.get(object):(t.set(object,object.visible),object.visible=e))}))}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(e,t,r,n,o){if(this.selectedObjects.length>0){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const t=e.autoClear;e.autoClear=!1,o&&e.state.buffers.stencil.setTest(!1),e.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const n=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=n,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const e=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(e),this.tempPulseColor2.multiplyScalar(e)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=l.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=l.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=l.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=l.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,o&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(r),this.fsQuad.render(e),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=t}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=r.texture,e.setRenderTarget(null),this.fsQuad.render(e))}getPrepareMaskMaterial(){return new n.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new n.Vector2(.5,.5)},textureMatrix:{value:null}},vertexShader:"#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",fragmentShader:"#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}"})}getEdgeDetectionMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},visibleEdgeColor:{value:new n.Vector3(1,1,1)},hiddenEdgeColor:{value:new n.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}"})}getSeperableBlurMaterial(e){return new n.ShaderMaterial({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},direction:{value:new n.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}"})}getOverlayMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",blending:n.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}}l.BlurDirectionX=new n.Vector2(1,0),l.BlurDirectionY=new n.Vector2(0,1)},680:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},resolution:{value:new(r(14).Vector2)(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t"}},681:function(e,t,r){"use strict";r.d(t,"a",(function(){return y}));var n=r(14);const o=new n.Raycaster,h=new n.Vector3,l=new n.Vector3,c=new n.Quaternion,d={X:new n.Vector3(1,0,0),Y:new n.Vector3(0,1,0),Z:new n.Vector3(0,0,1)},m={type:"change"},f={type:"mouseDown"},_={type:"mouseUp",mode:null},v={type:"objectChange"};class y extends n.Object3D{constructor(e,t){super(),void 0===t&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.visible=!1,this.domElement=t,this.domElement.style.touchAction="none";const r=new H;this._gizmo=r,this.add(r);const o=new V;this._plane=o,this.add(o);const h=this;function l(e,t){let n=t;Object.defineProperty(h,e,{get:function(){return void 0!==n?n:t},set:function(t){n!==t&&(n=t,o[e]=t,r[e]=t,h.dispatchEvent({type:e+"-changed",value:t}),h.dispatchEvent(m))}}),h[e]=t,o[e]=t,r[e]=t}l("camera",e),l("object",void 0),l("enabled",!0),l("axis",null),l("mode","translate"),l("translationSnap",null),l("rotationSnap",null),l("scaleSnap",null),l("space","world"),l("size",1),l("dragging",!1),l("showX",!0),l("showY",!0),l("showZ",!0);const c=new n.Vector3,d=new n.Vector3,f=new n.Quaternion,_=new n.Quaternion,v=new n.Vector3,y=new n.Quaternion,S=new n.Vector3,A=new n.Vector3,R=new n.Vector3,O=new n.Vector3;l("worldPosition",c),l("worldPositionStart",d),l("worldQuaternion",f),l("worldQuaternionStart",_),l("cameraPosition",v),l("cameraQuaternion",y),l("pointStart",S),l("pointEnd",A),l("rotationAxis",R),l("rotationAngle",0),l("eye",O),this._offset=new n.Vector3,this._startNorm=new n.Vector3,this._endNorm=new n.Vector3,this._cameraScale=new n.Vector3,this._parentPosition=new n.Vector3,this._parentQuaternion=new n.Quaternion,this._parentQuaternionInv=new n.Quaternion,this._parentScale=new n.Vector3,this._worldScaleStart=new n.Vector3,this._worldQuaternionInv=new n.Quaternion,this._worldScale=new n.Vector3,this._positionStart=new n.Vector3,this._quaternionStart=new n.Quaternion,this._scaleStart=new n.Vector3,this._getPointer=x.bind(this),this._onPointerDown=E.bind(this),this._onPointerHover=T.bind(this),this._onPointerMove=M.bind(this),this._onPointerUp=w.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(e){if(void 0===this.object||!0===this.dragging)return;o.setFromCamera(e,this.camera);const t=S(this._gizmo.picker[this.mode],o);this.axis=t?t.object.name:null}pointerDown(e){if(void 0!==this.object&&!0!==this.dragging&&0===e.button&&null!==this.axis){o.setFromCamera(e,this.camera);const t=S(this._plane,o,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,f.mode=this.mode,this.dispatchEvent(f)}}pointerMove(e){const t=this.axis,r=this.mode,object=this.object;let n=this.space;if("scale"===r?n="local":"E"!==t&&"XYZE"!==t&&"XYZ"!==t||(n="world"),void 0===object||null===t||!1===this.dragging||-1!==e.button)return;o.setFromCamera(e,this.camera);const f=S(this._plane,o,!0);if(f){if(this.pointEnd.copy(f.point).sub(this.worldPositionStart),"translate"===r)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===n&&"XYZ"!==t&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===t.indexOf("X")&&(this._offset.x=0),-1===t.indexOf("Y")&&(this._offset.y=0),-1===t.indexOf("Z")&&(this._offset.z=0),"local"===n&&"XYZ"!==t?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),object.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===n&&(object.position.applyQuaternion(c.copy(this._quaternionStart).invert()),-1!==t.search("X")&&(object.position.x=Math.round(object.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(object.position.y=Math.round(object.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(object.position.z=Math.round(object.position.z/this.translationSnap)*this.translationSnap),object.position.applyQuaternion(this._quaternionStart)),"world"===n&&(object.parent&&object.position.add(h.setFromMatrixPosition(object.parent.matrixWorld)),-1!==t.search("X")&&(object.position.x=Math.round(object.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(object.position.y=Math.round(object.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(object.position.z=Math.round(object.position.z/this.translationSnap)*this.translationSnap),object.parent&&object.position.sub(h.setFromMatrixPosition(object.parent.matrixWorld))));else if("scale"===r){if(-1!==t.search("XYZ")){let e=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(e*=-1),l.set(e,e,e)}else h.copy(this.pointStart),l.copy(this.pointEnd),h.applyQuaternion(this._worldQuaternionInv),l.applyQuaternion(this._worldQuaternionInv),l.divide(h),-1===t.search("X")&&(l.x=1),-1===t.search("Y")&&(l.y=1),-1===t.search("Z")&&(l.z=1);object.scale.copy(this._scaleStart).multiply(l),this.scaleSnap&&(-1!==t.search("X")&&(object.scale.x=Math.round(object.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Y")&&(object.scale.y=Math.round(object.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Z")&&(object.scale.z=Math.round(object.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===r){this._offset.copy(this.pointEnd).sub(this.pointStart);const e=20/this.worldPosition.distanceTo(h.setFromMatrixPosition(this.camera.matrixWorld));"E"===t?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):"XYZE"===t?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(h.copy(this.rotationAxis).cross(this.eye))*e):"X"!==t&&"Y"!==t&&"Z"!==t||(this.rotationAxis.copy(d[t]),h.copy(d[t]),"local"===n&&h.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(h.cross(this.eye).normalize())*e),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===n&&"E"!==t&&"XYZE"!==t?(object.quaternion.copy(this._quaternionStart),object.quaternion.multiply(c.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),object.quaternion.copy(c.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),object.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(m),this.dispatchEvent(v)}}pointerUp(e){0===e.button&&(this.dragging&&null!==this.axis&&(_.mode=this.mode,this.dispatchEvent(_)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))}attach(object){return this.object=object,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(m),this.dispatchEvent(v),this.pointStart.copy(this.pointEnd))}getRaycaster(){return o}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function x(e){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:e.button};{const rect=this.domElement.getBoundingClientRect();return{x:(e.clientX-rect.left)/rect.width*2-1,y:-(e.clientY-rect.top)/rect.height*2+1,button:e.button}}}function T(e){if(this.enabled)switch(e.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(e))}}function E(e){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(e.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(e)),this.pointerDown(this._getPointer(e)))}function M(e){this.enabled&&this.pointerMove(this._getPointer(e))}function w(e){this.enabled&&(this.domElement.releasePointerCapture(e.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(e)))}function S(object,e,t){const r=e.intersectObject(object,!0);for(let i=0;i<r.length;i++)if(r[i].object.visible||t)return r[i];return!1}y.prototype.isTransformControls=!0;const A=new n.Euler,R=new n.Vector3(0,1,0),O=new n.Vector3(0,0,0),C=new n.Matrix4,P=new n.Quaternion,L=new n.Quaternion,I=new n.Vector3,D=new n.Matrix4,U=new n.Vector3(1,0,0),F=new n.Vector3(0,1,0),B=new n.Vector3(0,0,1),N=new n.Vector3,k=new n.Vector3,z=new n.Vector3;class H extends n.Object3D{constructor(){super(),this.type="TransformControlsGizmo";const e=new n.MeshBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new n.LineBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),r=e.clone();r.opacity=.15;const o=t.clone();o.opacity=.5;const h=e.clone();h.color.setHex(16711680);const l=e.clone();l.color.setHex(65280);const c=e.clone();c.color.setHex(255);const d=e.clone();d.color.setHex(16711680),d.opacity=.5;const m=e.clone();m.color.setHex(65280),m.opacity=.5;const f=e.clone();f.color.setHex(255),f.opacity=.5;const _=e.clone();_.opacity=.25;const v=e.clone();v.color.setHex(16776960),v.opacity=.25;e.clone().color.setHex(16776960);const y=e.clone();y.color.setHex(7895160);const x=new n.CylinderGeometry(0,.04,.1,12);x.translate(0,.05,0);const T=new n.BoxGeometry(.08,.08,.08);T.translate(0,.04,0);const E=new n.BufferGeometry;E.setAttribute("position",new n.Float32BufferAttribute([0,0,0,1,0,0],3));const M=new n.CylinderGeometry(.0075,.0075,.5,3);function w(e,t){const r=new n.TorusGeometry(e,.0075,3,64,t*Math.PI*2);return r.rotateY(Math.PI/2),r.rotateX(Math.PI/2),r}M.translate(0,.25,0);const S={X:[[new n.Mesh(x,h),[.5,0,0],[0,0,-Math.PI/2]],[new n.Mesh(x,h),[-.5,0,0],[0,0,Math.PI/2]],[new n.Mesh(M,h),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new n.Mesh(x,l),[0,.5,0]],[new n.Mesh(x,l),[0,-.5,0],[Math.PI,0,0]],[new n.Mesh(M,l)]],Z:[[new n.Mesh(x,c),[0,0,.5],[Math.PI/2,0,0]],[new n.Mesh(x,c),[0,0,-.5],[-Math.PI/2,0,0]],[new n.Mesh(M,c),null,[Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.OctahedronGeometry(.1,0),_.clone()),[0,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),f.clone()),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),d.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),m.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},A={X:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[.3,0,0],[0,0,-Math.PI/2]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,.3,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,-.3,0],[0,0,Math.PI]]],Z:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,.3],[Math.PI/2,0,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.OctahedronGeometry(.2,0),r)]],XY:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,0,.15],[-Math.PI/2,0,0]]]},R={START:[[new n.Mesh(new n.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],END:[[new n.Mesh(new n.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],DELTA:[[new n.Line(function(){const e=new n.BufferGeometry;return e.setAttribute("position",new n.Float32BufferAttribute([0,0,0,1,1,1],3)),e}(),o),null,null,null,"helper"]],X:[[new n.Line(E,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new n.Line(E,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new n.Line(E,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},O={XYZE:[[new n.Mesh(w(.5,1),y),null,[0,Math.PI/2,0]]],X:[[new n.Mesh(w(.5,.5),h)]],Y:[[new n.Mesh(w(.5,.5),l),null,[0,0,-Math.PI/2]]],Z:[[new n.Mesh(w(.5,.5),c),null,[0,Math.PI/2,0]]],E:[[new n.Mesh(w(.75,1),v),null,[0,Math.PI/2,0]]]},C={AXIS:[[new n.Line(E,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},P={XYZE:[[new n.Mesh(new n.SphereGeometry(.25,10,8),r)]],X:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[Math.PI/2,0,0]]],Z:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[0,0,-Math.PI/2]]],E:[[new n.Mesh(new n.TorusGeometry(.75,.1,2,24),r)]]},L={X:[[new n.Mesh(T,h),[.5,0,0],[0,0,-Math.PI/2]],[new n.Mesh(M,h),[0,0,0],[0,0,-Math.PI/2]],[new n.Mesh(T,h),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(T,l),[0,.5,0]],[new n.Mesh(M,l)],[new n.Mesh(T,l),[0,-.5,0],[0,0,Math.PI]]],Z:[[new n.Mesh(T,c),[0,0,.5],[Math.PI/2,0,0]],[new n.Mesh(M,c),[0,0,0],[Math.PI/2,0,0]],[new n.Mesh(T,c),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),f),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),d),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),m),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.BoxGeometry(.1,.1,.1),_.clone())]]},I={X:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[.3,0,0],[0,0,-Math.PI/2]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,.3,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,-.3,0],[0,0,Math.PI]]],Z:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,.3],[Math.PI/2,0,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.2),r),[0,0,0]]]},D={X:[[new n.Line(E,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new n.Line(E,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new n.Line(E,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function U(e){const t=new n.Object3D;for(const r in e)for(let i=e[r].length;i--;){const object=e[r][i][0].clone(),n=e[r][i][1],o=e[r][i][2],h=e[r][i][3],l=e[r][i][4];object.name=r,object.tag=l,n&&object.position.set(n[0],n[1],n[2]),o&&object.rotation.set(o[0],o[1],o[2]),h&&object.scale.set(h[0],h[1],h[2]),object.updateMatrix();const c=object.geometry.clone();c.applyMatrix4(object.matrix),object.geometry=c,object.renderOrder=1/0,object.position.set(0,0,0),object.rotation.set(0,0,0),object.scale.set(1,1,1),t.add(object)}return t}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=U(S)),this.add(this.gizmo.rotate=U(O)),this.add(this.gizmo.scale=U(L)),this.add(this.picker.translate=U(A)),this.add(this.picker.rotate=U(P)),this.add(this.picker.scale=U(I)),this.add(this.helper.translate=U(R)),this.add(this.helper.rotate=U(C)),this.add(this.helper.scale=U(D)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const t="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:L;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let r=[];r=r.concat(this.picker[this.mode].children),r=r.concat(this.gizmo[this.mode].children),r=r.concat(this.helper[this.mode].children);for(let i=0;i<r.length;i++){const e=r[i];let n;if(e.visible=!0,e.rotation.set(0,0,0),e.position.copy(this.worldPosition),n=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),e.scale.set(1,1,1).multiplyScalar(n*this.size/4),"helper"!==e.tag){if(e.quaternion.copy(t),"translate"===this.mode||"scale"===this.mode){const r=.99,n=.2;"X"===e.name&&Math.abs(R.copy(U).applyQuaternion(t).dot(this.eye))>r&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"Y"===e.name&&Math.abs(R.copy(F).applyQuaternion(t).dot(this.eye))>r&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"Z"===e.name&&Math.abs(R.copy(B).applyQuaternion(t).dot(this.eye))>r&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"XY"===e.name&&Math.abs(R.copy(B).applyQuaternion(t).dot(this.eye))<n&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"YZ"===e.name&&Math.abs(R.copy(U).applyQuaternion(t).dot(this.eye))<n&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"XZ"===e.name&&Math.abs(R.copy(F).applyQuaternion(t).dot(this.eye))<n&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1)}else"rotate"===this.mode&&(P.copy(t),R.copy(this.eye).applyQuaternion(c.copy(t).invert()),-1!==e.name.search("E")&&e.quaternion.setFromRotationMatrix(C.lookAt(this.eye,O,F)),"X"===e.name&&(c.setFromAxisAngle(U,Math.atan2(-R.y,R.z)),c.multiplyQuaternions(P,c),e.quaternion.copy(c)),"Y"===e.name&&(c.setFromAxisAngle(F,Math.atan2(R.x,R.z)),c.multiplyQuaternions(P,c),e.quaternion.copy(c)),"Z"===e.name&&(c.setFromAxisAngle(B,Math.atan2(R.y,R.x)),c.multiplyQuaternions(P,c),e.quaternion.copy(c)));e.visible=e.visible&&(-1===e.name.indexOf("X")||this.showX),e.visible=e.visible&&(-1===e.name.indexOf("Y")||this.showY),e.visible=e.visible&&(-1===e.name.indexOf("Z")||this.showZ),e.visible=e.visible&&(-1===e.name.indexOf("E")||this.showX&&this.showY&&this.showZ),e.material._color=e.material._color||e.material.color.clone(),e.material._opacity=e.material._opacity||e.material.opacity,e.material.color.copy(e.material._color),e.material.opacity=e.material._opacity,this.enabled&&this.axis&&(e.name===this.axis||this.axis.split("").some((function(a){return e.name===a})))&&(e.material.color.setHex(16776960),e.material.opacity=1)}else e.visible=!1,"AXIS"===e.name?(e.position.copy(this.worldPositionStart),e.visible=!!this.axis,"X"===this.axis&&(c.setFromEuler(A.set(0,0,0)),e.quaternion.copy(t).multiply(c),Math.abs(R.copy(U).applyQuaternion(t).dot(this.eye))>.9&&(e.visible=!1)),"Y"===this.axis&&(c.setFromEuler(A.set(0,0,Math.PI/2)),e.quaternion.copy(t).multiply(c),Math.abs(R.copy(F).applyQuaternion(t).dot(this.eye))>.9&&(e.visible=!1)),"Z"===this.axis&&(c.setFromEuler(A.set(0,Math.PI/2,0)),e.quaternion.copy(t).multiply(c),Math.abs(R.copy(B).applyQuaternion(t).dot(this.eye))>.9&&(e.visible=!1)),"XYZE"===this.axis&&(c.setFromEuler(A.set(0,Math.PI/2,0)),R.copy(this.rotationAxis),e.quaternion.setFromRotationMatrix(C.lookAt(O,R,F)),e.quaternion.multiply(c),e.visible=this.dragging),"E"===this.axis&&(e.visible=!1)):"START"===e.name?(e.position.copy(this.worldPositionStart),e.visible=this.dragging):"END"===e.name?(e.position.copy(this.worldPosition),e.visible=this.dragging):"DELTA"===e.name?(e.position.copy(this.worldPositionStart),e.quaternion.copy(this.worldQuaternionStart),h.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),h.applyQuaternion(this.worldQuaternionStart.clone().invert()),e.scale.copy(h),e.visible=this.dragging):(e.quaternion.copy(t),this.dragging?e.position.copy(this.worldPositionStart):e.position.copy(this.worldPosition),this.axis&&(e.visible=-1!==this.axis.search(e.name)))}super.updateMatrixWorld(e)}}H.prototype.isTransformControlsGizmo=!0;class V extends n.Mesh{constructor(){super(new n.PlaneGeometry(1e5,1e5,2,2),new n.MeshBasicMaterial({visible:!1,wireframe:!0,side:n.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(e){let t=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(t="local"),N.copy(U).applyQuaternion("local"===t?this.worldQuaternion:L),k.copy(F).applyQuaternion("local"===t?this.worldQuaternion:L),z.copy(B).applyQuaternion("local"===t?this.worldQuaternion:L),R.copy(k),this.mode){case"translate":case"scale":switch(this.axis){case"X":R.copy(this.eye).cross(N),I.copy(N).cross(R);break;case"Y":R.copy(this.eye).cross(k),I.copy(k).cross(R);break;case"Z":R.copy(this.eye).cross(z),I.copy(z).cross(R);break;case"XY":I.copy(z);break;case"YZ":I.copy(N);break;case"XZ":R.copy(z),I.copy(k);break;case"XYZ":case"E":I.set(0,0,0)}break;default:I.set(0,0,0)}0===I.length()?this.quaternion.copy(this.cameraQuaternion):(D.lookAt(h.set(0,0,0),I,R),this.quaternion.setFromRotationMatrix(D)),super.updateMatrixWorld(e)}}V.prototype.isTransformControlsPlane=!0},682:function(e,t,r){"use strict";var n;function o(e){return e.isPerspectiveCamera}function h(e){return e.isOrthographicCamera}r.d(t,"a",(function(){return W})),function(e){e[e.NONE=0]="NONE",e[e.ROTATE=1]="ROTATE",e[e.TRUCK=2]="TRUCK",e[e.OFFSET=3]="OFFSET",e[e.DOLLY=4]="DOLLY",e[e.ZOOM=5]="ZOOM",e[e.TOUCH_ROTATE=6]="TOUCH_ROTATE",e[e.TOUCH_TRUCK=7]="TOUCH_TRUCK",e[e.TOUCH_OFFSET=8]="TOUCH_OFFSET",e[e.TOUCH_DOLLY=9]="TOUCH_DOLLY",e[e.TOUCH_ZOOM=10]="TOUCH_ZOOM",e[e.TOUCH_DOLLY_TRUCK=11]="TOUCH_DOLLY_TRUCK",e[e.TOUCH_DOLLY_OFFSET=12]="TOUCH_DOLLY_OFFSET",e[e.TOUCH_ZOOM_TRUCK=13]="TOUCH_ZOOM_TRUCK",e[e.TOUCH_ZOOM_OFFSET=14]="TOUCH_ZOOM_OFFSET"}(n||(n={}));const l=2*Math.PI,c=Math.PI/2;function d(e,t=1e-5){return Math.abs(e)<t}function m(a,b,e=1e-5){return d(a-b,e)}function f(e,t){return Math.round(e/t)*t}function _(e){return isFinite(e)?e:e<0?-Number.MAX_VALUE:Number.MAX_VALUE}function v(e){return Math.abs(e)<Number.MAX_VALUE?e:e*(1/0)}function y(e,t){t.set(0,0),e.forEach((e=>{t.x+=e.clientX,t.y+=e.clientY})),t.x/=e.length,t.y/=e.length}function x(e,t){return!!h(e)&&(console.warn(`${t} is not supported in OrthographicCamera`),!0)}function T(e){return e.invert?e.invert():e.inverse(),e}const E="undefined"!=typeof window,M=E&&/Mac/.test(navigator.platform),w=!(E&&"PointerEvent"in window),S=Object.freeze(n),A=1/8;let R,O,C,P,L,I,D,U,F,B,N,k,z,H,V,G,Q,j,X,Y,K,Z;class W extends class{constructor(){this._listeners={}}addEventListener(e,t){const r=this._listeners;void 0===r[e]&&(r[e]=[]),-1===r[e].indexOf(t)&&r[e].push(t)}removeEventListener(e,t){const r=this._listeners[e];if(void 0!==r){const e=r.indexOf(t);-1!==e&&r.splice(e,1)}}removeAllEventListeners(e){e?Array.isArray(this._listeners[e])&&(this._listeners[e].length=0):this._listeners={}}dispatchEvent(e){const t=this._listeners[e.type];if(void 0!==t){e.target=this;const r=t.slice(0);for(let i=0,t=r.length;i<t;i++)r[i].call(this,e)}}}{constructor(e,t){if(super(),this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.minDistance=0,this.maxDistance=1/0,this.infinityDolly=!1,this.minZoom=.01,this.maxZoom=1/0,this.dampingFactor=.05,this.draggingDampingFactor=.25,this.azimuthRotateSpeed=1,this.polarRotateSpeed=1,this.dollySpeed=1,this.truckSpeed=2,this.dollyToCursor=!1,this.dragToOffset=!1,this.verticalDragToForward=!1,this.boundaryFriction=0,this.restThreshold=.01,this.colliderMeshes=[],this.cancel=()=>{},this._enabled=!0,this._state=n.NONE,this._viewport=null,this._dollyControlAmount=0,this._hasRested=!0,this._boundaryEnclosesCamera=!1,this._needsUpdate=!0,this._updatedLastTime=!1,this._elementRect=new DOMRect,this._activePointers=[],this._truckInternal=(e,t,r)=>{if(o(this._camera)){const n=I.copy(this._camera.position).sub(this._target),o=this._camera.getEffectiveFOV()*R.MathUtils.DEG2RAD,h=n.length()*Math.tan(.5*o),l=this.truckSpeed*e*h/this._elementRect.height,c=this.truckSpeed*t*h/this._elementRect.height;this.verticalDragToForward?(r?this.setFocalOffset(this._focalOffsetEnd.x+l,this._focalOffsetEnd.y,this._focalOffsetEnd.z,!0):this.truck(l,0,!0),this.forward(-c,!0)):r?this.setFocalOffset(this._focalOffsetEnd.x+l,this._focalOffsetEnd.y+c,this._focalOffsetEnd.z,!0):this.truck(l,c,!0)}else if(h(this._camera)){const n=this._camera,o=e*(n.right-n.left)/n.zoom/this._elementRect.width,h=t*(n.top-n.bottom)/n.zoom/this._elementRect.height;r?this.setFocalOffset(this._focalOffsetEnd.x+o,this._focalOffsetEnd.y+h,this._focalOffsetEnd.z,!0):this.truck(o,h,!0)}},this._rotateInternal=(e,t)=>{const r=l*this.azimuthRotateSpeed*e/this._elementRect.height,n=l*this.polarRotateSpeed*t/this._elementRect.height;this.rotate(r,n,!0)},this._dollyInternal=(e,t,r)=>{const n=Math.pow(.95,-e*this.dollySpeed),o=this._sphericalEnd.radius*n,h=this._sphericalEnd.radius,l=h*(e>=0?-1:1);this.dollyTo(o),this.infinityDolly&&(o<this.minDistance||this.maxDistance===this.minDistance)&&(this._camera.getWorldDirection(I),this._targetEnd.add(I.normalize().multiplyScalar(l)),this._target.add(I.normalize().multiplyScalar(l))),this.dollyToCursor&&(this._dollyControlAmount+=this._sphericalEnd.radius-h,this.infinityDolly&&(o<this.minDistance||this.maxDistance===this.minDistance)&&(this._dollyControlAmount-=l),this._dollyControlCoord.set(t,r))},this._zoomInternal=(e,t,r)=>{const n=Math.pow(.95,e*this.dollySpeed);this.zoomTo(this._zoom*n),this.dollyToCursor&&(this._dollyControlAmount=this._zoomEnd,this._dollyControlCoord.set(t,r))},void 0===R&&console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."),this._camera=e,this._yAxisUpSpace=(new R.Quaternion).setFromUnitVectors(this._camera.up,C),this._yAxisUpSpaceInverse=T(this._yAxisUpSpace.clone()),this._state=n.NONE,this._domElement=t,this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none",this._target=new R.Vector3,this._targetEnd=this._target.clone(),this._focalOffset=new R.Vector3,this._focalOffsetEnd=this._focalOffset.clone(),this._spherical=(new R.Spherical).setFromVector3(I.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)),this._sphericalEnd=this._spherical.clone(),this._zoom=this._camera.zoom,this._zoomEnd=this._zoom,this._nearPlaneCorners=[new R.Vector3,new R.Vector3,new R.Vector3,new R.Vector3],this._updateNearPlaneCorners(),this._boundary=new R.Box3(new R.Vector3(-1/0,-1/0,-1/0),new R.Vector3(1/0,1/0,1/0)),this._target0=this._target.clone(),this._position0=this._camera.position.clone(),this._zoom0=this._zoom,this._focalOffset0=this._focalOffset.clone(),this._dollyControlAmount=0,this._dollyControlCoord=new R.Vector2,this.mouseButtons={left:n.ROTATE,middle:n.DOLLY,right:n.TRUCK,wheel:o(this._camera)?n.DOLLY:h(this._camera)?n.ZOOM:n.NONE,shiftLeft:n.NONE},this.touches={one:n.TOUCH_ROTATE,two:o(this._camera)?n.TOUCH_DOLLY_TRUCK:h(this._camera)?n.TOUCH_ZOOM_TRUCK:n.NONE,three:n.TOUCH_TRUCK},this._domElement){const e=new R.Vector2,t=new R.Vector2,r=new R.Vector2,o=e=>{if(!this._enabled)return;const t={pointerId:e.pointerId,clientX:e.clientX,clientY:e.clientY};switch(this._activePointers.push(t),e.button){case R.MOUSE.LEFT:this._state=e.shiftKey?this.mouseButtons.shiftLeft:this.mouseButtons.left;break;case R.MOUSE.MIDDLE:this._state=this.mouseButtons.middle;break;case R.MOUSE.RIGHT:this._state=this.mouseButtons.right}if("touch"===e.pointerType)switch(this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.addEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.addEventListener("pointerup",f),S()},h=e=>{if(!this._enabled)return;const t={pointerId:0,clientX:e.clientX,clientY:e.clientY};switch(this._activePointers.push(t),e.button){case R.MOUSE.LEFT:this._state=e.shiftKey?this.mouseButtons.shiftLeft:this.mouseButtons.left;break;case R.MOUSE.MIDDLE:this._state=this.mouseButtons.middle;break;case R.MOUSE.RIGHT:this._state=this.mouseButtons.right}this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("mouseup",_),this._domElement.ownerDocument.addEventListener("mousemove",d),this._domElement.ownerDocument.addEventListener("mouseup",_),S()},l=e=>{if(this._enabled){switch(e.preventDefault(),Array.prototype.forEach.call(e.changedTouches,(e=>{const t={pointerId:e.identifier,clientX:e.clientX,clientY:e.clientY};this._activePointers.push(t)})),this._activePointers.length){case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("touchend",v),this._domElement.ownerDocument.addEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.addEventListener("touchend",v),S()}},c=e=>{e.cancelable&&e.preventDefault();const t=e.pointerId,r=this._findPointerById(t);r&&(r.clientX=e.clientX,r.clientY=e.clientY,O())},d=e=>{const t=this._findPointerById(0);t&&(t.clientX=e.clientX,t.clientY=e.clientY,O())},m=e=>{e.cancelable&&e.preventDefault(),Array.prototype.forEach.call(e.changedTouches,(e=>{const t=e.identifier,r=this._findPointerById(t);r&&(r.clientX=e.clientX,r.clientY=e.clientY)})),O()},f=e=>{const t=e.pointerId,r=this._findPointerById(t);if(r&&this._activePointers.splice(this._activePointers.indexOf(r),1),"touch"===e.pointerType)switch(this._activePointers.length){case 0:this._state=n.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}else this._state=n.NONE;C()},_=()=>{const e=this._findPointerById(0);e&&this._activePointers.splice(this._activePointers.indexOf(e),1),this._state=n.NONE,C()},v=e=>{switch(Array.prototype.forEach.call(e.changedTouches,(e=>{const t=e.identifier,r=this._findPointerById(t);r&&this._activePointers.splice(this._activePointers.indexOf(r),1)})),this._activePointers.length){case 0:this._state=n.NONE;break;case 1:this._state=this.touches.one;break;case 2:this._state=this.touches.two;break;case 3:this._state=this.touches.three}C()};let x=-1;const T=e=>{if(!this._enabled||this.mouseButtons.wheel===n.NONE)return;if(e.preventDefault(),this.dollyToCursor||this.mouseButtons.wheel===n.ROTATE||this.mouseButtons.wheel===n.TRUCK){const e=performance.now();x-e<1e3&&this._getClientRect(this._elementRect),x=e}const t=M?-1:-3,r=1===e.deltaMode?e.deltaY/t:e.deltaY/(10*t),o=this.dollyToCursor?(e.clientX-this._elementRect.x)/this._elementRect.width*2-1:0,h=this.dollyToCursor?(e.clientY-this._elementRect.y)/this._elementRect.height*-2+1:0;switch(this.mouseButtons.wheel){case n.ROTATE:this._rotateInternal(e.deltaX,e.deltaY);break;case n.TRUCK:this._truckInternal(e.deltaX,e.deltaY,!1);break;case n.OFFSET:this._truckInternal(e.deltaX,e.deltaY,!0);break;case n.DOLLY:this._dollyInternal(-r,o,h);break;case n.ZOOM:this._zoomInternal(-r,o,h)}this.dispatchEvent({type:"control"})},E=e=>{this._enabled&&e.preventDefault()},S=()=>{if(!this._enabled)return;y(this._activePointers,L),this._getClientRect(this._elementRect),e.copy(L),t.copy(L);if(this._activePointers.length>=2){const e=L.x-this._activePointers[1].clientX,n=L.y-this._activePointers[1].clientY,o=Math.sqrt(e*e+n*n);r.set(0,o);const h=.5*(this._activePointers[0].clientX+this._activePointers[1].clientX),l=.5*(this._activePointers[0].clientY+this._activePointers[1].clientY);t.set(h,l)}this.dispatchEvent({type:"controlstart"})},O=()=>{if(!this._enabled)return;y(this._activePointers,L);const o=t.x-L.x,h=t.y-L.y;switch(t.copy(L),this._state){case n.ROTATE:case n.TOUCH_ROTATE:this._rotateInternal(o,h);break;case n.DOLLY:case n.ZOOM:{const t=this.dollyToCursor?(e.x-this._elementRect.x)/this._elementRect.width*2-1:0,r=this.dollyToCursor?(e.y-this._elementRect.y)/this._elementRect.height*-2+1:0;this._state===n.DOLLY?this._dollyInternal(h*A,t,r):this._zoomInternal(h*A,t,r);break}case n.TOUCH_DOLLY:case n.TOUCH_ZOOM:case n.TOUCH_DOLLY_TRUCK:case n.TOUCH_ZOOM_TRUCK:case n.TOUCH_DOLLY_OFFSET:case n.TOUCH_ZOOM_OFFSET:{const e=L.x-this._activePointers[1].clientX,l=L.y-this._activePointers[1].clientY,c=Math.sqrt(e*e+l*l),d=r.y-c;r.set(0,c);const m=this.dollyToCursor?(t.x-this._elementRect.x)/this._elementRect.width*2-1:0,f=this.dollyToCursor?(t.y-this._elementRect.y)/this._elementRect.height*-2+1:0;this._state===n.TOUCH_DOLLY||this._state===n.TOUCH_DOLLY_TRUCK||this._state===n.TOUCH_DOLLY_OFFSET?this._dollyInternal(d*A,m,f):this._zoomInternal(d*A,m,f),this._state===n.TOUCH_DOLLY_TRUCK||this._state===n.TOUCH_ZOOM_TRUCK?this._truckInternal(o,h,!1):this._state!==n.TOUCH_DOLLY_OFFSET&&this._state!==n.TOUCH_ZOOM_OFFSET||this._truckInternal(o,h,!0);break}case n.TRUCK:case n.TOUCH_TRUCK:this._truckInternal(o,h,!1);break;case n.OFFSET:case n.TOUCH_OFFSET:this._truckInternal(o,h,!0)}this.dispatchEvent({type:"control"})},C=()=>{y(this._activePointers,L),t.copy(L),0===this._activePointers.length&&(this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("touchend",v),this.dispatchEvent({type:"controlend"}))};this._domElement.addEventListener("pointerdown",o),w&&this._domElement.addEventListener("mousedown",h),w&&this._domElement.addEventListener("touchstart",l),this._domElement.addEventListener("pointercancel",f),this._domElement.addEventListener("wheel",T,{passive:!1}),this._domElement.addEventListener("contextmenu",E),this._removeAllEventListeners=()=>{this._domElement.removeEventListener("pointerdown",o),this._domElement.removeEventListener("mousedown",h),this._domElement.removeEventListener("touchstart",l),this._domElement.removeEventListener("pointercancel",f),this._domElement.removeEventListener("wheel",T,{passive:!1}),this._domElement.removeEventListener("contextmenu",E),this._domElement.ownerDocument.removeEventListener("pointermove",c,{passive:!1}),this._domElement.ownerDocument.removeEventListener("mousemove",d),this._domElement.ownerDocument.removeEventListener("touchmove",m,{passive:!1}),this._domElement.ownerDocument.removeEventListener("pointerup",f),this._domElement.ownerDocument.removeEventListener("mouseup",_),this._domElement.ownerDocument.removeEventListener("touchend",v)},this.cancel=()=>{this._state!==n.NONE&&(this._state=n.NONE,this._activePointers.length=0,C())}}this.update(0)}static install(e){R=e.THREE,O=Object.freeze(new R.Vector3(0,0,0)),C=Object.freeze(new R.Vector3(0,1,0)),P=Object.freeze(new R.Vector3(0,0,1)),L=new R.Vector2,I=new R.Vector3,D=new R.Vector3,U=new R.Vector3,F=new R.Vector3,B=new R.Vector3,N=new R.Vector3,k=new R.Vector3,z=new R.Vector3,H=new R.Spherical,V=new R.Spherical,G=new R.Box3,Q=new R.Box3,j=new R.Sphere,X=new R.Quaternion,Y=new R.Quaternion,K=new R.Matrix4,Z=new R.Raycaster}static get ACTION(){return S}get camera(){return this._camera}set camera(e){this._camera=e,this.updateCameraUp(),this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0}get enabled(){return this._enabled}set enabled(e){this._enabled=e,e?(this._domElement.style.touchAction="none",this._domElement.style.userSelect="none",this._domElement.style.webkitUserSelect="none"):(this.cancel(),this._domElement.style.touchAction="",this._domElement.style.userSelect="",this._domElement.style.webkitUserSelect="")}get active(){return!this._hasRested}get currentAction(){return this._state}get distance(){return this._spherical.radius}set distance(e){this._spherical.radius===e&&this._sphericalEnd.radius===e||(this._spherical.radius=e,this._sphericalEnd.radius=e,this._needsUpdate=!0)}get azimuthAngle(){return this._spherical.theta}set azimuthAngle(e){this._spherical.theta===e&&this._sphericalEnd.theta===e||(this._spherical.theta=e,this._sphericalEnd.theta=e,this._needsUpdate=!0)}get polarAngle(){return this._spherical.phi}set polarAngle(e){this._spherical.phi===e&&this._sphericalEnd.phi===e||(this._spherical.phi=e,this._sphericalEnd.phi=e,this._needsUpdate=!0)}get boundaryEnclosesCamera(){return this._boundaryEnclosesCamera}set boundaryEnclosesCamera(e){this._boundaryEnclosesCamera=e,this._needsUpdate=!0}addEventListener(e,t){super.addEventListener(e,t)}removeEventListener(e,t){super.removeEventListener(e,t)}rotate(e,t,r=!1){return this.rotateTo(this._sphericalEnd.theta+e,this._sphericalEnd.phi+t,r)}rotateAzimuthTo(e,t=!1){return this.rotateTo(e,this._sphericalEnd.phi,t)}rotatePolarTo(e,t=!1){return this.rotateTo(this._sphericalEnd.theta,e,t)}rotateTo(e,t,r=!1){const n=R.MathUtils.clamp(e,this.minAzimuthAngle,this.maxAzimuthAngle),o=R.MathUtils.clamp(t,this.minPolarAngle,this.maxPolarAngle);this._sphericalEnd.theta=n,this._sphericalEnd.phi=o,this._sphericalEnd.makeSafe(),this._needsUpdate=!0,r||(this._spherical.theta=this._sphericalEnd.theta,this._spherical.phi=this._sphericalEnd.phi);const h=!r||m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold);return this._createOnRestPromise(h)}dolly(e,t=!1){return this.dollyTo(this._sphericalEnd.radius-e,t)}dollyTo(e,t=!1){const r=this._sphericalEnd.radius,n=R.MathUtils.clamp(e,this.minDistance,this.maxDistance);if(this.colliderMeshes.length>=1){const e=this._collisionTest(),t=m(e,this._spherical.radius);if(!(r>n)&&t)return Promise.resolve();this._sphericalEnd.radius=Math.min(n,e)}else this._sphericalEnd.radius=n;this._needsUpdate=!0,t||(this._spherical.radius=this._sphericalEnd.radius);const o=!t||m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(o)}zoom(e,t=!1){return this.zoomTo(this._zoomEnd+e,t)}zoomTo(e,t=!1){this._zoomEnd=R.MathUtils.clamp(e,this.minZoom,this.maxZoom),this._needsUpdate=!0,t||(this._zoom=this._zoomEnd);const r=!t||m(this._zoom,this._zoomEnd,this.restThreshold);return this._createOnRestPromise(r)}pan(e,t,r=!1){return console.warn("`pan` has been renamed to `truck`"),this.truck(e,t,r)}truck(e,t,r=!1){this._camera.updateMatrix(),F.setFromMatrixColumn(this._camera.matrix,0),B.setFromMatrixColumn(this._camera.matrix,1),F.multiplyScalar(e),B.multiplyScalar(-t);const n=I.copy(F).add(B),o=D.copy(this._targetEnd).add(n);return this.moveTo(o.x,o.y,o.z,r)}forward(e,t=!1){I.setFromMatrixColumn(this._camera.matrix,0),I.crossVectors(this._camera.up,I),I.multiplyScalar(e);const r=D.copy(this._targetEnd).add(I);return this.moveTo(r.x,r.y,r.z,t)}moveTo(e,t,r,n=!1){const o=I.set(e,t,r).sub(this._targetEnd);this._encloseToBoundary(this._targetEnd,o,this.boundaryFriction),this._needsUpdate=!0,n||this._target.copy(this._targetEnd);const h=!n||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold);return this._createOnRestPromise(h)}fitToBox(e,t,{paddingLeft:r=0,paddingRight:n=0,paddingBottom:l=0,paddingTop:d=0}={}){const _=[],v=e.isBox3?G.copy(e):G.setFromObject(e);v.isEmpty()&&(console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"),Promise.resolve());const y=f(this._sphericalEnd.theta,c),x=f(this._sphericalEnd.phi,c);_.push(this.rotateTo(y,x,t));const T=I.setFromSpherical(this._sphericalEnd).normalize(),E=X.setFromUnitVectors(T,P);m(Math.abs(T.y),1)&&E.multiply(Y.setFromAxisAngle(C,y));const M=Q.makeEmpty();D.copy(v.min).applyQuaternion(E),M.expandByPoint(D),D.copy(v.min).setX(v.max.x).applyQuaternion(E),M.expandByPoint(D),D.copy(v.min).setY(v.max.y).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).setZ(v.min.z).applyQuaternion(E),M.expandByPoint(D),D.copy(v.min).setZ(v.max.z).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).setY(v.min.y).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).setX(v.min.x).applyQuaternion(E),M.expandByPoint(D),D.copy(v.max).applyQuaternion(E),M.expandByPoint(D),E.setFromUnitVectors(P,T),M.min.x-=r,M.min.y-=l,M.max.x+=n,M.max.y+=d;const w=M.getSize(I),S=M.getCenter(D).applyQuaternion(E);if(o(this._camera)){const e=this.getDistanceToFitBox(w.x,w.y,w.z);_.push(this.moveTo(S.x,S.y,S.z,t)),_.push(this.dollyTo(e,t)),_.push(this.setFocalOffset(0,0,0,t))}else if(h(this._camera)){const e=this._camera,r=e.right-e.left,n=e.top-e.bottom,o=Math.min(r/w.x,n/w.y);_.push(this.moveTo(S.x,S.y,S.z,t)),_.push(this.zoomTo(o,t)),_.push(this.setFocalOffset(0,0,0,t))}return Promise.all(_)}fitToSphere(e,t){const r=[],n=e instanceof R.Sphere?j.copy(e):function(e,t){const r=t,n=r.center;G.makeEmpty(),e.traverseVisible((object=>{object.isMesh&&G.expandByObject(object)})),G.getCenter(n);let o=0;return e.traverseVisible((object=>{if(!object.isMesh)return;const e=object,t=e.geometry.clone();if(t.applyMatrix4(e.matrixWorld),t.isBufferGeometry){const e=t.attributes.position;for(let i=0,t=e.count;i<t;i++)I.fromBufferAttribute(e,i),o=Math.max(o,n.distanceToSquared(I))}else{const e=t.attributes.position,r=new R.Vector3;for(let i=0,t=e.count;i<t;i++)r.fromBufferAttribute(e,i),o=Math.max(o,n.distanceToSquared(r))}})),r.radius=Math.sqrt(o),r}(e,j);if(r.push(this.moveTo(n.center.x,n.center.y,n.center.z,t)),o(this._camera)){const e=this.getDistanceToFitSphere(n.radius);r.push(this.dollyTo(e,t))}else if(h(this._camera)){const e=this._camera.right-this._camera.left,o=this._camera.top-this._camera.bottom,h=2*n.radius,l=Math.min(e/h,o/h);r.push(this.zoomTo(l,t))}return r.push(this.setFocalOffset(0,0,0,t)),Promise.all(r)}setLookAt(e,t,r,n,o,h,l=!1){const c=D.set(n,o,h),d=I.set(e,t,r);this._targetEnd.copy(c),this._sphericalEnd.setFromVector3(d.sub(c).applyQuaternion(this._yAxisUpSpace)),this.normalizeRotations(),this._needsUpdate=!0,l||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const f=!l||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold)&&m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(f)}lerpLookAt(e,t,r,n,o,h,l,c,d,f,_,v,y,x=!1){const T=I.set(n,o,h),E=D.set(e,t,r);H.setFromVector3(E.sub(T).applyQuaternion(this._yAxisUpSpace));const M=U.set(f,_,v),w=D.set(l,c,d);V.setFromVector3(w.sub(M).applyQuaternion(this._yAxisUpSpace)),this._targetEnd.copy(T.lerp(M,y));const S=V.theta-H.theta,A=V.phi-H.phi,R=V.radius-H.radius;this._sphericalEnd.set(H.radius+R*y,H.phi+A*y,H.theta+S*y),this.normalizeRotations(),this._needsUpdate=!0,x||(this._target.copy(this._targetEnd),this._spherical.copy(this._sphericalEnd));const O=!x||m(this._target.x,this._targetEnd.x,this.restThreshold)&&m(this._target.y,this._targetEnd.y,this.restThreshold)&&m(this._target.z,this._targetEnd.z,this.restThreshold)&&m(this._spherical.theta,this._sphericalEnd.theta,this.restThreshold)&&m(this._spherical.phi,this._sphericalEnd.phi,this.restThreshold)&&m(this._spherical.radius,this._sphericalEnd.radius,this.restThreshold);return this._createOnRestPromise(O)}setPosition(e,t,r,n=!1){return this.setLookAt(e,t,r,this._targetEnd.x,this._targetEnd.y,this._targetEnd.z,n)}setTarget(e,t,r,n=!1){const o=this.getPosition(I);return this.setLookAt(o.x,o.y,o.z,e,t,r,n)}setFocalOffset(e,t,r,n=!1){this._focalOffsetEnd.set(e,t,r),this._needsUpdate=!0,n||this._focalOffset.copy(this._focalOffsetEnd);const o=!n||m(this._focalOffset.x,this._focalOffsetEnd.x,this.restThreshold)&&m(this._focalOffset.y,this._focalOffsetEnd.y,this.restThreshold)&&m(this._focalOffset.z,this._focalOffsetEnd.z,this.restThreshold);return this._createOnRestPromise(o)}setOrbitPoint(e,t,r){F.setFromMatrixColumn(this._camera.matrixWorldInverse,0),B.setFromMatrixColumn(this._camera.matrixWorldInverse,1),N.setFromMatrixColumn(this._camera.matrixWorldInverse,2);const n=I.set(e,t,r),o=n.distanceTo(this._camera.position),h=n.sub(this._camera.position);F.multiplyScalar(h.x),B.multiplyScalar(h.y),N.multiplyScalar(h.z),I.copy(F).add(B).add(N),I.z=I.z+o,this.dollyTo(o,!1),this.setFocalOffset(-I.x,I.y,-I.z,!1),this.moveTo(e,t,r,!1)}setBoundary(e){if(!e)return this._boundary.min.set(-1/0,-1/0,-1/0),this._boundary.max.set(1/0,1/0,1/0),void(this._needsUpdate=!0);this._boundary.copy(e),this._boundary.clampPoint(this._targetEnd,this._targetEnd),this._needsUpdate=!0}setViewport(e,t,r,n){null!==e?(this._viewport=this._viewport||new R.Vector4,"number"==typeof e?this._viewport.set(e,t,r,n):this._viewport.copy(e)):this._viewport=null}getDistanceToFitBox(e,t,r){if(x(this._camera,"getDistanceToFitBox"))return this._spherical.radius;const n=e/t,o=this._camera.getEffectiveFOV()*R.MathUtils.DEG2RAD,h=this._camera.aspect;return.5*(n<h?t:e/h)/Math.tan(.5*o)+.5*r}getDistanceToFitSphere(e){if(x(this._camera,"getDistanceToFitSphere"))return this._spherical.radius;const t=this._camera.getEffectiveFOV()*R.MathUtils.DEG2RAD,r=2*Math.atan(Math.tan(.5*t)*this._camera.aspect),n=1<this._camera.aspect?t:r;return e/Math.sin(.5*n)}getTarget(e){return(e&&e.isVector3?e:new R.Vector3).copy(this._targetEnd)}getPosition(e){return(e&&e.isVector3?e:new R.Vector3).setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).add(this._targetEnd)}getFocalOffset(e){return(e&&e.isVector3?e:new R.Vector3).copy(this._focalOffsetEnd)}normalizeRotations(){this._sphericalEnd.theta=this._sphericalEnd.theta%l,this._sphericalEnd.theta<0&&(this._sphericalEnd.theta+=l),this._spherical.theta+=l*Math.round((this._sphericalEnd.theta-this._spherical.theta)/l)}reset(e=!1){const t=[this.setLookAt(this._position0.x,this._position0.y,this._position0.z,this._target0.x,this._target0.y,this._target0.z,e),this.setFocalOffset(this._focalOffset0.x,this._focalOffset0.y,this._focalOffset0.z,e),this.zoomTo(this._zoom0,e)];return Promise.all(t)}saveState(){this._target0.copy(this._target),this._position0.copy(this._camera.position),this._zoom0=this._zoom}updateCameraUp(){this._yAxisUpSpace.setFromUnitVectors(this._camera.up,C),T(this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace))}update(e){const t=this._state===n.NONE?this.dampingFactor:this.draggingDampingFactor,r=Math.min(t*e*60,1),l=this._sphericalEnd.theta-this._spherical.theta,c=this._sphericalEnd.phi-this._spherical.phi,m=this._sphericalEnd.radius-this._spherical.radius,f=k.subVectors(this._targetEnd,this._target),_=z.subVectors(this._focalOffsetEnd,this._focalOffset);if(d(l)&&d(c)&&d(m)&&d(f.x)&&d(f.y)&&d(f.z)&&d(_.x)&&d(_.y)&&d(_.z)?(this._spherical.copy(this._sphericalEnd),this._target.copy(this._targetEnd),this._focalOffset.copy(this._focalOffsetEnd)):(this._spherical.set(this._spherical.radius+m*r,this._spherical.phi+c*r,this._spherical.theta+l*r),this._target.add(f.multiplyScalar(r)),this._focalOffset.add(_.multiplyScalar(r)),this._needsUpdate=!0),0!==this._dollyControlAmount){if(o(this._camera)){const e=this._camera,t=I.setFromSpherical(this._sphericalEnd).applyQuaternion(this._yAxisUpSpaceInverse).normalize().negate(),r=D.copy(t).cross(e.up).normalize();0===r.lengthSq()&&(r.x=1);const n=U.crossVectors(r,t),o=this._sphericalEnd.radius*Math.tan(e.getEffectiveFOV()*R.MathUtils.DEG2RAD*.5),h=(this._sphericalEnd.radius-this._dollyControlAmount-this._sphericalEnd.radius)/this._sphericalEnd.radius,cursor=I.copy(this._targetEnd).add(r.multiplyScalar(this._dollyControlCoord.x*o*e.aspect)).add(n.multiplyScalar(this._dollyControlCoord.y*o));this._targetEnd.lerp(cursor,h),this._target.copy(this._targetEnd)}else if(h(this._camera)){const e=this._camera,t=I.set(this._dollyControlCoord.x,this._dollyControlCoord.y,(e.near+e.far)/(e.near-e.far)).unproject(e),r=D.set(0,0,-1).applyQuaternion(e.quaternion),n=r.dot(e.up),o=d(n)?-t.dot(e.up):-t.dot(e.up)/n,cursor=U.copy(t).add(r.multiplyScalar(o));this._targetEnd.lerp(cursor,1-e.zoom/this._dollyControlAmount),this._target.copy(this._targetEnd)}this._dollyControlAmount=0}const v=this._collisionTest();this._spherical.radius=Math.min(this._spherical.radius,v),this._spherical.makeSafe(),this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),this._camera.lookAt(this._target);(!d(this._focalOffset.x)||!d(this._focalOffset.y)||!d(this._focalOffset.z))&&(this._camera.updateMatrix(),F.setFromMatrixColumn(this._camera.matrix,0),B.setFromMatrixColumn(this._camera.matrix,1),N.setFromMatrixColumn(this._camera.matrix,2),F.multiplyScalar(this._focalOffset.x),B.multiplyScalar(-this._focalOffset.y),N.multiplyScalar(this._focalOffset.z),I.copy(F).add(B).add(N),this._camera.position.add(I)),this._boundaryEnclosesCamera&&this._encloseToBoundary(this._camera.position.copy(this._target),I.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),1);const y=this._zoomEnd-this._zoom;this._zoom+=y*r,this._camera.zoom!==this._zoom&&(d(y)&&(this._zoom=this._zoomEnd),this._camera.zoom=this._zoom,this._camera.updateProjectionMatrix(),this._updateNearPlaneCorners(),this._needsUpdate=!0);const x=this._needsUpdate;return x&&!this._updatedLastTime?(this._hasRested=!1,this.dispatchEvent({type:"wake"}),this.dispatchEvent({type:"update"})):x?(this.dispatchEvent({type:"update"}),d(l,this.restThreshold)&&d(c,this.restThreshold)&&d(m,this.restThreshold)&&d(f.x,this.restThreshold)&&d(f.y,this.restThreshold)&&d(f.z,this.restThreshold)&&d(_.x,this.restThreshold)&&d(_.y,this.restThreshold)&&d(_.z,this.restThreshold)&&!this._hasRested&&(this._hasRested=!0,this.dispatchEvent({type:"rest"}))):!x&&this._updatedLastTime&&this.dispatchEvent({type:"sleep"}),this._updatedLastTime=x,this._needsUpdate=!1,x}toJSON(){return JSON.stringify({enabled:this._enabled,minDistance:this.minDistance,maxDistance:_(this.maxDistance),minZoom:this.minZoom,maxZoom:_(this.maxZoom),minPolarAngle:this.minPolarAngle,maxPolarAngle:_(this.maxPolarAngle),minAzimuthAngle:_(this.minAzimuthAngle),maxAzimuthAngle:_(this.maxAzimuthAngle),dampingFactor:this.dampingFactor,draggingDampingFactor:this.draggingDampingFactor,dollySpeed:this.dollySpeed,truckSpeed:this.truckSpeed,dollyToCursor:this.dollyToCursor,verticalDragToForward:this.verticalDragToForward,target:this._targetEnd.toArray(),position:I.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),zoom:this._zoomEnd,focalOffset:this._focalOffsetEnd.toArray(),target0:this._target0.toArray(),position0:this._position0.toArray(),zoom0:this._zoom0,focalOffset0:this._focalOffset0.toArray()})}fromJSON(e,t=!1){const r=JSON.parse(e),n=I.fromArray(r.position);this.enabled=r.enabled,this.minDistance=r.minDistance,this.maxDistance=v(r.maxDistance),this.minZoom=r.minZoom,this.maxZoom=v(r.maxZoom),this.minPolarAngle=r.minPolarAngle,this.maxPolarAngle=v(r.maxPolarAngle),this.minAzimuthAngle=v(r.minAzimuthAngle),this.maxAzimuthAngle=v(r.maxAzimuthAngle),this.dampingFactor=r.dampingFactor,this.draggingDampingFactor=r.draggingDampingFactor,this.dollySpeed=r.dollySpeed,this.truckSpeed=r.truckSpeed,this.dollyToCursor=r.dollyToCursor,this.verticalDragToForward=r.verticalDragToForward,this._target0.fromArray(r.target0),this._position0.fromArray(r.position0),this._zoom0=r.zoom0,this._focalOffset0.fromArray(r.focalOffset0),this.moveTo(r.target[0],r.target[1],r.target[2],t),H.setFromVector3(n.sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),this.rotateTo(H.theta,H.phi,t),this.zoomTo(r.zoom,t),this.setFocalOffset(r.focalOffset[0],r.focalOffset[1],r.focalOffset[2],t),this._needsUpdate=!0}dispose(){this._removeAllEventListeners()}_findPointerById(e){let t=null;return this._activePointers.some((r=>r.pointerId===e&&(t=r,!0))),t}_encloseToBoundary(e,t,r){const n=t.lengthSq();if(0===n)return e;const o=D.copy(t).add(e),h=this._boundary.clampPoint(o,U).sub(o),l=h.lengthSq();if(0===l)return e.add(t);if(l===n)return e;if(0===r)return e.add(t).add(h);{const n=1+r*l/t.dot(h);return e.add(D.copy(t).multiplyScalar(n)).add(h.multiplyScalar(1-r))}}_updateNearPlaneCorners(){if(o(this._camera)){const e=this._camera,t=e.near,r=e.getEffectiveFOV()*R.MathUtils.DEG2RAD,n=Math.tan(.5*r)*t,o=n*e.aspect;this._nearPlaneCorners[0].set(-o,-n,0),this._nearPlaneCorners[1].set(o,-n,0),this._nearPlaneCorners[2].set(o,n,0),this._nearPlaneCorners[3].set(-o,n,0)}else if(h(this._camera)){const e=this._camera,t=1/e.zoom,r=e.left*t,n=e.right*t,o=e.top*t,h=e.bottom*t;this._nearPlaneCorners[0].set(r,o,0),this._nearPlaneCorners[1].set(n,o,0),this._nearPlaneCorners[2].set(n,h,0),this._nearPlaneCorners[3].set(r,h,0)}}_collisionTest(){let e=1/0;if(!(this.colliderMeshes.length>=1))return e;if(x(this._camera,"_collisionTest"))return e;const t=I.setFromSpherical(this._spherical).divideScalar(this._spherical.radius);K.lookAt(O,t,this._camera.up);for(let i=0;i<4;i++){const r=D.copy(this._nearPlaneCorners[i]);r.applyMatrix4(K);const n=U.addVectors(this._target,r);Z.set(n,t),Z.far=this._spherical.radius+1;const o=Z.intersectObjects(this.colliderMeshes);0!==o.length&&o[0].distance<e&&(e=o[0].distance)}return e}_getClientRect(e){const rect=this._domElement.getBoundingClientRect();return e.x=rect.left,e.y=rect.top,this._viewport?(e.x+=this._viewport.x,e.y+=rect.height-this._viewport.w-this._viewport.y,e.width=this._viewport.z,e.height=this._viewport.w):(e.width=rect.width,e.height=rect.height),e}_createOnRestPromise(e){return e?Promise.resolve():(this._hasRested=!1,this.dispatchEvent({type:"transitionstart"}),new Promise((e=>{const t=()=>{this.removeEventListener("rest",t),e()};this.addEventListener("rest",t)})))}_removeAllEventListeners(){}}},685:function(e,t,r){"use strict";r.d(t,"a",(function(){return m}));var n=r(14),o=r(677),h=r(674),l=r(673);class c extends l.b{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,r){const n=e.getContext(),o=e.state;let h,l;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(h=0,l=1):(h=1,l=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),o.buffers.stencil.setFunc(n.ALWAYS,h,4294967295),o.buffers.stencil.setClear(l),o.buffers.stencil.setLocked(!0),e.setRenderTarget(r),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(n.EQUAL,1,4294967295),o.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),o.buffers.stencil.setLocked(!0)}}class d extends l.b{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class m{constructor(e,t){if(this.renderer=e,void 0===t){const r=e.getSize(new n.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=r.width,this._height=r.height,(t=new n.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===o.a&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===h.a&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new h.a(o.a),this.clock=new n.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let i=e+1;i<this.passes.length;i++)if(this.passes[i].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let r=!1;for(let i=0,t=this.passes.length;i<t;i++){const t=this.passes[i];if(!1!==t.enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(i),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,r),t.needsSwap){if(r){const t=this.renderer.getContext(),r=this.renderer.state.buffers.stencil;r.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),r.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==c&&(t instanceof c?r=!0:t instanceof d&&(r=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new n.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const r=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(r,n),this.renderTarget2.setSize(r,n);for(let i=0;i<this.passes.length;i++)this.passes[i].setSize(r,n)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new n.OrthographicCamera(-1,1,1,-1,0,1);const f=new n.BufferGeometry;f.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),f.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2))}}]);