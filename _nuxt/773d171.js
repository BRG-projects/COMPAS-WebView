(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{684:function(e,t,r){"use strict";r.d(t,"b",(function(){return o})),r.d(t,"a",(function(){return h}));var n=r(17);class o{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const l=new n.OrthographicCamera(-1,1,1,-1,0,1),c=new n.BufferGeometry;c.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),c.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2));class h{constructor(e){this._mesh=new n.Mesh(c,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,l)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}},685:function(e,t,r){"use strict";r.d(t,"a",(function(){return l}));var n=r(17),o=r(684);class l extends o.b{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof n.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=n.UniformsUtils.clone(e.uniforms),this.material=new n.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new o.a(this.material)}render(e,t,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}},687:function(e,t,r){"use strict";var n=r(5),o=r(193);n({target:"String",proto:!0,forced:r(194)("sub")},{sub:function(){return o(this,"sub","","")}})},688:function(e,t,r){"use strict";r.d(t,"a",(function(){return o}));var n=r(17);class o extends n.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new f(e)})),this.register((function(e){return new w(e)})),this.register((function(e){return new S(e)})),this.register((function(e){return new v(e)})),this.register((function(e){return new x(e)})),this.register((function(e){return new M(e)})),this.register((function(e){return new T(e)})),this.register((function(e){return new m(e)})),this.register((function(e){return new y(e)})),this.register((function(e){return new h(e)})),this.register((function(e){return new E(e)}))}load(e,t,r,o){const l=this;let c;c=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:n.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const h=function(t){o?o(t):console.error(t),l.manager.itemError(e),l.manager.itemEnd(e)},d=new n.FileLoader(this.manager);d.setPath(this.path),d.setResponseType("arraybuffer"),d.setRequestHeader(this.requestHeader),d.setWithCredentials(this.withCredentials),d.load(e,(function(data){try{l.parse(data,c,(function(r){t(r),l.manager.itemEnd(e)}),h)}catch(e){h(e)}}),r,h)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(data,path,e,t){let content;const r={},o={};if("string"==typeof data)content=data;else{if(n.LoaderUtils.decodeText(new Uint8Array(data,0,4))===_){try{r[c.KHR_BINARY_GLTF]=new P(data)}catch(e){return void(t&&t(e))}content=r[c.KHR_BINARY_GLTF].content}else content=n.LoaderUtils.decodeText(new Uint8Array(data))}const l=JSON.parse(content);if(void 0===l.asset||l.asset.version[0]<2)return void(t&&t(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const h=new le(l,{path:path||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});h.fileLoader.setRequestHeader(this.requestHeader);for(let i=0;i<this.pluginCallbacks.length;i++){const e=this.pluginCallbacks[i](h);o[e.name]=e,r[e.name]=!0}if(l.extensionsUsed)for(let i=0;i<l.extensionsUsed.length;++i){const e=l.extensionsUsed[i],t=l.extensionsRequired||[];switch(e){case c.KHR_MATERIALS_UNLIT:r[e]=new d;break;case c.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:r[e]=new O;break;case c.KHR_DRACO_MESH_COMPRESSION:r[e]=new C(l,this.dracoLoader);break;case c.KHR_TEXTURE_TRANSFORM:r[e]=new I;break;case c.KHR_MESH_QUANTIZATION:r[e]=new B;break;default:t.indexOf(e)>=0&&void 0===o[e]&&console.warn('THREE.GLTFLoader: Unknown extension "'+e+'".')}}h.setExtensions(r),h.setPlugins(o),h.parse(e,t)}parseAsync(data,path){const e=this;return new Promise((function(t,r){e.parse(data,path,t,r)}))}}function l(){let e={};return{get:function(t){return e[t]},add:function(t,object){e[t]=object},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const c={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class h{constructor(e){this.parser=e,this.name=c.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let r=0,n=t.length;r<n;r++){const n=t[r];n.extensions&&n.extensions[this.name]&&void 0!==n.extensions[this.name].light&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){const t=this.parser,r="light:"+e;let o=t.cache.get(r);if(o)return o;const l=t.json,c=((l.extensions&&l.extensions[this.name]||{}).lights||[])[e];let h;const d=new n.Color(16777215);void 0!==c.color&&d.fromArray(c.color);const m=void 0!==c.range?c.range:0;switch(c.type){case"directional":h=new n.DirectionalLight(d),h.target.position.set(0,0,-1),h.add(h.target);break;case"point":h=new n.PointLight(d),h.distance=m;break;case"spot":h=new n.SpotLight(d),h.distance=m,c.spot=c.spot||{},c.spot.innerConeAngle=void 0!==c.spot.innerConeAngle?c.spot.innerConeAngle:0,c.spot.outerConeAngle=void 0!==c.spot.outerConeAngle?c.spot.outerConeAngle:Math.PI/4,h.angle=c.spot.outerConeAngle,h.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,h.target.position.set(0,0,-1),h.add(h.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return h.position.set(0,0,0),h.decay=2,void 0!==c.intensity&&(h.intensity=c.intensity),h.name=t.createUniqueName(c.name||"light_"+e),o=Promise.resolve(h),t.cache.add(r,o),o}createNodeAttachment(e){const t=this,r=this.parser,n=r.json.nodes[e],o=(n.extensions&&n.extensions[this.name]||{}).light;return void 0===o?null:this._loadLight(o).then((function(e){return r._getNodeRef(t.cache,o,e)}))}}class d{constructor(){this.name=c.KHR_MATERIALS_UNLIT}getMaterialType(){return n.MeshBasicMaterial}extendParams(e,t,r){const o=[];e.color=new n.Color(1,1,1),e.opacity=1;const l=t.pbrMetallicRoughness;if(l){if(Array.isArray(l.baseColorFactor)){const t=l.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==l.baseColorTexture&&o.push(r.assignTexture(e,"map",l.baseColorTexture,n.sRGBEncoding))}return Promise.all(o)}}class m{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name].emissiveStrength;return void 0!==n&&(t.emissiveIntensity=n),Promise.resolve()}}class f{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],c=o.extensions[this.name];if(void 0!==c.clearcoatFactor&&(t.clearcoat=c.clearcoatFactor),void 0!==c.clearcoatTexture&&l.push(r.assignTexture(t,"clearcoatMap",c.clearcoatTexture)),void 0!==c.clearcoatRoughnessFactor&&(t.clearcoatRoughness=c.clearcoatRoughnessFactor),void 0!==c.clearcoatRoughnessTexture&&l.push(r.assignTexture(t,"clearcoatRoughnessMap",c.clearcoatRoughnessTexture)),void 0!==c.clearcoatNormalTexture&&(l.push(r.assignTexture(t,"clearcoatNormalMap",c.clearcoatNormalTexture)),void 0!==c.clearcoatNormalTexture.scale)){const e=c.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new n.Vector2(e,e)}return Promise.all(l)}}class v{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[];t.sheenColor=new n.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const c=o.extensions[this.name];return void 0!==c.sheenColorFactor&&t.sheenColor.fromArray(c.sheenColorFactor),void 0!==c.sheenRoughnessFactor&&(t.sheenRoughness=c.sheenRoughnessFactor),void 0!==c.sheenColorTexture&&l.push(r.assignTexture(t,"sheenColorMap",c.sheenColorTexture,n.sRGBEncoding)),void 0!==c.sheenRoughnessTexture&&l.push(r.assignTexture(t,"sheenRoughnessMap",c.sheenRoughnessTexture)),Promise.all(l)}}class x{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,n=r.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[],l=n.extensions[this.name];return void 0!==l.transmissionFactor&&(t.transmission=l.transmissionFactor),void 0!==l.transmissionTexture&&o.push(r.assignTexture(t,"transmissionMap",l.transmissionTexture)),Promise.all(o)}}class M{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],c=o.extensions[this.name];t.thickness=void 0!==c.thicknessFactor?c.thicknessFactor:0,void 0!==c.thicknessTexture&&l.push(r.assignTexture(t,"thicknessMap",c.thicknessTexture)),t.attenuationDistance=c.attenuationDistance||0;const h=c.attenuationColor||[1,1,1];return t.attenuationColor=new n.Color(h[0],h[1],h[2]),Promise.all(l)}}class T{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const n=r.extensions[this.name];return t.ior=void 0!==n.ior?n.ior:1.5,Promise.resolve()}}class y{constructor(e){this.parser=e,this.name=c.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?n.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser,o=r.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const l=[],c=o.extensions[this.name];t.specularIntensity=void 0!==c.specularFactor?c.specularFactor:1,void 0!==c.specularTexture&&l.push(r.assignTexture(t,"specularIntensityMap",c.specularTexture));const h=c.specularColorFactor||[1,1,1];return t.specularColor=new n.Color(h[0],h[1],h[2]),void 0!==c.specularColorTexture&&l.push(r.assignTexture(t,"specularColorMap",c.specularColorTexture,n.sRGBEncoding)),Promise.all(l)}}class w{constructor(e){this.parser=e,this.name=c.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,r=t.json,n=r.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name],l=t.options.ktx2Loader;if(!l){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,o.source,l)}}class S{constructor(e){this.parser=e,this.name=c.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,r=this.parser,n=r.json,o=n.textures[e];if(!o.extensions||!o.extensions[t])return null;const l=o.extensions[t],source=n.images[l.source];let c=r.textureLoader;if(source.uri){const e=r.options.manager.getHandler(source.uri);null!==e&&(c=e)}return this.detectSupport().then((function(o){if(o)return r.loadTextureImage(e,l.source,c);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",image.onload=image.onerror=function(){e(1===image.height)}}))),this.isSupported}}class E{constructor(e){this.name=c.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,r=t.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const e=r.extensions[this.name],n=this.parser.getDependency("buffer",e.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([n,o.ready]).then((function(t){const r=e.byteOffset||0,n=e.byteLength||0,l=e.count,c=e.byteStride,h=new ArrayBuffer(l*c),source=new Uint8Array(t[0],r,n);return o.decodeGltfBuffer(new Uint8Array(h),l,c,source,e.mode,e.filter),h}))}return null}}const _="glTF",R=1313821514,A=5130562;class P{constructor(data){this.name=c.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(data,0,12);if(this.header={magic:n.LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==_)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const t=this.header.length-12,r=new DataView(data,12);let o=0;for(;o<t;){const e=r.getUint32(o,!0);o+=4;const t=r.getUint32(o,!0);if(o+=4,t===R){const t=new Uint8Array(data,12+o,e);this.content=n.LoaderUtils.decodeText(t)}else if(t===A){const t=12+o;this.body=data.slice(t,t+e)}o+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class C{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=c.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const r=this.json,n=this.dracoLoader,o=e.extensions[this.name].bufferView,l=e.extensions[this.name].attributes,c={},h={},d={};for(const e in l){const t=W[e]||e.toLowerCase();c[t]=l[e]}for(const t in e.attributes){const n=W[t]||t.toLowerCase();if(void 0!==l[t]){const o=r.accessors[e.attributes[t]],l=X[o.componentType];d[n]=l,h[n]=!0===o.normalized}}return t.getDependency("bufferView",o).then((function(e){return new Promise((function(t){n.decodeDracoFile(e,(function(e){for(const t in e.attributes){const r=e.attributes[t],n=h[t];void 0!==n&&(r.normalized=n)}t(e)}),c,d)}))}))}}class I{constructor(){this.name=c.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class L extends n.MeshStandardMaterial{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),r=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),o=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),l=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),c=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),h={specular:{value:(new n.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=h,this.onBeforeCompile=function(e){for(const t in h)e.uniforms[t]=h[t];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",r).replace("#include <roughnessmap_fragment>",o).replace("#include <metalnessmap_fragment>",l).replace("#include <lights_physical_fragment>",c)},Object.defineProperties(this,{specular:{get:function(){return h.specular.value},set:function(e){h.specular.value=e}},specularMap:{get:function(){return h.specularMap.value},set:function(e){h.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return h.glossiness.value},set:function(e){h.glossiness.value=e}},glossinessMap:{get:function(){return h.glossinessMap.value},set:function(e){h.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(source){return super.copy(source),this.specularMap=source.specularMap,this.specular.copy(source.specular),this.glossinessMap=source.glossinessMap,this.glossiness=source.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class O{constructor(){this.name=c.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return L}extendParams(e,t,r){const o=t.extensions[this.name];e.color=new n.Color(1,1,1),e.opacity=1;const l=[];if(Array.isArray(o.diffuseFactor)){const t=o.diffuseFactor;e.color.fromArray(t),e.opacity=t[3]}if(void 0!==o.diffuseTexture&&l.push(r.assignTexture(e,"map",o.diffuseTexture,n.sRGBEncoding)),e.emissive=new n.Color(0,0,0),e.glossiness=void 0!==o.glossinessFactor?o.glossinessFactor:1,e.specular=new n.Color(1,1,1),Array.isArray(o.specularFactor)&&e.specular.fromArray(o.specularFactor),void 0!==o.specularGlossinessTexture){const t=o.specularGlossinessTexture;l.push(r.assignTexture(e,"glossinessMap",t)),l.push(r.assignTexture(e,"specularMap",t,n.sRGBEncoding))}return Promise.all(l)}createMaterial(e){const t=new L(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=void 0===e.emissiveIntensity?1:e.emissiveIntensity,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=n.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t}}class B{constructor(){this.name=c.KHR_MESH_QUANTIZATION}}class D extends n.Interpolant{constructor(e,t,r,n){super(e,t,r,n)}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,n=this.valueSize,o=e*n*3+n;for(let i=0;i!==n;i++)t[i]=r[o+i];return t}}D.prototype.beforeStart_=D.prototype.copySampleValue_,D.prototype.afterEnd_=D.prototype.copySampleValue_,D.prototype.interpolate_=function(e,t,r,n){const o=this.resultBuffer,l=this.sampleValues,c=this.valueSize,h=2*c,d=3*c,td=n-t,p=(r-t)/td,m=p*p,f=m*p,v=e*d,x=v-d,M=-2*f+3*m,T=f-m,y=1-M,w=T-m+p;for(let i=0;i!==c;i++){const e=l[x+i+c],t=l[x+i+h]*td,r=l[v+i+c],n=l[v+i]*td;o[i]=y*e+w*t+M*r+T*n}return o};const N=new n.Quaternion;class F extends D{interpolate_(e,t,r,n){const o=super.interpolate_(e,t,r,n);return N.fromArray(o).normalize().toArray(o),o}}const U=0,k=1,H=2,G=3,V=4,j=5,Q=6,X={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},z={9728:n.NearestFilter,9729:n.LinearFilter,9984:n.NearestMipmapNearestFilter,9985:n.LinearMipmapNearestFilter,9986:n.NearestMipmapLinearFilter,9987:n.LinearMipmapLinearFilter},Y={33071:n.ClampToEdgeWrapping,33648:n.MirroredRepeatWrapping,10497:n.RepeatWrapping},K={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},W={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Z={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},J={CUBICSPLINE:void 0,LINEAR:n.InterpolateLinear,STEP:n.InterpolateDiscrete},$="OPAQUE",ee="MASK",te="BLEND";function se(e,object,t){for(const r in t.extensions)void 0===e[r]&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[r]=t.extensions[r])}function re(object,e){void 0!==e.extras&&("object"==typeof e.extras?Object.assign(object.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function ne(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let i=0,r=t.weights.length;i<r;i++)e.morphTargetInfluences[i]=t.weights[i];if(t.extras&&Array.isArray(t.extras.targetNames)){const r=t.extras.targetNames;if(e.morphTargetInfluences.length===r.length){e.morphTargetDictionary={};for(let i=0,t=r.length;i<t;i++)e.morphTargetDictionary[r[i]]=i}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ie(e){const t=e.extensions&&e.extensions[c.KHR_DRACO_MESH_COMPRESSION];let r;return r=t?"draco:"+t.bufferView+":"+t.indices+":"+ae(t.attributes):e.indices+":"+ae(e.attributes)+":"+e.mode,r}function ae(e){let t="";const r=Object.keys(e).sort();for(let i=0,n=r.length;i<n;i++)t+=r[i]+":"+e[r[i]]+";";return t}function oe(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class le{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new l,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const r=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),o=navigator.userAgent.indexOf("Firefox")>-1,c=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||r||o&&c<98?this.textureLoader=new n.TextureLoader(this.options.manager):this.textureLoader=new n.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new n.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const r=this,n=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])})).then((function(t){const l={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:r,userData:{}};se(o,l,n),re(l,n),Promise.all(r._invokeAll((function(e){return e.afterRoot&&e.afterRoot(l)}))).then((function(){e(l)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],r=this.json.meshes||[];for(let r=0,n=t.length;r<n;r++){const n=t[r].joints;for(let i=0,t=n.length;i<t;i++)e[n[i]].isBone=!0}for(let t=0,n=e.length;t<n;t++){const n=e[t];void 0!==n.mesh&&(this._addNodeRef(this.meshCache,n.mesh),void 0!==n.skin&&(r[n.mesh].isSkinnedMesh=!0)),void 0!==n.camera&&this._addNodeRef(this.cameraCache,n.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,object){if(e.refs[t]<=1)return object;const r=object.clone(),n=(e,t)=>{const r=this.associations.get(e);null!=r&&this.associations.set(t,r);for(const[i,r]of e.children.entries())n(r,t.children[i])};return n(object,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const r=[];for(let i=0;i<t.length;i++){const n=e(t[i]);n&&r.push(n)}return r}getDependency(e,t){const r=e+":"+t;let n=this.cache.get(r);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this.loadNode(t);break;case"mesh":n=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":n=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":n=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(r,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const r=this,defs=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(defs.map((function(t,n){return r.getDependency(e,n)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],r=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[c.KHR_BINARY_GLTF].body);const o=this.options;return new Promise((function(e,l){r.load(n.LoaderUtils.resolveURL(t.uri,o.path),e,void 0,(function(){l(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const r=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+r)}))}loadAccessor(e){const t=this,r=this.json,o=this.json.accessors[e];if(void 0===o.bufferView&&void 0===o.sparse)return Promise.resolve(null);const l=[];return void 0!==o.bufferView?l.push(this.getDependency("bufferView",o.bufferView)):l.push(null),void 0!==o.sparse&&(l.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),l.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(l).then((function(e){const l=e[0],c=K[o.type],h=X[o.componentType],d=h.BYTES_PER_ELEMENT,m=d*c,f=o.byteOffset||0,v=void 0!==o.bufferView?r.bufferViews[o.bufferView].byteStride:void 0,x=!0===o.normalized;let M,T;if(v&&v!==m){const e=Math.floor(f/v),r="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+e+":"+o.count;let m=t.cache.get(r);m||(M=new h(l,e*v,o.count*v/d),m=new n.InterleavedBuffer(M,v/d),t.cache.add(r,m)),T=new n.InterleavedBufferAttribute(m,c,f%v/d,x)}else M=null===l?new h(o.count*c):new h(l,f,o.count*c),T=new n.BufferAttribute(M,c,x);if(void 0!==o.sparse){const t=K.SCALAR,r=X[o.sparse.indices.componentType],d=o.sparse.indices.byteOffset||0,m=o.sparse.values.byteOffset||0,f=new r(e[1],d,o.sparse.count*t),v=new h(e[2],m,o.sparse.count*c);null!==l&&(T=new n.BufferAttribute(T.array.slice(),T.itemSize,T.normalized));for(let i=0,e=f.length;i<e;i++){const e=f[i];if(T.setX(e,v[i*c]),c>=2&&T.setY(e,v[i*c+1]),c>=3&&T.setZ(e,v[i*c+2]),c>=4&&T.setW(e,v[i*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return T}))}loadTexture(e){const t=this.json,r=this.options,n=t.textures[e].source,o=t.images[n];let l=this.textureLoader;if(o.uri){const e=r.manager.getHandler(o.uri);null!==e&&(l=e)}return this.loadTextureImage(e,n,l)}loadTextureImage(e,t,r){const o=this,l=this.json,c=l.textures[e],h=l.images[t],d=(h.uri||h.bufferView)+":"+c.sampler;if(this.textureCache[d])return this.textureCache[d];const m=this.loadImageSource(t,r).then((function(t){t.flipY=!1,c.name&&(t.name=c.name);const r=(l.samplers||{})[c.sampler]||{};return t.magFilter=z[r.magFilter]||n.LinearFilter,t.minFilter=z[r.minFilter]||n.LinearMipmapLinearFilter,t.wrapS=Y[r.wrapS]||n.RepeatWrapping,t.wrapT=Y[r.wrapT]||n.RepeatWrapping,o.associations.set(t,{textures:e}),t})).catch((function(){return null}));return this.textureCache[d]=m,m}loadImageSource(e,t){const r=this,o=this.json,l=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then((e=>e.clone()));const c=o.images[e],h=self.URL||self.webkitURL;let d=c.uri||"",m=!1;if(void 0!==c.bufferView)d=r.getDependency("bufferView",c.bufferView).then((function(e){m=!0;const t=new Blob([e],{type:c.mimeType});return d=h.createObjectURL(t),d}));else if(void 0===c.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const f=Promise.resolve(d).then((function(e){return new Promise((function(r,o){let c=r;!0===t.isImageBitmapLoader&&(c=function(e){const t=new n.Texture(e);t.needsUpdate=!0,r(t)}),t.load(n.LoaderUtils.resolveURL(e,l.path),c,void 0,o)}))})).then((function(e){var t;return!0===m&&h.revokeObjectURL(d),e.userData.mimeType=c.mimeType||((t=c.uri).search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/)?"image/jpeg":t.search(/\.webp($|\?)/i)>0||0===t.search(/^data\:image\/webp/)?"image/webp":"image/png"),e})).catch((function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",d),e}));return this.sourceCache[e]=f,f}assignTexture(e,t,r,n){const o=this;return this.getDependency("texture",r.index).then((function(l){if(void 0===r.texCoord||0==r.texCoord||"aoMap"===t&&1==r.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+t+" not yet supported."),o.extensions[c.KHR_TEXTURE_TRANSFORM]){const e=void 0!==r.extensions?r.extensions[c.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=o.associations.get(l);l=o.extensions[c.KHR_TEXTURE_TRANSFORM].extendTexture(l,e),o.associations.set(l,t)}}return void 0!==n&&(l.encoding=n),e[t]=l,l}))}assignFinalMaterial(e){const t=e.geometry;let r=e.material;const o=void 0===t.attributes.tangent,l=void 0!==t.attributes.color,c=void 0===t.attributes.normal;if(e.isPoints){const e="PointsMaterial:"+r.uuid;let t=this.cache.get(e);t||(t=new n.PointsMaterial,n.Material.prototype.copy.call(t,r),t.color.copy(r.color),t.map=r.map,t.sizeAttenuation=!1,this.cache.add(e,t)),r=t}else if(e.isLine){const e="LineBasicMaterial:"+r.uuid;let t=this.cache.get(e);t||(t=new n.LineBasicMaterial,n.Material.prototype.copy.call(t,r),t.color.copy(r.color),this.cache.add(e,t)),r=t}if(o||l||c){let e="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),o&&(e+="derivative-tangents:"),l&&(e+="vertex-colors:"),c&&(e+="flat-shading:");let t=this.cache.get(e);t||(t=r.clone(),l&&(t.vertexColors=!0),c&&(t.flatShading=!0),o&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(r))),r=t}r.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=r}getMaterialType(){return n.MeshStandardMaterial}loadMaterial(e){const t=this,r=this.json,o=this.extensions,l=r.materials[e];let h;const d={},m=l.extensions||{},f=[];if(m[c.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const e=o[c.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];h=e.getMaterialType(),f.push(e.extendParams(d,l,t))}else if(m[c.KHR_MATERIALS_UNLIT]){const e=o[c.KHR_MATERIALS_UNLIT];h=e.getMaterialType(),f.push(e.extendParams(d,l,t))}else{const r=l.pbrMetallicRoughness||{};if(d.color=new n.Color(1,1,1),d.opacity=1,Array.isArray(r.baseColorFactor)){const e=r.baseColorFactor;d.color.fromArray(e),d.opacity=e[3]}void 0!==r.baseColorTexture&&f.push(t.assignTexture(d,"map",r.baseColorTexture,n.sRGBEncoding)),d.metalness=void 0!==r.metallicFactor?r.metallicFactor:1,d.roughness=void 0!==r.roughnessFactor?r.roughnessFactor:1,void 0!==r.metallicRoughnessTexture&&(f.push(t.assignTexture(d,"metalnessMap",r.metallicRoughnessTexture)),f.push(t.assignTexture(d,"roughnessMap",r.metallicRoughnessTexture))),h=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),f.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,d)}))))}!0===l.doubleSided&&(d.side=n.DoubleSide);const v=l.alphaMode||$;if(v===te?(d.transparent=!0,d.depthWrite=!1):(d.transparent=!1,v===ee&&(d.alphaTest=void 0!==l.alphaCutoff?l.alphaCutoff:.5)),void 0!==l.normalTexture&&h!==n.MeshBasicMaterial&&(f.push(t.assignTexture(d,"normalMap",l.normalTexture)),d.normalScale=new n.Vector2(1,1),void 0!==l.normalTexture.scale)){const e=l.normalTexture.scale;d.normalScale.set(e,e)}return void 0!==l.occlusionTexture&&h!==n.MeshBasicMaterial&&(f.push(t.assignTexture(d,"aoMap",l.occlusionTexture)),void 0!==l.occlusionTexture.strength&&(d.aoMapIntensity=l.occlusionTexture.strength)),void 0!==l.emissiveFactor&&h!==n.MeshBasicMaterial&&(d.emissive=(new n.Color).fromArray(l.emissiveFactor)),void 0!==l.emissiveTexture&&h!==n.MeshBasicMaterial&&f.push(t.assignTexture(d,"emissiveMap",l.emissiveTexture,n.sRGBEncoding)),Promise.all(f).then((function(){let r;return r=h===L?o[c.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(d):new h(d),l.name&&(r.name=l.name),re(r,l),t.associations.set(r,{materials:e}),l.extensions&&se(o,r,l),r}))}createUniqueName(e){const t=n.PropertyBinding.sanitizeNodeName(e||"");let r=t;for(let i=1;this.nodeNamesUsed[r];++i)r=t+"_"+i;return this.nodeNamesUsed[r]=!0,r}loadGeometries(e){const t=this,r=this.extensions,o=this.primitiveCache;function l(e){return r[c.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(r){return he(r,e,t)}))}const h=[];for(let i=0,r=e.length;i<r;i++){const r=e[i],d=ie(r),m=o[d];if(m)h.push(m.promise);else{let e;e=r.extensions&&r.extensions[c.KHR_DRACO_MESH_COMPRESSION]?l(r):he(new n.BufferGeometry,r,t),o[d]={primitive:r,promise:e},h.push(e)}}return Promise.all(h)}loadMesh(e){const t=this,r=this.json,o=this.extensions,l=r.meshes[e],c=l.primitives,h=[];for(let i=0,e=c.length;i<e;i++){const e=void 0===c[i].material?(void 0===(d=this.cache).DefaultMaterial&&(d.DefaultMaterial=new n.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:n.FrontSide})),d.DefaultMaterial):this.getDependency("material",c[i].material);h.push(e)}var d;return h.push(t.loadGeometries(c)),Promise.all(h).then((function(r){const h=r.slice(0,r.length-1),d=r[r.length-1],m=[];for(let i=0,r=d.length;i<r;i++){const r=d[i],f=c[i];let v;const x=h[i];if(f.mode===V||f.mode===j||f.mode===Q||void 0===f.mode)v=!0===l.isSkinnedMesh?new n.SkinnedMesh(r,x):new n.Mesh(r,x),!0!==v.isSkinnedMesh||v.geometry.attributes.skinWeight.normalized||v.normalizeSkinWeights(),f.mode===j?v.geometry=ue(v.geometry,n.TriangleStripDrawMode):f.mode===Q&&(v.geometry=ue(v.geometry,n.TriangleFanDrawMode));else if(f.mode===k)v=new n.LineSegments(r,x);else if(f.mode===G)v=new n.Line(r,x);else if(f.mode===H)v=new n.LineLoop(r,x);else{if(f.mode!==U)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+f.mode);v=new n.Points(r,x)}Object.keys(v.geometry.morphAttributes).length>0&&ne(v,l),v.name=t.createUniqueName(l.name||"mesh_"+e),re(v,l),f.extensions&&se(o,v,f),t.assignFinalMaterial(v),m.push(v)}for(let i=0,r=m.length;i<r;i++)t.associations.set(m[i],{meshes:e,primitives:i});if(1===m.length)return m[0];const f=new n.Group;t.associations.set(f,{meshes:e});for(let i=0,e=m.length;i<e;i++)f.add(m[i]);return f}))}loadCamera(e){let t;const r=this.json.cameras[e],o=r[r.type];if(o)return"perspective"===r.type?t=new n.PerspectiveCamera(n.MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):"orthographic"===r.type&&(t=new n.OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),r.name&&(t.name=this.createUniqueName(r.name)),re(t,r),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],r={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(r):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return r.inverseBindMatrices=e,r}))}loadAnimation(e){const t=this.json.animations[e],r=[],o=[],l=[],c=[],h=[];for(let i=0,e=t.channels.length;i<e;i++){const e=t.channels[i],n=t.samplers[e.sampler],d=e.target,m=void 0!==d.node?d.node:d.id,input=void 0!==t.parameters?t.parameters[n.input]:n.input,output=void 0!==t.parameters?t.parameters[n.output]:n.output;r.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",input)),l.push(this.getDependency("accessor",output)),c.push(n),h.push(d)}return Promise.all([Promise.all(r),Promise.all(o),Promise.all(l),Promise.all(c),Promise.all(h)]).then((function(r){const o=r[0],l=r[1],c=r[2],h=r[3],d=r[4],m=[];for(let i=0,e=o.length;i<e;i++){const e=o[i],t=l[i],r=c[i],f=h[i],v=d[i];if(void 0===e)continue;let x;switch(e.updateMatrix(),e.matrixAutoUpdate=!0,Z[v.path]){case Z.weights:x=n.NumberKeyframeTrack;break;case Z.rotation:x=n.QuaternionKeyframeTrack;break;default:x=n.VectorKeyframeTrack}const M=e.name?e.name:e.uuid,T=void 0!==f.interpolation?J[f.interpolation]:n.InterpolateLinear,y=[];Z[v.path]===Z.weights?e.traverse((function(object){object.morphTargetInfluences&&y.push(object.name?object.name:object.uuid)})):y.push(M);let w=r.array;if(r.normalized){const e=oe(w.constructor),t=new Float32Array(w.length);for(let r=0,n=w.length;r<n;r++)t[r]=w[r]*e;w=t}for(let e=0,r=y.length;e<r;e++){const track=new x(y[e]+"."+Z[v.path],t.array,w,T);"CUBICSPLINE"===f.interpolation&&(track.createInterpolant=function(e){return new(this instanceof n.QuaternionKeyframeTrack?F:D)(this.times,this.values,this.getValueSize()/3,e)},track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(track)}}const f=t.name?t.name:"animation_"+e;return new n.AnimationClip(f,void 0,m)}))}createNodeMesh(e){const t=this.json,r=this,n=t.nodes[e];return void 0===n.mesh?null:r.getDependency("mesh",n.mesh).then((function(e){const t=r._getNodeRef(r.meshCache,n.mesh,e);return void 0!==n.weights&&t.traverse((function(e){if(e.isMesh)for(let i=0,t=n.weights.length;i<t;i++)e.morphTargetInfluences[i]=n.weights[i]})),t}))}loadNode(e){const t=this.json,r=this.extensions,o=this,l=t.nodes[e],c=l.name?o.createUniqueName(l.name):"";return function(){const t=[],r=o._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return r&&t.push(r),void 0!==l.camera&&t.push(o.getDependency("camera",l.camera).then((function(e){return o._getNodeRef(o.cameraCache,l.camera,e)}))),o._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){t.push(e)})),Promise.all(t)}().then((function(t){let h;if(h=!0===l.isBone?new n.Bone:t.length>1?new n.Group:1===t.length?t[0]:new n.Object3D,h!==t[0])for(let i=0,e=t.length;i<e;i++)h.add(t[i]);if(l.name&&(h.userData.name=l.name,h.name=c),re(h,l),l.extensions&&se(r,h,l),void 0!==l.matrix){const e=new n.Matrix4;e.fromArray(l.matrix),h.applyMatrix4(e)}else void 0!==l.translation&&h.position.fromArray(l.translation),void 0!==l.rotation&&h.quaternion.fromArray(l.rotation),void 0!==l.scale&&h.scale.fromArray(l.scale);return o.associations.has(h)||o.associations.set(h,{}),o.associations.get(h).nodes=e,h}))}loadScene(e){const t=this.json,r=this.extensions,o=this.json.scenes[e],l=this,c=new n.Group;o.name&&(c.name=l.createUniqueName(o.name)),re(c,o),o.extensions&&se(r,c,o);const h=o.nodes||[],d=[];for(let i=0,e=h.length;i<e;i++)d.push(ce(h[i],c,t,l));return Promise.all(d).then((function(){return l.associations=(e=>{const t=new Map;for(const[e,r]of l.associations)(e instanceof n.Material||e instanceof n.Texture)&&t.set(e,r);return e.traverse((e=>{const r=l.associations.get(e);null!=r&&t.set(e,r)})),t})(c),c}))}}function ce(e,t,r,o){const l=r.nodes[e];return o.getDependency("node",e).then((function(e){if(void 0===l.skin)return e;let t;return o.getDependency("skin",l.skin).then((function(e){t=e;const r=[];for(let i=0,e=t.joints.length;i<e;i++)r.push(o.getDependency("node",t.joints[i]));return Promise.all(r)})).then((function(r){return e.traverse((function(e){if(!e.isMesh)return;const o=[],l=[];for(let e=0,c=r.length;e<c;e++){const c=r[e];if(c){o.push(c);const r=new n.Matrix4;void 0!==t.inverseBindMatrices&&r.fromArray(t.inverseBindMatrices.array,16*e),l.push(r)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}e.bind(new n.Skeleton(o,l),e.matrixWorld)})),e}))})).then((function(e){t.add(e);const n=[];if(l.children){const t=l.children;for(let i=0,l=t.length;i<l;i++){const l=t[i];n.push(ce(l,e,r,o))}}return Promise.all(n)}))}function he(e,t,r){const o=t.attributes,l=[];function c(t,n){return r.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(const t in o){const r=W[t]||t.toLowerCase();r in e.attributes||l.push(c(o[t],r))}if(void 0!==t.indices&&!e.index){const n=r.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));l.push(n)}return re(e,t),function(e,t,r){const o=t.attributes,l=new n.Box3;if(void 0===o.POSITION)return;{const e=r.json.accessors[o.POSITION],t=e.min,c=e.max;if(void 0===t||void 0===c)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(l.set(new n.Vector3(t[0],t[1],t[2]),new n.Vector3(c[0],c[1],c[2])),e.normalized){const t=oe(X[e.componentType]);l.min.multiplyScalar(t),l.max.multiplyScalar(t)}}const c=t.targets;if(void 0!==c){const e=new n.Vector3,t=new n.Vector3;for(let i=0,n=c.length;i<n;i++){const n=c[i];if(void 0!==n.POSITION){const o=r.json.accessors[n.POSITION],l=o.min,c=o.max;if(void 0!==l&&void 0!==c){if(t.setX(Math.max(Math.abs(l[0]),Math.abs(c[0]))),t.setY(Math.max(Math.abs(l[1]),Math.abs(c[1]))),t.setZ(Math.max(Math.abs(l[2]),Math.abs(c[2]))),o.normalized){const e=oe(X[o.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}l.expandByVector(e)}e.boundingBox=l;const h=new n.Sphere;l.getCenter(h.center),h.radius=l.min.distanceTo(l.max)/2,e.boundingSphere=h}(e,t,r),Promise.all(l).then((function(){return void 0!==t.targets?function(e,t,r){let n=!1,o=!1,l=!1;for(let i=0,e=t.length;i<e;i++){const e=t[i];if(void 0!==e.POSITION&&(n=!0),void 0!==e.NORMAL&&(o=!0),void 0!==e.COLOR_0&&(l=!0),n&&o&&l)break}if(!n&&!o&&!l)return Promise.resolve(e);const c=[],h=[],d=[];for(let i=0,m=t.length;i<m;i++){const m=t[i];if(n){const t=void 0!==m.POSITION?r.getDependency("accessor",m.POSITION):e.attributes.position;c.push(t)}if(o){const t=void 0!==m.NORMAL?r.getDependency("accessor",m.NORMAL):e.attributes.normal;h.push(t)}if(l){const t=void 0!==m.COLOR_0?r.getDependency("accessor",m.COLOR_0):e.attributes.color;d.push(t)}}return Promise.all([Promise.all(c),Promise.all(h),Promise.all(d)]).then((function(t){const r=t[0],c=t[1],h=t[2];return n&&(e.morphAttributes.position=r),o&&(e.morphAttributes.normal=c),l&&(e.morphAttributes.color=h),e.morphTargetsRelative=!0,e}))}(e,t.targets,r):e}))}function ue(e,t){let r=e.getIndex();if(null===r){const t=[],n=e.getAttribute("position");if(void 0===n)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let i=0;i<n.count;i++)t.push(i);e.setIndex(t),r=e.getIndex()}const o=r.count-2,l=[];if(t===n.TriangleFanDrawMode)for(let i=1;i<=o;i++)l.push(r.getX(0)),l.push(r.getX(i)),l.push(r.getX(i+1));else for(let i=0;i<o;i++)i%2==0?(l.push(r.getX(i)),l.push(r.getX(i+1)),l.push(r.getX(i+2))):(l.push(r.getX(i+2)),l.push(r.getX(i+1)),l.push(r.getX(i)));l.length/3!==o&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const c=e.clone();return c.setIndex(l),c}},689:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"}},690:function(e,t,r){"use strict";r.d(t,"a",(function(){return l}));var n=r(17),o=r(684);class l extends o.b{constructor(e,t,r,o,l){super(),this.scene=e,this.camera=t,this.overrideMaterial=r,this.clearColor=o,this.clearAlpha=void 0!==l?l:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new n.Color}render(e,t,r){const n=e.autoClear;let o,l;e.autoClear=!1,void 0!==this.overrideMaterial&&(l=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),o=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:r),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,o),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=l),e.autoClear=n}}},691:function(e,t,r){"use strict";r.d(t,"a",(function(){return c}));var n=r(17),o=r(684),l=r(689);class c extends o.b{constructor(e,t,r,c){super(),this.renderScene=t,this.renderCamera=r,this.selectedObjects=void 0!==c?c:[],this.visibleEdgeColor=new n.Color(1,1,1),this.hiddenEdgeColor=new n.Color(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=void 0!==e?new n.Vector2(e.x,e.y):new n.Vector2(256,256);const h=Math.round(this.resolution.x/this.downSampleRatio),d=Math.round(this.resolution.y/this.downSampleRatio);this.renderTargetMaskBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new n.MeshDepthMaterial,this.depthMaterial.side=n.DoubleSide,this.depthMaterial.depthPacking=n.RGBADepthPacking,this.depthMaterial.blending=n.NoBlending,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=n.DoubleSide,this.prepareMaskMaterial.fragmentShader=function(e,t){const r=t.isPerspectiveCamera?"perspective":"orthographic";return e.replace(/DEPTH_TO_VIEW_Z/g,r+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new n.WebGLRenderTarget(this.resolution.x,this.resolution.y),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new n.WebGLRenderTarget(h,d),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new n.WebGLRenderTarget(h,d),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new n.WebGLRenderTarget(Math.round(h/2),Math.round(d/2)),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new n.WebGLRenderTarget(h,d),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new n.WebGLRenderTarget(Math.round(h/2),Math.round(d/2)),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(h,d),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(h/2),Math.round(d/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===l.a&&console.error("THREE.OutlinePass relies on CopyShader");const m=l.a;this.copyUniforms=n.UniformsUtils.clone(m.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new n.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,blending:n.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new n.Color,this.oldClearAlpha=1,this.fsQuad=new o.a(null),this.tempPulseColor1=new n.Color,this.tempPulseColor2=new n.Color,this.textureMatrix=new n.Matrix4}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t),this.renderTargetDepthBuffer.setSize(e,t);let r=Math.round(e/this.downSampleRatio),n=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(r,n),this.renderTargetBlurBuffer1.setSize(r,n),this.renderTargetEdgeBuffer1.setSize(r,n),this.separableBlurMaterial1.uniforms.texSize.value.set(r,n),r=Math.round(r/2),n=Math.round(n/2),this.renderTargetBlurBuffer2.setSize(r,n),this.renderTargetEdgeBuffer2.setSize(r,n),this.separableBlurMaterial2.uniforms.texSize.value.set(r,n)}changeVisibilityOfSelectedObjects(e){const t=this._visibilityCache;function r(object){object.isMesh&&(!0===e?object.visible=t.get(object):(t.set(object,object.visible),object.visible=e))}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(r)}}changeVisibilityOfNonSelectedObjects(e){const t=this._visibilityCache,r=[];function n(object){object.isMesh&&r.push(object)}for(let i=0;i<this.selectedObjects.length;i++){this.selectedObjects[i].traverse(n)}this.renderScene.traverse((function(object){if(object.isMesh||object.isSprite){let n=!1;for(let i=0;i<r.length;i++){if(r[i].id===object.id){n=!0;break}}if(!1===n){const r=object.visible;!1!==e&&!0!==t.get(object)||(object.visible=e),t.set(object,r)}}else(object.isPoints||object.isLine)&&(!0===e?object.visible=t.get(object):(t.set(object,object.visible),object.visible=e))}))}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(e,t,r,n,o){if(this.selectedObjects.length>0){e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const t=e.autoClear;e.autoClear=!1,o&&e.state.buffers.stencil.setTest(!1),e.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const n=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=n,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const e=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(e),this.tempPulseColor2.multiplyScalar(e)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=c.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=c.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=c.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=c.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,o&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(r),this.fsQuad.render(e),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=t}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=r.texture,e.setRenderTarget(null),this.fsQuad.render(e))}getPrepareMaskMaterial(){return new n.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new n.Vector2(.5,.5)},textureMatrix:{value:null}},vertexShader:"#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",fragmentShader:"#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}"})}getEdgeDetectionMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},visibleEdgeColor:{value:new n.Vector3(1,1,1)},hiddenEdgeColor:{value:new n.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}"})}getSeperableBlurMaterial(e){return new n.ShaderMaterial({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},direction:{value:new n.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}"})}getOverlayMaterial(){return new n.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",blending:n.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}}c.BlurDirectionX=new n.Vector2(1,0),c.BlurDirectionY=new n.Vector2(0,1)},692:function(e,t,r){"use strict";r.d(t,"a",(function(){return n}));const n={uniforms:{tDiffuse:{value:null},resolution:{value:new(r(17).Vector2)(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t"}},693:function(e,t,r){"use strict";r.d(t,"a",(function(){return M}));var n=r(17);const o=new n.Raycaster,l=new n.Vector3,c=new n.Vector3,h=new n.Quaternion,d={X:new n.Vector3(1,0,0),Y:new n.Vector3(0,1,0),Z:new n.Vector3(0,0,1)},m={type:"change"},f={type:"mouseDown"},v={type:"mouseUp",mode:null},x={type:"objectChange"};class M extends n.Object3D{constructor(e,t){super(),void 0===t&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.visible=!1,this.domElement=t,this.domElement.style.touchAction="none";const r=new G;this._gizmo=r,this.add(r);const o=new V;this._plane=o,this.add(o);const l=this;function c(e,t){let n=t;Object.defineProperty(l,e,{get:function(){return void 0!==n?n:t},set:function(t){n!==t&&(n=t,o[e]=t,r[e]=t,l.dispatchEvent({type:e+"-changed",value:t}),l.dispatchEvent(m))}}),l[e]=t,o[e]=t,r[e]=t}c("camera",e),c("object",void 0),c("enabled",!0),c("axis",null),c("mode","translate"),c("translationSnap",null),c("rotationSnap",null),c("scaleSnap",null),c("space","world"),c("size",1),c("dragging",!1),c("showX",!0),c("showY",!0),c("showZ",!0);const h=new n.Vector3,d=new n.Vector3,f=new n.Quaternion,v=new n.Quaternion,x=new n.Vector3,M=new n.Quaternion,_=new n.Vector3,R=new n.Vector3,A=new n.Vector3,P=new n.Vector3;c("worldPosition",h),c("worldPositionStart",d),c("worldQuaternion",f),c("worldQuaternionStart",v),c("cameraPosition",x),c("cameraQuaternion",M),c("pointStart",_),c("pointEnd",R),c("rotationAxis",A),c("rotationAngle",0),c("eye",P),this._offset=new n.Vector3,this._startNorm=new n.Vector3,this._endNorm=new n.Vector3,this._cameraScale=new n.Vector3,this._parentPosition=new n.Vector3,this._parentQuaternion=new n.Quaternion,this._parentQuaternionInv=new n.Quaternion,this._parentScale=new n.Vector3,this._worldScaleStart=new n.Vector3,this._worldQuaternionInv=new n.Quaternion,this._worldScale=new n.Vector3,this._positionStart=new n.Vector3,this._quaternionStart=new n.Quaternion,this._scaleStart=new n.Vector3,this._getPointer=T.bind(this),this._onPointerDown=w.bind(this),this._onPointerHover=y.bind(this),this._onPointerMove=S.bind(this),this._onPointerUp=E.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(e){if(void 0===this.object||!0===this.dragging)return;o.setFromCamera(e,this.camera);const t=_(this._gizmo.picker[this.mode],o);this.axis=t?t.object.name:null}pointerDown(e){if(void 0!==this.object&&!0!==this.dragging&&0===e.button&&null!==this.axis){o.setFromCamera(e,this.camera);const t=_(this._plane,o,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,f.mode=this.mode,this.dispatchEvent(f)}}pointerMove(e){const t=this.axis,r=this.mode,object=this.object;let n=this.space;if("scale"===r?n="local":"E"!==t&&"XYZE"!==t&&"XYZ"!==t||(n="world"),void 0===object||null===t||!1===this.dragging||-1!==e.button)return;o.setFromCamera(e,this.camera);const f=_(this._plane,o,!0);if(f){if(this.pointEnd.copy(f.point).sub(this.worldPositionStart),"translate"===r)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===n&&"XYZ"!==t&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===t.indexOf("X")&&(this._offset.x=0),-1===t.indexOf("Y")&&(this._offset.y=0),-1===t.indexOf("Z")&&(this._offset.z=0),"local"===n&&"XYZ"!==t?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),object.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===n&&(object.position.applyQuaternion(h.copy(this._quaternionStart).invert()),-1!==t.search("X")&&(object.position.x=Math.round(object.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(object.position.y=Math.round(object.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(object.position.z=Math.round(object.position.z/this.translationSnap)*this.translationSnap),object.position.applyQuaternion(this._quaternionStart)),"world"===n&&(object.parent&&object.position.add(l.setFromMatrixPosition(object.parent.matrixWorld)),-1!==t.search("X")&&(object.position.x=Math.round(object.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(object.position.y=Math.round(object.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(object.position.z=Math.round(object.position.z/this.translationSnap)*this.translationSnap),object.parent&&object.position.sub(l.setFromMatrixPosition(object.parent.matrixWorld))));else if("scale"===r){if(-1!==t.search("XYZ")){let e=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(e*=-1),c.set(e,e,e)}else l.copy(this.pointStart),c.copy(this.pointEnd),l.applyQuaternion(this._worldQuaternionInv),c.applyQuaternion(this._worldQuaternionInv),c.divide(l),-1===t.search("X")&&(c.x=1),-1===t.search("Y")&&(c.y=1),-1===t.search("Z")&&(c.z=1);object.scale.copy(this._scaleStart).multiply(c),this.scaleSnap&&(-1!==t.search("X")&&(object.scale.x=Math.round(object.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Y")&&(object.scale.y=Math.round(object.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Z")&&(object.scale.z=Math.round(object.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===r){this._offset.copy(this.pointEnd).sub(this.pointStart);const e=20/this.worldPosition.distanceTo(l.setFromMatrixPosition(this.camera.matrixWorld));"E"===t?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):"XYZE"===t?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(l.copy(this.rotationAxis).cross(this.eye))*e):"X"!==t&&"Y"!==t&&"Z"!==t||(this.rotationAxis.copy(d[t]),l.copy(d[t]),"local"===n&&l.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(l.cross(this.eye).normalize())*e),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===n&&"E"!==t&&"XYZE"!==t?(object.quaternion.copy(this._quaternionStart),object.quaternion.multiply(h.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),object.quaternion.copy(h.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),object.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(m),this.dispatchEvent(x)}}pointerUp(e){0===e.button&&(this.dragging&&null!==this.axis&&(v.mode=this.mode,this.dispatchEvent(v)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))}attach(object){return this.object=object,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(m),this.dispatchEvent(x),this.pointStart.copy(this.pointEnd))}getRaycaster(){return o}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function T(e){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:e.button};{const rect=this.domElement.getBoundingClientRect();return{x:(e.clientX-rect.left)/rect.width*2-1,y:-(e.clientY-rect.top)/rect.height*2+1,button:e.button}}}function y(e){if(this.enabled)switch(e.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(e))}}function w(e){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(e.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(e)),this.pointerDown(this._getPointer(e)))}function S(e){this.enabled&&this.pointerMove(this._getPointer(e))}function E(e){this.enabled&&(this.domElement.releasePointerCapture(e.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(e)))}function _(object,e,t){const r=e.intersectObject(object,!0);for(let i=0;i<r.length;i++)if(r[i].object.visible||t)return r[i];return!1}M.prototype.isTransformControls=!0;const R=new n.Euler,A=new n.Vector3(0,1,0),P=new n.Vector3(0,0,0),C=new n.Matrix4,I=new n.Quaternion,L=new n.Quaternion,O=new n.Vector3,B=new n.Matrix4,D=new n.Vector3(1,0,0),N=new n.Vector3(0,1,0),F=new n.Vector3(0,0,1),U=new n.Vector3,k=new n.Vector3,H=new n.Vector3;class G extends n.Object3D{constructor(){super(),this.type="TransformControlsGizmo";const e=new n.MeshBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new n.LineBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),r=e.clone();r.opacity=.15;const o=t.clone();o.opacity=.5;const l=e.clone();l.color.setHex(16711680);const c=e.clone();c.color.setHex(65280);const h=e.clone();h.color.setHex(255);const d=e.clone();d.color.setHex(16711680),d.opacity=.5;const m=e.clone();m.color.setHex(65280),m.opacity=.5;const f=e.clone();f.color.setHex(255),f.opacity=.5;const v=e.clone();v.opacity=.25;const x=e.clone();x.color.setHex(16776960),x.opacity=.25;e.clone().color.setHex(16776960);const M=e.clone();M.color.setHex(7895160);const T=new n.CylinderGeometry(0,.04,.1,12);T.translate(0,.05,0);const y=new n.BoxGeometry(.08,.08,.08);y.translate(0,.04,0);const w=new n.BufferGeometry;w.setAttribute("position",new n.Float32BufferAttribute([0,0,0,1,0,0],3));const S=new n.CylinderGeometry(.0075,.0075,.5,3);function E(e,t){const r=new n.TorusGeometry(e,.0075,3,64,t*Math.PI*2);return r.rotateY(Math.PI/2),r.rotateX(Math.PI/2),r}S.translate(0,.25,0);const _={X:[[new n.Mesh(T,l),[.5,0,0],[0,0,-Math.PI/2]],[new n.Mesh(T,l),[-.5,0,0],[0,0,Math.PI/2]],[new n.Mesh(S,l),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new n.Mesh(T,c),[0,.5,0]],[new n.Mesh(T,c),[0,-.5,0],[Math.PI,0,0]],[new n.Mesh(S,c)]],Z:[[new n.Mesh(T,h),[0,0,.5],[Math.PI/2,0,0]],[new n.Mesh(T,h),[0,0,-.5],[-Math.PI/2,0,0]],[new n.Mesh(S,h),null,[Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.OctahedronGeometry(.1,0),v.clone()),[0,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),f.clone()),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),d.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),m.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},R={X:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[.3,0,0],[0,0,-Math.PI/2]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,.3,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,-.3,0],[0,0,Math.PI]]],Z:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,.3],[Math.PI/2,0,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.OctahedronGeometry(.2,0),r)]],XY:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,0,.15],[-Math.PI/2,0,0]]]},A={START:[[new n.Mesh(new n.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],END:[[new n.Mesh(new n.OctahedronGeometry(.01,2),o),null,null,null,"helper"]],DELTA:[[new n.Line(function(){const e=new n.BufferGeometry;return e.setAttribute("position",new n.Float32BufferAttribute([0,0,0,1,1,1],3)),e}(),o),null,null,null,"helper"]],X:[[new n.Line(w,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new n.Line(w,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new n.Line(w,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},P={XYZE:[[new n.Mesh(E(.5,1),M),null,[0,Math.PI/2,0]]],X:[[new n.Mesh(E(.5,.5),l)]],Y:[[new n.Mesh(E(.5,.5),c),null,[0,0,-Math.PI/2]]],Z:[[new n.Mesh(E(.5,.5),h),null,[0,Math.PI/2,0]]],E:[[new n.Mesh(E(.75,1),x),null,[0,Math.PI/2,0]]]},C={AXIS:[[new n.Line(w,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},I={XYZE:[[new n.Mesh(new n.SphereGeometry(.25,10,8),r)]],X:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[Math.PI/2,0,0]]],Z:[[new n.Mesh(new n.TorusGeometry(.5,.1,4,24),r),[0,0,0],[0,0,-Math.PI/2]]],E:[[new n.Mesh(new n.TorusGeometry(.75,.1,2,24),r)]]},L={X:[[new n.Mesh(y,l),[.5,0,0],[0,0,-Math.PI/2]],[new n.Mesh(S,l),[0,0,0],[0,0,-Math.PI/2]],[new n.Mesh(y,l),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(y,c),[0,.5,0]],[new n.Mesh(S,c)],[new n.Mesh(y,c),[0,-.5,0],[0,0,Math.PI]]],Z:[[new n.Mesh(y,h),[0,0,.5],[Math.PI/2,0,0]],[new n.Mesh(S,h),[0,0,0],[Math.PI/2,0,0]],[new n.Mesh(y,h),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),f),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),d),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.15,.15,.01),m),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.BoxGeometry(.1,.1,.1),v.clone())]]},O={X:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[.3,0,0],[0,0,-Math.PI/2]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,.3,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,-.3,0],[0,0,Math.PI]]],Z:[[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,.3],[Math.PI/2,0,0]],[new n.Mesh(new n.CylinderGeometry(.2,0,.6,4),r),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,.15,0]]],YZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.01),r),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new n.Mesh(new n.BoxGeometry(.2,.2,.2),r),[0,0,0]]]},B={X:[[new n.Line(w,o.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new n.Line(w,o.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new n.Line(w,o.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function D(e){const t=new n.Object3D;for(const r in e)for(let i=e[r].length;i--;){const object=e[r][i][0].clone(),n=e[r][i][1],o=e[r][i][2],l=e[r][i][3],c=e[r][i][4];object.name=r,object.tag=c,n&&object.position.set(n[0],n[1],n[2]),o&&object.rotation.set(o[0],o[1],o[2]),l&&object.scale.set(l[0],l[1],l[2]),object.updateMatrix();const h=object.geometry.clone();h.applyMatrix4(object.matrix),object.geometry=h,object.renderOrder=1/0,object.position.set(0,0,0),object.rotation.set(0,0,0),object.scale.set(1,1,1),t.add(object)}return t}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=D(_)),this.add(this.gizmo.rotate=D(P)),this.add(this.gizmo.scale=D(L)),this.add(this.picker.translate=D(R)),this.add(this.picker.rotate=D(I)),this.add(this.picker.scale=D(O)),this.add(this.helper.translate=D(A)),this.add(this.helper.rotate=D(C)),this.add(this.helper.scale=D(B)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const t="local"===("scale"===this.mode?"local":this.space)?this.worldQuaternion:L;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let r=[];r=r.concat(this.picker[this.mode].children),r=r.concat(this.gizmo[this.mode].children),r=r.concat(this.helper[this.mode].children);for(let i=0;i<r.length;i++){const e=r[i];let n;if(e.visible=!0,e.rotation.set(0,0,0),e.position.copy(this.worldPosition),n=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),e.scale.set(1,1,1).multiplyScalar(n*this.size/4),"helper"!==e.tag){if(e.quaternion.copy(t),"translate"===this.mode||"scale"===this.mode){const r=.99,n=.2;"X"===e.name&&Math.abs(A.copy(D).applyQuaternion(t).dot(this.eye))>r&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"Y"===e.name&&Math.abs(A.copy(N).applyQuaternion(t).dot(this.eye))>r&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"Z"===e.name&&Math.abs(A.copy(F).applyQuaternion(t).dot(this.eye))>r&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"XY"===e.name&&Math.abs(A.copy(F).applyQuaternion(t).dot(this.eye))<n&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"YZ"===e.name&&Math.abs(A.copy(D).applyQuaternion(t).dot(this.eye))<n&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1),"XZ"===e.name&&Math.abs(A.copy(N).applyQuaternion(t).dot(this.eye))<n&&(e.scale.set(1e-10,1e-10,1e-10),e.visible=!1)}else"rotate"===this.mode&&(I.copy(t),A.copy(this.eye).applyQuaternion(h.copy(t).invert()),-1!==e.name.search("E")&&e.quaternion.setFromRotationMatrix(C.lookAt(this.eye,P,N)),"X"===e.name&&(h.setFromAxisAngle(D,Math.atan2(-A.y,A.z)),h.multiplyQuaternions(I,h),e.quaternion.copy(h)),"Y"===e.name&&(h.setFromAxisAngle(N,Math.atan2(A.x,A.z)),h.multiplyQuaternions(I,h),e.quaternion.copy(h)),"Z"===e.name&&(h.setFromAxisAngle(F,Math.atan2(A.y,A.x)),h.multiplyQuaternions(I,h),e.quaternion.copy(h)));e.visible=e.visible&&(-1===e.name.indexOf("X")||this.showX),e.visible=e.visible&&(-1===e.name.indexOf("Y")||this.showY),e.visible=e.visible&&(-1===e.name.indexOf("Z")||this.showZ),e.visible=e.visible&&(-1===e.name.indexOf("E")||this.showX&&this.showY&&this.showZ),e.material._color=e.material._color||e.material.color.clone(),e.material._opacity=e.material._opacity||e.material.opacity,e.material.color.copy(e.material._color),e.material.opacity=e.material._opacity,this.enabled&&this.axis&&(e.name===this.axis||this.axis.split("").some((function(a){return e.name===a})))&&(e.material.color.setHex(16776960),e.material.opacity=1)}else e.visible=!1,"AXIS"===e.name?(e.position.copy(this.worldPositionStart),e.visible=!!this.axis,"X"===this.axis&&(h.setFromEuler(R.set(0,0,0)),e.quaternion.copy(t).multiply(h),Math.abs(A.copy(D).applyQuaternion(t).dot(this.eye))>.9&&(e.visible=!1)),"Y"===this.axis&&(h.setFromEuler(R.set(0,0,Math.PI/2)),e.quaternion.copy(t).multiply(h),Math.abs(A.copy(N).applyQuaternion(t).dot(this.eye))>.9&&(e.visible=!1)),"Z"===this.axis&&(h.setFromEuler(R.set(0,Math.PI/2,0)),e.quaternion.copy(t).multiply(h),Math.abs(A.copy(F).applyQuaternion(t).dot(this.eye))>.9&&(e.visible=!1)),"XYZE"===this.axis&&(h.setFromEuler(R.set(0,Math.PI/2,0)),A.copy(this.rotationAxis),e.quaternion.setFromRotationMatrix(C.lookAt(P,A,N)),e.quaternion.multiply(h),e.visible=this.dragging),"E"===this.axis&&(e.visible=!1)):"START"===e.name?(e.position.copy(this.worldPositionStart),e.visible=this.dragging):"END"===e.name?(e.position.copy(this.worldPosition),e.visible=this.dragging):"DELTA"===e.name?(e.position.copy(this.worldPositionStart),e.quaternion.copy(this.worldQuaternionStart),l.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),l.applyQuaternion(this.worldQuaternionStart.clone().invert()),e.scale.copy(l),e.visible=this.dragging):(e.quaternion.copy(t),this.dragging?e.position.copy(this.worldPositionStart):e.position.copy(this.worldPosition),this.axis&&(e.visible=-1!==this.axis.search(e.name)))}super.updateMatrixWorld(e)}}G.prototype.isTransformControlsGizmo=!0;class V extends n.Mesh{constructor(){super(new n.PlaneGeometry(1e5,1e5,2,2),new n.MeshBasicMaterial({visible:!1,wireframe:!0,side:n.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(e){let t=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(t="local"),U.copy(D).applyQuaternion("local"===t?this.worldQuaternion:L),k.copy(N).applyQuaternion("local"===t?this.worldQuaternion:L),H.copy(F).applyQuaternion("local"===t?this.worldQuaternion:L),A.copy(k),this.mode){case"translate":case"scale":switch(this.axis){case"X":A.copy(this.eye).cross(U),O.copy(U).cross(A);break;case"Y":A.copy(this.eye).cross(k),O.copy(k).cross(A);break;case"Z":A.copy(this.eye).cross(H),O.copy(H).cross(A);break;case"XY":O.copy(H);break;case"YZ":O.copy(U);break;case"XZ":A.copy(H),O.copy(k);break;case"XYZ":case"E":O.set(0,0,0)}break;default:O.set(0,0,0)}0===O.length()?this.quaternion.copy(this.cameraQuaternion):(B.lookAt(l.set(0,0,0),O,A),this.quaternion.setFromRotationMatrix(B)),super.updateMatrixWorld(e)}}V.prototype.isTransformControlsPlane=!0},696:function(e,t,r){"use strict";r.d(t,"a",(function(){return m}));var n=r(17),o=r(689),l=r(685),c=r(684);class h extends c.b{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,r){const n=e.getContext(),o=e.state;let l,c;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(l=0,c=1):(l=1,c=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(n.REPLACE,n.REPLACE,n.REPLACE),o.buffers.stencil.setFunc(n.ALWAYS,l,4294967295),o.buffers.stencil.setClear(c),o.buffers.stencil.setLocked(!0),e.setRenderTarget(r),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(n.EQUAL,1,4294967295),o.buffers.stencil.setOp(n.KEEP,n.KEEP,n.KEEP),o.buffers.stencil.setLocked(!0)}}class d extends c.b{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class m{constructor(e,t){if(this.renderer=e,void 0===t){const r=e.getSize(new n.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=r.width,this._height=r.height,(t=new n.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===o.a&&console.error("THREE.EffectComposer relies on CopyShader"),void 0===l.a&&console.error("THREE.EffectComposer relies on ShaderPass"),this.copyPass=new l.a(o.a),this.clock=new n.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let i=e+1;i<this.passes.length;i++)if(this.passes[i].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let r=!1;for(let i=0,t=this.passes.length;i<t;i++){const t=this.passes[i];if(!1!==t.enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(i),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,r),t.needsSwap){if(r){const t=this.renderer.getContext(),r=this.renderer.state.buffers.stencil;r.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),r.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==h&&(t instanceof h?r=!0:t instanceof d&&(r=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new n.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const r=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(r,n),this.renderTarget2.setSize(r,n);for(let i=0;i<this.passes.length;i++)this.passes[i].setSize(r,n)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}new n.OrthographicCamera(-1,1,1,-1,0,1);const f=new n.BufferGeometry;f.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),f.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2))}}]);